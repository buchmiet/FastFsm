using System;
using System.IO;
using System.Linq;
using FastFsm.HsmPrototype.Core;
using FastFsm.HsmPrototype.TestModels;

Console.WriteLine("=== FastFSM HSM Prototype Generator ===\n");

// Create test model
var model = SimpleHierarchy.Create();
Console.WriteLine($"Model: {model.ClassName}");
Console.WriteLine($"States: {string.Join(", ", model.States.Keys)}");
Console.WriteLine($"Transitions: {model.Transitions.Count}");
Console.WriteLine($"Hierarchy: {string.Join(", ", model.ChildrenOf.Select(kv => $"{kv.Key}->[{string.Join(",", kv.Value)}]"))}");

Console.WriteLine("\n=== Hierarchy Info ===");
foreach (var state in model.States.Values)
{
    if (state.ParentState != null)
    {
        Console.WriteLine($"{state.Name} -> Parent: {state.ParentState}");
    }
    if (state.IsInitial)
    {
        Console.WriteLine($"{state.Name} is INITIAL for {state.ParentState}");
    }
}

Console.WriteLine("\n=== Transitions by Priority ===");
var byPriority = model.Transitions
    .OrderByDescending(t => t.Priority)
    .ThenBy(t => t.FromState)
    .ThenBy(t => t.Trigger);

foreach (var t in byPriority)
{
    Console.WriteLine($"[{t.Priority,3}] {t.FromState} + {t.Trigger} -> {t.ToState}" +
                      $"{(t.IsInternal ? " (INTERNAL)" : "")}" +
                      $"{(!string.IsNullOrEmpty(t.GuardMethod) ? $" [guard: {t.GuardMethod}]" : "")}" +
                      $"{(!string.IsNullOrEmpty(t.ActionMethod) ? $" [action: {t.ActionMethod}]" : "")}");
}
Console.WriteLine();

// Generate code
var generator = new HierarchicalCodeGenerator(model);
var generatedCode = generator.Generate();

Console.WriteLine("=== Generated Code ===\n");
Console.WriteLine(generatedCode);

// Save to file
var outputPath = "Output/SimpleHierarchy.generated.cs";
Directory.CreateDirectory("Output");
File.WriteAllText(outputPath, generatedCode);
Console.WriteLine($"\nCode saved to: {outputPath}");

// Test history model
Console.WriteLine("\n=== Testing History Model ===\n");
var historyModel = HistoryHierarchy.Create();
Console.WriteLine($"History Model: {historyModel.ClassName}");
Console.WriteLine($"States with history:");
foreach (var kvp in historyModel.HistoryOf)
{
    Console.WriteLine($"  {kvp.Key}: {kvp.Value}");
}

var historyGen = new HierarchicalCodeGenerator(historyModel);
var historyCode = historyGen.Generate();

Console.WriteLine("\n=== History Generated Code (excerpt) ===\n");
// Show only first 50 lines
var historyLines = historyCode.Split('\n').Take(50);
foreach (var line in historyLines)
{
    Console.WriteLine(line);
}

File.WriteAllText("Output/HistoryHierarchy.generated.cs", historyCode);
Console.WriteLine($"\nHistory code saved to: Output/HistoryHierarchy.generated.cs");
using System.Collections.Generic;
using System.Linq;
using FastFsm.HsmPrototype.Helpers;
using Generator.Model;

namespace FastFsm.HsmPrototype.Core;

public class HierarchicalCodeGenerator
{
    private readonly StateMachineModel _model;
    private readonly IndentedStringBuilder _sb = new();
    
    public HierarchicalCodeGenerator(StateMachineModel model)
    {
        _model = model;
    }
    
    public string Generate()
    {
        _sb.AppendLine("// Generated Hierarchical State Machine");
        _sb.AppendLine($"namespace {_model.Namespace};");
        _sb.AppendLine();
        
        _sb.AppendLine($"public partial class {_model.ClassName}");
        _sb.OpenBrace();
        
        GenerateFields();
        _sb.AppendLine();
        GenerateFireMethod();
        _sb.AppendLine();
        GenerateHistoryHelperMethods();
        
        _sb.CloseBrace();
        
        return _sb.ToString();
    }
    
    private void GenerateFields()
    {
        _sb.AppendLine($"private {_model.StateType} _currentState;");
        _sb.AppendLine();
        
        // Generate history fields
        GenerateHistoryFields();
        _sb.AppendLine();
        
        // Generate delegates for callbacks
        foreach (var state in _model.States.Values)
        {
            if (!string.IsNullOrEmpty(state.OnEntryMethod))
            {
                _sb.AppendLine($"private Action? {state.OnEntryMethod};");
            }
            if (!string.IsNullOrEmpty(state.OnExitMethod))
            {
                _sb.AppendLine($"private Action? {state.OnExitMethod};");
            }
        }
    }
    
    private void GenerateHistoryFields()
    {
        foreach (var kvp in _model.HistoryOf)
        {
            var stateName = kvp.Key;
            var historyMode = kvp.Value;
            
            if (historyMode == HistoryMode.Shallow)
            {
                _sb.AppendLine($"// Shallow history for {stateName}");
                _sb.AppendLine($"private {_model.StateType}? _history_{stateName};");
            }
            else if (historyMode == HistoryMode.Deep)
            {
                _sb.AppendLine($"// Deep history for {stateName}");
                _sb.AppendLine($"private {_model.StateType}? _historyDeep_{stateName};");
            }
        }
    }
    
    private void GenerateFireMethod()
    {
        _sb.AppendLine($"public void Fire({_model.TriggerType} trigger)");
        _sb.OpenBrace();
        
        _sb.AppendLine("switch (_currentState)");
        _sb.OpenBrace();
        
        // Group transitions by FromState
        var transitionsByState = _model.Transitions
            .GroupBy(t => t.FromState)
            .OrderBy(g => g.Key);
        
        foreach (var group in transitionsByState)
        {
            _sb.AppendLine($"case {_model.StateType}.{group.Key}:");
            _sb.Indent();
            
            // Sort transitions by priority (descending) then by order of definition
            var sortedTransitions = group
                .Select((t, index) => new { Transition = t, Index = index })
                .OrderByDescending(x => x.Transition.Priority)
                .ThenBy(x => x.Index)
                .Select(x => x.Transition);
            
            foreach (var transition in sortedTransitions)
            {
                GenerateCaseForTransition(transition);
            }
            
            // Add fallthrough to parent if this state has a parent
            if (_model.ParentOf.ContainsKey(group.Key) && _model.ParentOf[group.Key] != null)
            {
                var parent = _model.ParentOf[group.Key];
                _sb.AppendLine($"// Fallthrough to parent");
                _sb.AppendLine($"goto case {_model.StateType}.{parent};");
            }
            else
            {
                _sb.AppendLine("break;");
            }
            
            _sb.Outdent();
        }
        
        _sb.CloseBrace(); // switch
        _sb.CloseBrace(); // method
    }
    
    private void GenerateCaseForTransition(TransitionModel transition)
    {
        // Generate if statement with guard
        if (!string.IsNullOrEmpty(transition.GuardMethod))
        {
            _sb.AppendLine($"if (trigger == {_model.TriggerType}.{transition.Trigger} && {transition.GuardMethod}())");
        }
        else
        {
            _sb.AppendLine($"if (trigger == {_model.TriggerType}.{transition.Trigger})");
        }
        
        _sb.OpenBrace();
        
        // Add priority comment for debugging
        _sb.AppendLine($"// Priority: {transition.Priority}, Internal: {transition.IsInternal}");
        
        if (transition.IsInternal)
        {
            GenerateInternalTransition(transition);
        }
        else
        {
            GenerateTransitionCode(transition);
        }
        
        _sb.AppendLine("return;");
        _sb.CloseBrace();
    }
    
    private void GenerateInternalTransition(TransitionModel transition)
    {
        _sb.AppendLine($"// Internal transition in {transition.FromState}");
        
        // Execute action if present
        if (!string.IsNullOrEmpty(transition.ActionMethod))
        {
            _sb.AppendLine($"{transition.ActionMethod}();");
        }
        
        // No state change, no exit/entry
        _sb.AppendLine("// State remains: " + transition.FromState);
    }
    
    private void GenerateTransitionCode(TransitionModel transition)
    {
        var fromState = transition.FromState;
        var toStateName = transition.ToState!;
        
        // Check if target has history
        if (_model.HistoryOf.ContainsKey(toStateName))
        {
            GenerateHistoryTransition(transition);
        }
        else
        {
            // Determine actual target state (handle composite states)
            var actualTargetState = DetermineActualTargetState(toStateName);
            
            // Find LCA between source and actual target
            var lca = FindLowestCommonAncestor(fromState, actualTargetState);
            
            _sb.AppendLine($"// Transition: {fromState} -> {actualTargetState} (LCA: {lca ?? "none"})");
            
            // Generate exit sequence up to (but not including) LCA
            GenerateExitSequenceUpTo(fromState, lca);
            
            // Execute transition action if present
            if (!string.IsNullOrEmpty(transition.ActionMethod))
            {
                _sb.AppendLine($"// Transition action");
                _sb.AppendLine($"{transition.ActionMethod}();");
            }
            
            // Generate entry sequence from (but not including) LCA to target
            GenerateEntrySequenceFrom(lca, toStateName, actualTargetState);
            
            // Set the current state
            _sb.AppendLine($"_currentState = {_model.StateType}.{actualTargetState};");
        }
    }
    
    private void GenerateHistoryTransition(TransitionModel transition)
    {
        var fromState = transition.FromState;
        var toStateName = transition.ToState!;
        var historyMode = _model.HistoryOf[toStateName];
        
        _sb.AppendLine($"// Transition to {toStateName} with {historyMode} history");
        
        // Find LCA between source and target for proper exit sequence
        var lca = FindLowestCommonAncestor(fromState, toStateName);
        
        // Exit from source up to LCA
        GenerateExitSequenceUpTo(fromState, lca);
        
        // Execute transition action if present
        if (!string.IsNullOrEmpty(transition.ActionMethod))
        {
            _sb.AppendLine($"// Transition action");
            _sb.AppendLine($"{transition.ActionMethod}();");
        }
        
        // Check for saved history
        string historyField = historyMode == HistoryMode.Shallow 
            ? $"_history_{toStateName}" 
            : $"_historyDeep_{toStateName}";
            
        _sb.AppendLine($"if ({historyField}.HasValue)");
        _sb.OpenBrace();
        
        if (historyMode == HistoryMode.Shallow)
        {
            _sb.AppendLine($"// Restore shallow history");
            _sb.AppendLine($"var targetState = {historyField}.Value;");
            
            // Generate entry sequence from LCA to target parent
            GenerateEntrySequenceFrom(lca, toStateName, toStateName);
            
            // Then dispatch to the historical child
            _sb.AppendLine($"// Enter historical child");
            _sb.AppendLine($"switch (targetState)");
            _sb.OpenBrace();
            
            if (_model.ChildrenOf.ContainsKey(toStateName))
            {
                foreach (var child in _model.ChildrenOf[toStateName])
                {
                    _sb.AppendLine($"case {_model.StateType}.{child}:");
                    _sb.Indent();
                    GenerateEntryForState(child);
                    _sb.AppendLine($"_currentState = {_model.StateType}.{child};");
                    _sb.AppendLine("break;");
                    _sb.Outdent();
                }
            }
            
            _sb.CloseBrace(); // switch
        }
        else // Deep history
        {
            _sb.AppendLine($"// Restore deep history");
            _sb.AppendLine($"var targetState = {historyField}.Value;");
            
            // Need to generate entry sequence for all states from LCA to target
            _sb.AppendLine($"// Enter all states from LCA to historical state");
            _sb.AppendLine($"switch (targetState)");
            _sb.OpenBrace();
            
            // Generate cases for all possible deep states
            var allDeepStates = GetAllDescendants(toStateName);
            foreach (var deepState in allDeepStates)
            {
                _sb.AppendLine($"case {_model.StateType}.{deepState}:");
                _sb.Indent();
                
                // Generate entry sequence from LCA to deepState
                GenerateEntrySequenceFrom(lca, toStateName, deepState);
                
                _sb.AppendLine($"_currentState = {_model.StateType}.{deepState};");
                _sb.AppendLine("break;");
                _sb.Outdent();
            }
            
            _sb.CloseBrace(); // switch
        }
        
        _sb.CloseBrace(); // if has history
        _sb.AppendLine("else");
        _sb.OpenBrace();
        
        // No history - use initial state
        var initialChild = _model.InitialChildOf.ContainsKey(toStateName) 
            ? _model.InitialChildOf[toStateName] 
            : toStateName;
            
        _sb.AppendLine($"// No history, enter default");
        
        // Generate normal entry sequence
        var actualTarget = DetermineActualTargetState(toStateName);
        GenerateEntrySequenceFrom(null, toStateName, actualTarget);
        _sb.AppendLine($"_currentState = {_model.StateType}.{actualTarget};");
        
        _sb.CloseBrace(); // else
    }
    
    private void GenerateEntryForState(string state)
    {
        if (_model.States.ContainsKey(state))
        {
            var stateModel = _model.States[state];
            if (!string.IsNullOrEmpty(stateModel.OnEntryMethod))
            {
                _sb.AppendLine($"{stateModel.OnEntryMethod}?.Invoke();");
            }
        }
    }
    
    private List<string> GetAllDescendants(string state)
    {
        var descendants = new List<string>();
        
        if (_model.ChildrenOf.ContainsKey(state))
        {
            foreach (var child in _model.ChildrenOf[state])
            {
                descendants.Add(child);
                descendants.AddRange(GetAllDescendants(child));
            }
        }
        
        return descendants;
    }
    
    private List<string> BuildPathFromTo(string from, string to)
    {
        var path = new List<string>();
        
        // Build path from 'to' up to (but not including) 'from'
        var current = to;
        var reversePath = new List<string>();
        
        while (current != null && current != from)
        {
            reversePath.Add(current);
            current = _model.ParentOf.ContainsKey(current) ? _model.ParentOf[current] : null;
        }
        
        // Add 'from' at the beginning
        path.Add(from);
        
        // Add the rest in reverse order
        reversePath.Reverse();
        path.AddRange(reversePath);
        
        return path;
    }
    
    private string DetermineActualTargetState(string targetState)
    {
        // If target is composite, return its initial child (unless history overrides)
        if (_model.ChildrenOf.ContainsKey(targetState) && 
            _model.InitialChildOf.ContainsKey(targetState))
        {
            return _model.InitialChildOf[targetState];
        }
        
        // Otherwise return the target itself
        return targetState;
    }
    
    private void GenerateExitSequenceUpTo(string fromState, string? stopBefore)
    {
        var exitPath = new List<string>();
        var current = fromState;
        
        // Build path from current to (but not including) stopBefore
        while (current != null && current != stopBefore)
        {
            exitPath.Add(current);
            current = _model.ParentOf.ContainsKey(current) ? _model.ParentOf[current] : null;
        }
        
        // Execute exits from child to parent
        foreach (var state in exitPath)
        {
            var stateModel = _model.States[state];
            
            // Save history if this state has history
            if (_model.HistoryOf.ContainsKey(state))
            {
                var historyMode = _model.HistoryOf[state];
                if (historyMode == HistoryMode.Shallow)
                {
                    // Save the current direct child
                    var currentChild = GetDirectChildOf(state, fromState);
                    if (currentChild != null)
                    {
                        _sb.AppendLine($"// Save shallow history for {state}");
                        _sb.AppendLine($"_history_{state} = {_model.StateType}.{currentChild};");
                    }
                }
                else if (historyMode == HistoryMode.Deep)
                {
                    _sb.AppendLine($"// Save deep history for {state}");
                    _sb.AppendLine($"_historyDeep_{state} = _currentState;");
                }
            }
            
            if (!string.IsNullOrEmpty(stateModel.OnExitMethod))
            {
                _sb.AppendLine($"// Exit {state}");
                _sb.AppendLine($"{stateModel.OnExitMethod}?.Invoke();");
            }
        }
    }
    
    private string? GetDirectChildOf(string parent, string descendant)
    {
        // Find the direct child of parent that contains descendant
        var current = descendant;
        var previous = current;
        
        while (current != null && current != parent)
        {
            previous = current;
            current = _model.ParentOf.ContainsKey(current) ? _model.ParentOf[current] : null;
            
            if (current == parent)
            {
                return previous;
            }
        }
        
        return null;
    }
    
    private void GenerateEntrySequenceFrom(string? startAfter, string targetState, string actualTargetState)
    {
        var entryPath = new List<string>();
        
        // Build full path to actual target
        var fullPath = new List<string>();
        var current = actualTargetState;
        
        while (current != null)
        {
            fullPath.Insert(0, current); // Insert at beginning to reverse order
            current = _model.ParentOf.ContainsKey(current) ? _model.ParentOf[current] : null;
        }
        
        // If target is composite and different from actual, ensure it's in path
        if (targetState != actualTargetState && _model.ChildrenOf.ContainsKey(targetState))
        {
            if (!fullPath.Contains(targetState))
            {
                // Find where to insert it
                var actualParent = _model.ParentOf.ContainsKey(actualTargetState) 
                    ? _model.ParentOf[actualTargetState] : null;
                if (actualParent == targetState)
                {
                    var index = fullPath.IndexOf(actualTargetState);
                    fullPath.Insert(index, targetState);
                }
            }
        }
        
        // Skip everything up to and including startAfter
        bool foundStart = startAfter == null;
        foreach (var state in fullPath)
        {
            if (foundStart)
            {
                entryPath.Add(state);
            }
            if (state == startAfter)
            {
                foundStart = true;
            }
        }
        
        // Execute entries from parent to child
        foreach (var state in entryPath)
        {
            var stateModel = _model.States[state];
            if (!string.IsNullOrEmpty(stateModel.OnEntryMethod))
            {
                _sb.AppendLine($"// Enter {state}");
                _sb.AppendLine($"{stateModel.OnEntryMethod}?.Invoke();");
            }
        }
    }
    
    private bool AreInSameHierarchy(string state1, string state2)
    {
        // Check if states share a common parent
        var parent1 = _model.ParentOf.ContainsKey(state1) ? _model.ParentOf[state1] : null;
        var parent2 = _model.ParentOf.ContainsKey(state2) ? _model.ParentOf[state2] : null;
        
        return parent1 != null && parent1 == parent2;
    }
    
    private List<string> GetAncestors(string state)
    {
        var ancestors = new List<string>();
        var current = state;
        
        while (current != null)
        {
            ancestors.Add(current);
            current = _model.ParentOf.ContainsKey(current) ? _model.ParentOf[current] : null;
        }
        
        return ancestors;
    }
    
    private string? FindLowestCommonAncestor(string state1, string state2)
    {
        var ancestors1 = GetAncestors(state1);
        var ancestors2 = GetAncestors(state2);
        
        // Find first common ancestor
        foreach (var ancestor in ancestors1)
        {
            if (ancestors2.Contains(ancestor))
            {
                return ancestor;
            }
        }
        
        return null; // No common ancestor (different hierarchies)
    }
    
    private void GenerateHistoryHelperMethods()
    {
        if (!_model.HistoryOf.Any())
            return;
            
        // Generate RestoreFromHistory method
        _sb.AppendLine("private void RestoreFromHistory(string targetState)");
        _sb.OpenBrace();
        _sb.AppendLine("// This method handles runtime dispatch to historical states");
        
        foreach (var kvp in _model.HistoryOf)
        {
            var stateName = kvp.Key;
            var historyMode = kvp.Value;
            
            _sb.AppendLine($"if (targetState == \"{stateName}\")");
            _sb.OpenBrace();
            
            if (historyMode == HistoryMode.Shallow)
            {
                _sb.AppendLine($"if (_history_{stateName}.HasValue)");
                _sb.OpenBrace();
                _sb.AppendLine($"var historicalState = _history_{stateName}.Value;");
                _sb.AppendLine($"// Restore to shallow history");
                _sb.AppendLine($"switch (historicalState)");
                _sb.OpenBrace();
                
                // Generate cases for each direct child
                if (_model.ChildrenOf.ContainsKey(stateName))
                {
                    foreach (var child in _model.ChildrenOf[stateName])
                    {
                        _sb.AppendLine($"case {_model.StateType}.{child}:");
                        _sb.Indent();
                        _sb.AppendLine($"_currentState = {_model.StateType}.{child};");
                        _sb.AppendLine("return;");
                        _sb.Outdent();
                    }
                }
                
                _sb.CloseBrace(); // switch
                _sb.CloseBrace(); // if has value
                
                // Default to initial child
                if (_model.InitialChildOf.ContainsKey(stateName))
                {
                    _sb.AppendLine($"// No history, use initial");
                    _sb.AppendLine($"_currentState = {_model.StateType}.{_model.InitialChildOf[stateName]};");
                }
            }
            else if (historyMode == HistoryMode.Deep)
            {
                _sb.AppendLine($"if (_historyDeep_{stateName}.HasValue)");
                _sb.OpenBrace();
                _sb.AppendLine($"// Restore to deep history");
                _sb.AppendLine($"_currentState = _historyDeep_{stateName}.Value;");
                _sb.AppendLine("return;");
                _sb.CloseBrace();
                
                // Default to initial child
                if (_model.InitialChildOf.ContainsKey(stateName))
                {
                    _sb.AppendLine($"// No history, use initial");
                    _sb.AppendLine($"_currentState = {_model.StateType}.{_model.InitialChildOf[stateName]};");
                }
            }
            
            _sb.CloseBrace(); // if targetState ==
        }
        
        _sb.CloseBrace(); // method
    }
}
using System;
using System.Text;

namespace FastFsm.HsmPrototype.Helpers;

public class IndentedStringBuilder
{
    private readonly StringBuilder _sb = new();
    private int _indentLevel = 0;
    private bool _newLine = true;
    
    public void Indent() => _indentLevel++;
    public void Outdent() => _indentLevel = Math.Max(0, _indentLevel - 1);
    
    public IndentedStringBuilder AppendLine(string text = "")
    {
        if (!string.IsNullOrEmpty(text))
        {
            if (_newLine)
            {
                _sb.Append(new string(' ', _indentLevel * 4));
            }
            _sb.Append(text);
        }
        _sb.AppendLine();
        _newLine = true;
        return this;
    }
    
    public IndentedStringBuilder OpenBrace()
    {
        AppendLine("{");
        Indent();
        return this;
    }
    
    public IndentedStringBuilder CloseBrace()
    {
        Outdent();
        AppendLine("}");
        return this;
    }
    
    public override string ToString() => _sb.ToString();
}
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("FastFsm.HsmPrototype")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+85de538759f71a48e4a730d280118d23ea98d3c1")]
[assembly: System.Reflection.AssemblyProductAttribute("FastFsm.HsmPrototype")]
[assembly: System.Reflection.AssemblyTitleAttribute("FastFsm.HsmPrototype")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

// Generated Hierarchical State Machine
namespace TestNamespace;

public partial class HistoryHsmMachine
{
    private MachineState _currentState;

    // Shallow history for On
    private MachineState? _history_On;
    // Deep history for On_Working
    private MachineState? _historyDeep_On_Working;

    private Action? OnOnEntry;
    private Action? OnOnExit;
    private Action? OnIdleEntry;
    private Action? OnWorkingEntry;
    private Action? OnWorkingExit;
    private Action? OnFastEntry;
    private Action? OnSlowEntry;

    public void Fire(MachineTrigger trigger)
    {
        switch (_currentState)
        {
            case MachineState.Off:
                if (trigger == MachineTrigger.PowerOn)
                {
                    // Priority: 0, Internal: False
                    // Transition to On with Shallow history
                    if (_history_On.HasValue)
                    {
                        // Restore shallow history
                        var targetState = _history_On.Value;
                        // Enter On
                        OnOnEntry?.Invoke();
                        // Enter historical child
                        switch (targetState)
                        {
                            case MachineState.On_Idle:
                                OnIdleEntry?.Invoke();
                                _currentState = MachineState.On_Idle;
                                break;
                            case MachineState.On_Working:
                                OnWorkingEntry?.Invoke();
                                _currentState = MachineState.On_Working;
                                break;
                        }
                    }
                    else
                    {
                        // No history, enter default
                        // Enter On
                        OnOnEntry?.Invoke();
                        // Enter On_Idle
                        OnIdleEntry?.Invoke();
                        _currentState = MachineState.On_Idle;
                    }
                    return;
                }
                break;
            case MachineState.On:
                if (trigger == MachineTrigger.PowerOff)
                {
                    // Priority: 0, Internal: False
                    // Transition: On -> Off (LCA: none)
                    // Exit On
                    OnOnExit?.Invoke();
                    _currentState = MachineState.Off;
                    return;
                }
                break;
            case MachineState.On_Idle:
                if (trigger == MachineTrigger.StartWork)
                {
                    // Priority: 0, Internal: False
                    // Transition to On_Working with Deep history
                    if (_historyDeep_On_Working.HasValue)
                    {
                        // Restore deep history
                        var targetState = _historyDeep_On_Working.Value;
                        // Enter all states from LCA to historical state
                        switch (targetState)
                        {
                            case MachineState.On_Working_Fast:
                                // Enter On_Working
                                OnWorkingEntry?.Invoke();
                                // Enter On_Working_Fast
                                OnFastEntry?.Invoke();
                                _currentState = MachineState.On_Working_Fast;
                                break;
                            case MachineState.On_Working_Slow:
                                // Enter On_Working
                                OnWorkingEntry?.Invoke();
                                // Enter On_Working_Slow
                                OnSlowEntry?.Invoke();
                                _currentState = MachineState.On_Working_Slow;
                                break;
                        }
                    }
                    else
                    {
                        // No history, enter default
                        // Enter On
                        OnOnEntry?.Invoke();
                        // Enter On_Working
                        OnWorkingEntry?.Invoke();
                        // Enter On_Working_Fast
                        OnFastEntry?.Invoke();
                        _currentState = MachineState.On_Working_Fast;
                    }
                    return;
                }
                // Fallthrough to parent
                goto case MachineState.On;
            case MachineState.On_Working:
                if (trigger == MachineTrigger.Stop)
                {
                    // Priority: 0, Internal: False
                    // Transition: On_Working -> On_Idle (LCA: On)
                    // Save deep history for On_Working
                    _historyDeep_On_Working = _currentState;
                    // Exit On_Working
                    OnWorkingExit?.Invoke();
                    // Enter On_Idle
                    OnIdleEntry?.Invoke();
                    _currentState = MachineState.On_Idle;
                    return;
                }
                // Fallthrough to parent
                goto case MachineState.On;
            case MachineState.On_Working_Fast:
                if (trigger == MachineTrigger.Slow)
                {
                    // Priority: 0, Internal: False
                    // Transition: On_Working_Fast -> On_Working_Slow (LCA: On_Working)
                    // Enter On_Working_Slow
                    OnSlowEntry?.Invoke();
                    _currentState = MachineState.On_Working_Slow;
                    return;
                }
                // Fallthrough to parent
                goto case MachineState.On_Working;
            case MachineState.On_Working_Slow:
                if (trigger == MachineTrigger.Fast)
                {
                    // Priority: 0, Internal: False
                    // Transition: On_Working_Slow -> On_Working_Fast (LCA: On_Working)
                    // Enter On_Working_Fast
                    OnFastEntry?.Invoke();
                    _currentState = MachineState.On_Working_Fast;
                    return;
                }
                // Fallthrough to parent
                goto case MachineState.On_Working;
        }
    }

    private void RestoreFromHistory(string targetState)
    {
        // This method handles runtime dispatch to historical states
        if (targetState == "On")
        {
            if (_history_On.HasValue)
            {
                var historicalState = _history_On.Value;
                // Restore to shallow history
                switch (historicalState)
                {
                    case MachineState.On_Idle:
                        _currentState = MachineState.On_Idle;
                        return;
                    case MachineState.On_Working:
                        _currentState = MachineState.On_Working;
                        return;
                }
            }
            // No history, use initial
            _currentState = MachineState.On_Idle;
        }
        if (targetState == "On_Working")
        {
            if (_historyDeep_On_Working.HasValue)
            {
                // Restore to deep history
                _currentState = _historyDeep_On_Working.Value;
                return;
            }
            // No history, use initial
            _currentState = MachineState.On_Working_Fast;
        }
    }
}
// Generated Hierarchical State Machine
namespace TestNamespace;

public partial class SimpleHsmMachine
{
    private ProcessState _currentState;


    private Action? OnWorkEntry;
    private Action? OnWorkExit;
    private Action? OnIdleEntry;
    private Action? OnIdleExit;
    private Action? OnActiveEntry;
    private Action? OnActiveExit;

    public void Fire(ProcessTrigger trigger)
    {
        switch (_currentState)
        {
            case ProcessState.Pending:
                if (trigger == ProcessTrigger.Start)
                {
                    // Priority: 0, Internal: False
                    // Transition: Pending -> Work_Idle (LCA: none)
                    // Enter Work
                    OnWorkEntry?.Invoke();
                    // Enter Work_Idle
                    OnIdleEntry?.Invoke();
                    _currentState = ProcessState.Work_Idle;
                    return;
                }
                break;
            case ProcessState.Work:
                if (trigger == ProcessTrigger.Abort)
                {
                    // Priority: 50, Internal: False
                    // Transition: Work -> Done (LCA: none)
                    // Exit Work
                    OnWorkExit?.Invoke();
                    // Transition action
                    CleanupWork();
                    _currentState = ProcessState.Done;
                    return;
                }
                break;
            case ProcessState.Work_Active:
                if (trigger == ProcessTrigger.Emergency && IsEmergency())
                {
                    // Priority: 200, Internal: False
                    // Transition: Work_Active -> Done (LCA: none)
                    // Exit Work_Active
                    OnActiveExit?.Invoke();
                    // Exit Work
                    OnWorkExit?.Invoke();
                    _currentState = ProcessState.Done;
                    return;
                }
                if (trigger == ProcessTrigger.Tick)
                {
                    // Priority: 150, Internal: True
                    // Internal transition in Work_Active
                    UpdateProgress();
                    // State remains: Work_Active
                    return;
                }
                if (trigger == ProcessTrigger.Finish)
                {
                    // Priority: 100, Internal: False
                    // Transition: Work_Active -> Done (LCA: none)
                    // Exit Work_Active
                    OnActiveExit?.Invoke();
                    // Exit Work
                    OnWorkExit?.Invoke();
                    _currentState = ProcessState.Done;
                    return;
                }
                if (trigger == ProcessTrigger.Finish)
                {
                    // Priority: 80, Internal: False
                    // Transition: Work_Active -> Work_Idle (LCA: Work)
                    // Exit Work_Active
                    OnActiveExit?.Invoke();
                    // Enter Work_Idle
                    OnIdleEntry?.Invoke();
                    _currentState = ProcessState.Work_Idle;
                    return;
                }
                if (trigger == ProcessTrigger.Pause)
                {
                    // Priority: 0, Internal: False
                    // Transition: Work_Active -> Work_Idle (LCA: Work)
                    // Exit Work_Active
                    OnActiveExit?.Invoke();
                    // Enter Work_Idle
                    OnIdleEntry?.Invoke();
                    _currentState = ProcessState.Work_Idle;
                    return;
                }
                // Fallthrough to parent
                goto case ProcessState.Work;
            case ProcessState.Work_Idle:
                if (trigger == ProcessTrigger.Activate)
                {
                    // Priority: 0, Internal: False
                    // Transition: Work_Idle -> Work_Active (LCA: Work)
                    // Exit Work_Idle
                    OnIdleExit?.Invoke();
                    // Enter Work_Active
                    OnActiveEntry?.Invoke();
                    _currentState = ProcessState.Work_Active;
                    return;
                }
                // Fallthrough to parent
                goto case ProcessState.Work;
        }
    }

}
using System.Collections.Generic;
using Generator.Model;

namespace FastFsm.HsmPrototype.TestModels;

public static class HistoryHierarchy
{
    public static StateMachineModel Create()
    {
        var model = new StateMachineModel
        {
            Namespace = "TestNamespace",
            ClassName = "HistoryHsmMachine",
            StateType = "MachineState",
            TriggerType = "MachineTrigger",
            HierarchyEnabled = true
        };
        
        // States hierarchy:
        // Off
        // On (has shallow history)
        //   ├── On_Idle
        //   └── On_Working (has deep history)
        //         ├── On_Working_Fast
        //         └── On_Working_Slow
        
        // Define states
        model.States["Off"] = new StateModel { Name = "Off" };
        
        model.States["On"] = new StateModel { 
            Name = "On",
            History = HistoryMode.Shallow,  // Remember last direct child
            OnEntryMethod = "OnOnEntry",
            OnExitMethod = "OnOnExit"
        };
        
        model.States["On_Idle"] = new StateModel { 
            Name = "On_Idle",
            ParentState = "On",
            IsInitial = true,
            OnEntryMethod = "OnIdleEntry"
        };
        
        model.States["On_Working"] = new StateModel { 
            Name = "On_Working",
            ParentState = "On",
            History = HistoryMode.Deep,  // Remember full substate path
            OnEntryMethod = "OnWorkingEntry",
            OnExitMethod = "OnWorkingExit"
        };
        
        model.States["On_Working_Fast"] = new StateModel { 
            Name = "On_Working_Fast",
            ParentState = "On_Working",
            IsInitial = true,
            OnEntryMethod = "OnFastEntry"
        };
        
        model.States["On_Working_Slow"] = new StateModel { 
            Name = "On_Working_Slow",
            ParentState = "On_Working",
            OnEntryMethod = "OnSlowEntry"
        };
        
        // Build hierarchy
        model.ParentOf["Off"] = null;
        model.ParentOf["On"] = null;
        model.ParentOf["On_Idle"] = "On";
        model.ParentOf["On_Working"] = "On";
        model.ParentOf["On_Working_Fast"] = "On_Working";
        model.ParentOf["On_Working_Slow"] = "On_Working";
        
        model.ChildrenOf["On"] = new List<string> { "On_Idle", "On_Working" };
        model.ChildrenOf["On_Working"] = new List<string> { "On_Working_Fast", "On_Working_Slow" };
        
        model.InitialChildOf["On"] = "On_Idle";
        model.InitialChildOf["On_Working"] = "On_Working_Fast";
        
        model.HistoryOf["On"] = HistoryMode.Shallow;
        model.HistoryOf["On_Working"] = HistoryMode.Deep;
        
        // Transitions
        model.Transitions.Add(new TransitionModel
        {
            FromState = "Off",
            Trigger = "PowerOn",
            ToState = "On"  // Should use history if available, else On_Idle
        });
        
        model.Transitions.Add(new TransitionModel
        {
            FromState = "On",
            Trigger = "PowerOff",
            ToState = "Off"
        });
        
        model.Transitions.Add(new TransitionModel
        {
            FromState = "On_Idle",
            Trigger = "StartWork",
            ToState = "On_Working"  // Should use deep history if available
        });
        
        model.Transitions.Add(new TransitionModel
        {
            FromState = "On_Working",
            Trigger = "Stop",
            ToState = "On_Idle"
        });
        
        model.Transitions.Add(new TransitionModel
        {
            FromState = "On_Working_Fast",
            Trigger = "Slow",
            ToState = "On_Working_Slow"
        });
        
        model.Transitions.Add(new TransitionModel
        {
            FromState = "On_Working_Slow",
            Trigger = "Fast",
            ToState = "On_Working_Fast"
        });
        
        return model;
    }
}
using System.Collections.Generic;
using Generator.Model;

namespace FastFsm.HsmPrototype.TestModels;

public static class SimpleHierarchy
{
    public static StateMachineModel Create()
    {
        var model = new StateMachineModel
        {
            Namespace = "TestNamespace",
            ClassName = "SimpleHsmMachine",
            StateType = "ProcessState",
            TriggerType = "ProcessTrigger",
            HierarchyEnabled = true
        };
        
        // Define states
        model.States["Pending"] = new StateModel { Name = "Pending" };
        model.States["Work"] = new StateModel { 
            Name = "Work",
            OnEntryMethod = "OnWorkEntry",
            OnExitMethod = "OnWorkExit"
        };
        model.States["Work_Idle"] = new StateModel { 
            Name = "Work_Idle",
            ParentState = "Work",
            IsInitial = true,
            OnEntryMethod = "OnIdleEntry",
            OnExitMethod = "OnIdleExit"
        };
        model.States["Work_Active"] = new StateModel { 
            Name = "Work_Active",
            ParentState = "Work",
            OnEntryMethod = "OnActiveEntry",
            OnExitMethod = "OnActiveExit"
        };
        model.States["Done"] = new StateModel { Name = "Done" };
        
        // Build hierarchy relationships
        model.ParentOf["Pending"] = null;
        model.ParentOf["Work"] = null;
        model.ParentOf["Work_Idle"] = "Work";
        model.ParentOf["Work_Active"] = "Work";
        model.ParentOf["Done"] = null;
        
        model.ChildrenOf["Work"] = new List<string> { "Work_Idle", "Work_Active" };
        model.InitialChildOf["Work"] = "Work_Idle";
        
        // Work is automatically composite (has children)
        
        // Define transitions
        model.Transitions.Add(new TransitionModel
        {
            FromState = "Pending",
            Trigger = "Start",
            ToState = "Work"  // Should go to Work_Idle automatically
        });
        
        model.Transitions.Add(new TransitionModel
        {
            FromState = "Work_Idle",
            Trigger = "Activate",
            ToState = "Work_Active"
        });
        
        model.Transitions.Add(new TransitionModel
        {
            FromState = "Work_Active",
            Trigger = "Finish",
            ToState = "Done",
            Priority = 100
        });
        
        // Add transition between children of the same parent
        model.Transitions.Add(new TransitionModel
        {
            FromState = "Work_Active",
            Trigger = "Pause",
            ToState = "Work_Idle"  // Transition between Work's children
        });
        
        // Internal transition - tick w Work_Active
        model.Transitions.Add(new TransitionModel
        {
            FromState = "Work_Active",
            Trigger = "Tick",
            ToState = "Work_Active",  // Same state = internal
            IsInternal = true,
            ActionMethod = "UpdateProgress",
            Priority = 150  // High priority
        });
        
        // Transition z Work_Active z wysokim priorytetem
        model.Transitions.Add(new TransitionModel
        {
            FromState = "Work_Active",
            Trigger = "Emergency",
            ToState = "Done",
            Priority = 200,  // Highest priority
            GuardMethod = "IsEmergency"
        });
        
        // Transition z Work (parent) z niskim priorytetem - fallback
        model.Transitions.Add(new TransitionModel
        {
            FromState = "Work",
            Trigger = "Abort",
            ToState = "Done",
            Priority = 50,  // Low priority
            ActionMethod = "CleanupWork"
        });
        
        // Konflikt priorytetów - dwa transitions z tego samego stanu
        model.Transitions.Add(new TransitionModel
        {
            FromState = "Work_Active",
            Trigger = "Finish",
            ToState = "Work_Idle",
            Priority = 80  // Lower than existing Finish->Done (100)
        });
        
        return model;
    }
}
