[
    {
        "Source": "C:\\Users\\newon\\source\\repos\\FastFsm\\Abstractions",
        "FilesWithContent": {
            "Attributes\\GenerateLoggingAttribute.cs": "﻿//using System;\n\n//namespace Abstractions.Attributes;\n\n///// <summary>\n///// Controls whether logging code should be generated for this state machine.\n///// By default, logging is enabled only when FSM.NET.Logging package is installed.\n///// </summary>\n//[AttributeUsage(AttributeTargets.Class)]\n//public sealed class GenerateLoggingAttribute(bool enabled) : Attribute\n//{\n//    /// <summary>\n//    /// Whether to generate logging code for this state machine.\n//    /// </summary>\n//    public bool Enabled { get; } = enabled;\n//}",
            "Attributes\\GenerationModeAttribute.cs": "using System;\n\nnamespace Abstractions.Attributes;\n\n/// <summary>\n/// Controls the generation mode for the state machine\n/// </summary>\n[AttributeUsage(AttributeTargets.Class)]\npublic sealed class GenerationModeAttribute(GenerationMode mode) : Attribute\n{\n    /// <summary>\n    /// The generation mode to use\n    /// </summary>\n    public GenerationMode Mode { get; } = mode;\n\n    /// <summary>\n    /// Force specific variant regardless of usage analysis\n    /// </summary>\n    public bool Force { get; set; }\n}\n\npublic enum GenerationMode\n{\n    /// <summary>\n    /// Automatically detect based on usage\n    /// </summary>\n    Auto = 0,\n    \n    /// <summary>\n    /// Generate only the pure variant (no features)\n    /// </summary>\n    Pure = 1,\n    \n    /// <summary>\n    /// Generate with OnEntry/OnExit support\n    /// </summary>\n    Basic = 2,\n    \n    /// <summary>\n    /// Generate with typed payload support\n    /// </summary>\n    WithPayload = 3,\n    \n    /// <summary>\n    /// Generate with extension support\n    /// </summary>\n    WithExtensions = 4,\n    \n    /// <summary>\n    /// Generate with all features\n    /// </summary>\n    Full = 5\n}\n",
            "Attributes\\HistoryMode.cs": "using System;\n\nnamespace Abstractions.Attributes;\n\n/// <summary>\n/// Defines the history behavior for composite states\n/// </summary>\npublic enum HistoryMode\n{\n    /// <summary>\n    /// No history - always enter through initial substate\n    /// </summary>\n    None = 0,\n    \n    /// <summary>\n    /// Shallow history - remember only the direct child state\n    /// </summary>\n    Shallow = 1,\n    \n    /// <summary>\n    /// Deep history - remember the full nested state path\n    /// </summary>\n    Deep = 2\n}",
            "Attributes\\InternalTransitionAttribute.cs": "﻿\n\nusing System;\n\nnamespace Abstractions.Attributes;\n\n/// <summary>\n/// Defines an internal transition (no state change)\n/// </summary>\n[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\npublic sealed class InternalTransitionAttribute(object state, object trigger, string action) : Attribute\n{\n    public object State { get; } = state ?? throw new ArgumentNullException(nameof(state));\n    public object Trigger { get; } = trigger ?? throw new ArgumentNullException(nameof(trigger));\n    public string Guard { get; set; }\n    public string Action { get; set; } = action ?? throw new ArgumentNullException(nameof(action)); \n}\n",
            "Attributes\\OnExceptionAttribute.cs": "using System;\n\nnamespace Abstractions.Attributes;\n\n/// <summary>\n/// Specifies a method to handle exceptions that occur during state transitions.\n/// The method must accept ExceptionContext and return ExceptionDirective.\n/// </summary>\n[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]\npublic sealed class OnExceptionAttribute : Attribute\n{\n    /// <summary>\n    /// The name of the method that handles exceptions.\n    /// </summary>\n    public string MethodName { get; }\n    \n    /// <summary>\n    /// Initializes a new instance of the OnExceptionAttribute class.\n    /// </summary>\n    /// <param name=\"methodName\">The name of the exception handling method.</param>\n    public OnExceptionAttribute(string methodName)\n    {\n        MethodName = methodName ?? throw new ArgumentNullException(nameof(methodName));\n    }\n}",
            "Attributes\\PayloadTypeAttribute.cs": "using System;\n\nnamespace Abstractions.Attributes;\n\n/// <summary>\n/// Specifies the payload type for a state machine or specific triggers\n/// </summary>\n[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)]\npublic sealed class PayloadTypeAttribute : Attribute\n{\n    /// <summary>\n    /// The default payload type for all triggers\n    /// </summary>\n    public Type DefaultPayloadType { get; set; }\n    \n    /// <summary>\n    /// Specific trigger this payload type applies to\n    /// </summary>\n    public object Trigger { get; }\n    \n    /// <summary>\n    /// The payload type for the specific trigger\n    /// </summary>\n    public Type PayloadType { get; }\n    \n    /// <summary>\n    /// Constructor for default payload type\n    /// </summary>\n    public PayloadTypeAttribute(Type defaultPayloadType)\n    {\n        DefaultPayloadType = defaultPayloadType ?? throw new ArgumentNullException(nameof(defaultPayloadType));\n    }\n    \n    /// <summary>\n    /// Constructor for trigger-specific payload type\n    /// </summary>\n    public PayloadTypeAttribute(object trigger, Type payloadType)\n    {\n        Trigger = trigger ?? throw new ArgumentNullException(nameof(trigger));\n        PayloadType = payloadType ?? throw new ArgumentNullException(nameof(payloadType));\n    }\n}\n",
            "Attributes\\StateAttribute.cs": "﻿\n\nusing System;\n\nnamespace Abstractions.Attributes;\n\n\n[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\npublic sealed class StateAttribute(object state) : Attribute\n{\n    public object State { get; } = state ?? throw new ArgumentNullException(nameof(state));\n    public string OnEntry { get; set; }\n    public string OnExit { get; set; }\n    \n    // HSM support - hierarchical states\n    /// <summary>\n    /// Optional parent state for hierarchical state machines\n    /// </summary>\n    public object Parent { get; set; }\n    \n    /// <summary>\n    /// History mode for composite states (None by default)\n    /// </summary>\n    public HistoryMode History { get; set; } = HistoryMode.None;\n    \n    /// <summary>\n    /// Marks this state as the initial substate of its parent\n    /// </summary>\n    public bool IsInitial { get; set; } = false;\n}\n",
            "Attributes\\StateMachineAttribute.cs": "\n\nusing System;\n\nnamespace Abstractions.Attributes;\n\n/// <summary>\n/// Marks a class as a fast state machine that should be generated\n/// </summary>\n[AttributeUsage(AttributeTargets.Class)]\npublic sealed class StateMachineAttribute : Attribute\n{\n    public Type StateType { get; }\n    public Type TriggerType { get; }\n    \n    /// <summary>\n    /// Controls whether to generate extensible variant\n    /// </summary>\n    public bool GenerateExtensibleVersion { get; set; } = true;\n    \n    /// <summary>\n    /// Default payload type for all triggers (optional)\n    /// </summary>\n    public Type DefaultPayloadType { get; set; }\n    /// <summary>\n    /// When true, generates additional methods for structural analysis of the state machine (HasTransition, GetDefinedTriggers)\n    /// </summary>\n    public bool GenerateStructuralApi { get; set; } = false;\n    public StateMachineAttribute(Type stateType, Type triggerType)\n    {\n        if (!stateType.IsEnum || !triggerType.IsEnum)\n            throw new ArgumentException(\"State and Trigger types must be enums\");\n            \n        StateType = stateType;\n        TriggerType = triggerType;\n    }\n    /// <summary>\n    /// Controls whether async continuations should be posted back to the original context.\n    /// Only applicable for async state machines. Defaults to false for better performance.\n    /// </summary>\n    public bool ContinueOnCapturedContext { get; set; } = false;\n    \n    /// <summary>\n    /// Enables hierarchical state machine features (composite states, history, etc.)\n    /// Automatically enabled if any HSM attributes are used\n    /// </summary>\n    public bool EnableHierarchy { get; set; } = false;\n}\n\n",
            "Attributes\\TransitionAttribute.cs": "﻿\nusing System;\n\nnamespace Abstractions.Attributes;\n\n/// <summary>\n/// Defines a state transition\n/// </summary>\n[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\npublic sealed class TransitionAttribute(object fromState, object trigger, object toState) : Attribute\n{\n    public object FromState { get; } = fromState ?? throw new ArgumentNullException(nameof(fromState));\n    public object Trigger { get; } = trigger ?? throw new ArgumentNullException(nameof(trigger));\n    public object ToState { get; } = toState ?? throw new ArgumentNullException(nameof(toState));\n    public string Guard { get; set; }\n    public string Action { get; set; }\n}\n",
            "Abstractions.csproj": "﻿<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <TargetFramework>netstandard2.0</TargetFramework>\n    <LangVersion>latest</LangVersion>\n  </PropertyGroup>\n\n</Project>\n"
        }
    },
    {
        "Source": "C:\\Users\\newon\\source\\repos\\FastFsm\\Generator.Model",
        "FilesWithContent": {
            "CallbackSignatureInfo.cs": "﻿namespace Generator.Model;\n\n/// <summary>\n/// Comprehensive description of a callback method signature,\n/// including all possible overload combinations with payload and cancellation token.\n/// </summary>\npublic struct CallbackSignatureInfo\n{\n    /// <summary>\n    /// Whether the callback is async (returns Task/ValueTask).\n    /// </summary>\n    public bool IsAsync { get; set; }\n\n    /// <summary>\n    /// Whether the signature is void-equivalent (void, Task, ValueTask).\n    /// Used for Action, OnEntry, OnExit callbacks.\n    /// </summary>\n    public bool IsVoidEquivalent { get; set; }\n\n    /// <summary>\n    /// Whether the signature is bool-equivalent (bool, ValueTask<bool>).\n    /// Used for Guard callbacks.\n    /// </summary>\n    public bool IsBoolEquivalent { get; set; }\n\n    /// <summary>\n    /// Whether a parameterless overload exists: ()\n    /// </summary>\n    public bool HasParameterless { get; set; }\n\n    /// <summary>\n    /// Whether a payload-only overload exists: (T)\n    /// </summary>\n    public bool HasPayloadOnly { get; set; }\n\n    /// <summary>\n    /// Whether a token-only overload exists: (CancellationToken)\n    /// </summary>\n    public bool HasTokenOnly { get; set; }\n\n    /// <summary>\n    /// Whether a payload+token overload exists: (T, CancellationToken)\n    /// </summary>\n    public bool HasPayloadAndToken { get; set; }\n\n    /// <summary>\n    /// The fully qualified type name of the payload parameter (for T and T,CT overloads).\n    /// Null if no payload overloads exist.\n    /// </summary>\n    public string? PayloadTypeFullName { get; set; }\n\n    /// <summary>\n    /// Determines the best overload to call based on available parameters.\n    /// </summary>\n    /// <param name=\"hasPayload\">Whether a typed payload is available</param>\n    /// <param name=\"hasToken\">Whether a cancellation token is available</param>\n    /// <returns>The overload type that should be called</returns>\n    public OverloadType GetBestOverload(bool hasPayload, bool hasToken)\n    {\n        // Priority: payload+token → payload → token → parameterless\n        if (hasPayload && hasToken && HasPayloadAndToken)\n            return OverloadType.PayloadAndToken;\n\n        if (hasPayload && HasPayloadOnly)\n            return OverloadType.PayloadOnly;\n\n        if (hasToken && HasTokenOnly)\n            return OverloadType.TokenOnly;\n\n        if (HasParameterless)\n            return OverloadType.Parameterless;\n\n        return OverloadType.None;\n    }\n\n    /// <summary>\n    /// Creates an empty signature info (no overloads available).\n    /// </summary>\n    public static CallbackSignatureInfo Empty => new();\n}\n\n/// <summary>\n/// Types of callback overloads.\n/// </summary>\npublic enum OverloadType\n{\n    /// <summary>No matching overload</summary>\n    None,\n    /// <summary>Parameterless: ()</summary>\n    Parameterless,\n    /// <summary>Payload only: (T)</summary>\n    PayloadOnly,\n    /// <summary>Token only: (CancellationToken)</summary>\n    TokenOnly,\n    /// <summary>Payload and token: (T, CancellationToken)</summary>\n    PayloadAndToken\n}",
            "ExceptionHandlerModel.cs": "namespace Generator.Model;\n\n/// <summary>\n/// Represents an exception handler method for the state machine.\n/// </summary>\npublic sealed class ExceptionHandlerModel\n{\n    /// <summary>\n    /// The name of the exception handler method.\n    /// </summary>\n    public string MethodName { get; set; } = default!;\n    \n    /// <summary>\n    /// Whether the handler is async (returns ValueTask<ExceptionDirective>).\n    /// </summary>\n    public bool IsAsync { get; set; }\n    \n    /// <summary>\n    /// Whether the handler accepts a CancellationToken as second parameter.\n    /// </summary>\n    public bool AcceptsCancellationToken { get; set; }\n    \n    /// <summary>\n    /// The fully qualified closed generic type for ExceptionContext.\n    /// Example: \"global::StateMachine.Exceptions.ExceptionContext<MyStates, MyTriggers>\"\n    /// </summary>\n    public string ExceptionContextClosedType { get; set; } = default!;\n}",
            "GenerationConfig.cs": "﻿namespace Generator.Model;\n\npublic class GenerationConfig\n{\n    public GenerationVariant Variant { get; set; } // Pure lub Basic\n    public bool HasOnEntryExit { get; set; }      // Kluczowe dla rozróżnienia Pure/Basic\n    public bool IsForced { get; set; }\n\n    public bool HasPayload { get; set; }\n    public bool HasExtensions { get; set; }\n    public bool IsAsync { get; set; }\n    /// <summary>\n    /// Whether to treat OperationCanceledException as a failure (true) or as a cancellation (false).\n    /// Default: false - cancellation is not treated as failure.\n    /// </summary>\n    public bool TreatCancellationAsFailure { get; set; } = false;\n}\n",
            "GenerationVariant.cs": "namespace Generator.Model;\n\n/// <summary>\n/// Represents the generation variant for a state machine\n/// </summary>\npublic enum GenerationVariant\n{\n    /// <summary>\n    /// Minimal implementation with no features\n    /// </summary>\n    Pure,\n    \n    /// <summary>\n    /// Includes OnEntry/OnExit support\n    /// </summary>\n    Basic,\n    \n    /// <summary>\n    /// Includes typed payload support\n    /// </summary>\n    WithPayload,\n    \n    /// <summary>\n    /// Includes extension support\n    /// </summary>\n    WithExtensions,\n    \n    /// <summary>\n    /// All features enabled\n    /// </summary>\n    Full\n}",
            "HistoryMode.cs": "namespace Generator.Model;\n\n/// <summary>\n/// Defines the history behavior for composite states in hierarchical state machines\n/// </summary>\npublic enum HistoryMode\n{\n    /// <summary>\n    /// No history - always enter through initial substate\n    /// </summary>\n    None = 0,\n    \n    /// <summary>\n    /// Shallow history - remember only the direct child state\n    /// </summary>\n    Shallow = 1,\n    \n    /// <summary>\n    /// Deep history - remember the full nested state path\n    /// </summary>\n    Deep = 2\n}",
            "StateMachineModel.cs": "﻿namespace Generator.Model;\n\npublic class StateMachineModel\n{\n    public string Namespace { get; set; } = \"\";\n    public string ClassName { get; set; } = \"\";\n    public string StateType { get; set; } = \"\"; // Fully qualified name\n    public string TriggerType { get; set; } = \"\"; // Fully qualified name\n    public List<TransitionModel> Transitions { get; set; } = [];\n    public Dictionary<string, StateModel> States { get; set; } = new(); // Key is EnumMemberName\n    public GenerationConfig GenerationConfig { get; set; } = new();\n    public GenerationVariant Variant => GenerationConfig.Variant;\n    public string? DefaultPayloadType { get; set; } // Fully qualified name of default payload type\n    public Dictionary<string, string> TriggerPayloadTypes { get; set; } = new(); \n\n    public bool GenerateLogging { get; set; }\n    public bool GenerateDependencyInjection { get; set; }\n    public bool EmitStructuralHelpers { get; set; }\n    public bool ContinueOnCapturedContext { get; set; } = false;\n    \n    /// <summary>\n    /// Optional exception handler configuration.\n    /// </summary>\n    public ExceptionHandlerModel? ExceptionHandler { get; set; }\n\n    #region HSM Properties\n\n    /// <summary>\n    /// Maps each state to its parent state (null for root states)\n    /// </summary>\n    public Dictionary<string, string?> ParentOf { get; set; } = new();\n\n    /// <summary>\n    /// Maps each composite state to its child states\n    /// </summary>\n    public Dictionary<string, List<string>> ChildrenOf { get; set; } = new();\n\n    /// <summary>\n    /// Maps each state to its depth in the hierarchy (0 for root states)\n    /// </summary>\n    public Dictionary<string, int> Depth { get; set; } = new();\n\n    /// <summary>\n    /// Maps each composite state to its initial child state\n    /// </summary>\n    public Dictionary<string, string?> InitialChildOf { get; set; } = new();\n\n    /// <summary>\n    /// Maps each composite state to its history mode\n    /// </summary>\n    public Dictionary<string, HistoryMode> HistoryOf { get; set; } = new();\n\n    /// <summary>\n    /// Whether hierarchy is enabled (from attribute or auto-detected)\n    /// </summary>\n    public bool HierarchyEnabled { get; set; } = false;\n\n    /// <summary>\n    /// Whether any HSM features are actually used\n    /// </summary>\n    public bool HasHierarchy => ParentOf.Any(p => p.Value != null) || ChildrenOf.Any(c => c.Value.Count > 0);\n\n    #endregion\n}\n",
            "StateModel.cs": "﻿namespace Generator.Model;\n\n/// <summary>\n/// Model reprezentujący stan w maszynie stanów wraz z jego callbackami.\n/// </summary>\npublic sealed class StateModel\n{\n    #region Core Properties\n\n    /// <summary>\n    /// Nazwa stanu\n    /// </summary>\n    public string Name { get; set; } = \"\";\n\n    /// <summary>\n    /// Nazwa metody OnEntry (wykonywana przy wejściu do stanu)\n    /// </summary>\n    public string OnEntryMethod { get; set; }\n\n    /// <summary>\n    /// Nazwa metody OnExit (wykonywana przy wyjściu ze stanu)\n    /// </summary>\n    public string OnExitMethod { get; set; }\n\n    #endregion\n\n    #region Signature Information\n\n    /// <summary>\n    /// Complete signature information for the OnEntry method\n    /// </summary>\n    public CallbackSignatureInfo OnEntrySignature { get; set; } = CallbackSignatureInfo.Empty;\n\n    /// <summary>\n    /// Complete signature information for the OnExit method\n    /// </summary>\n    public CallbackSignatureInfo OnExitSignature { get; set; } = CallbackSignatureInfo.Empty;\n\n    #endregion\n\n    #region Convenience Properties (Derived from Signatures)\n\n    /// <summary>\n    /// Whether the OnEntry method is async\n    /// </summary>\n    public bool OnEntryIsAsync\n    {\n        get => OnEntrySignature.IsAsync;\n        set\n        {\n            var sig = OnEntrySignature;\n            sig.IsAsync = value;\n            OnEntrySignature = sig;\n        }\n    }\n\n    /// <summary>\n    /// Whether the OnExit method is async\n    /// </summary>\n    public bool OnExitIsAsync\n    {\n        get => OnExitSignature.IsAsync;\n        set\n        {\n            var sig = OnExitSignature;\n            sig.IsAsync = value;\n            OnExitSignature = sig;\n        }\n    }\n\n    /// <summary>\n    /// Whether the OnEntry expects a payload parameter\n    /// </summary>\n    public bool OnEntryExpectsPayload\n    {\n        get => OnEntrySignature.HasPayloadOnly || OnEntrySignature.HasPayloadAndToken;\n        set\n        {\n            var sig = OnEntrySignature;\n            sig.HasPayloadOnly = value;\n            OnEntrySignature = sig;\n        }\n    }\n\n    /// <summary>\n    /// Whether the OnEntry has a parameterless overload\n    /// </summary>\n    public bool OnEntryHasParameterlessOverload\n    {\n        get => OnEntrySignature.HasParameterless;\n        set\n        {\n            var sig = OnEntrySignature;\n            sig.HasParameterless = value;\n            OnEntrySignature = sig;\n        }\n    }\n\n    /// <summary>\n    /// Whether the OnExit expects a payload parameter\n    /// </summary>\n    public bool OnExitExpectsPayload\n    {\n        get => OnExitSignature.HasPayloadOnly || OnExitSignature.HasPayloadAndToken;\n        set\n        {\n            var sig = OnExitSignature;\n            sig.HasPayloadOnly = value;\n            OnExitSignature = sig;\n        }\n    }\n\n    /// <summary>\n    /// Whether the OnExit has a parameterless overload\n    /// </summary>\n    public bool OnExitHasParameterlessOverload\n    {\n        get => OnExitSignature.HasParameterless;\n        set\n        {\n            var sig = OnExitSignature;\n            sig.HasParameterless = value;\n            OnExitSignature = sig;\n        }\n    }\n\n    #endregion\n\n    #region HSM Properties\n\n    /// <summary>\n    /// Parent state name for hierarchical state machines\n    /// </summary>\n    public string? ParentState { get; set; }\n\n    /// <summary>\n    /// List of child state names for composite states\n    /// </summary>\n    public List<string> ChildStates { get; set; } = new List<string>();\n\n    /// <summary>\n    /// Whether this state is a composite state (has children)\n    /// </summary>\n    public bool IsComposite => ChildStates.Count > 0;\n\n    /// <summary>\n    /// History mode for this composite state\n    /// </summary>\n    public HistoryMode History { get; set; } = HistoryMode.None;\n\n    /// <summary>\n    /// Whether this state is marked as the initial substate of its parent\n    /// </summary>\n    public bool IsInitial { get; set; } = false;\n\n    #endregion\n\n    #region Factory Methods\n\n    /// <summary>\n    /// Creates a state model with the specified properties\n    /// </summary>\n    public static StateModel Create(\n        string name,\n        string onEntryMethod = null,\n        string onExitMethod = null)\n    {\n        return new StateModel\n        {\n            Name = name,\n            OnEntryMethod = onEntryMethod,\n            OnExitMethod = onExitMethod\n        };\n    }\n\n    #endregion\n\n    /// <inheritdoc/>\n    public override string ToString() => Name;\n}",
            "TransitionModel.cs": "﻿namespace Generator.Model;\n\n/// <summary>\n/// Model reprezentujący pojedyncze przejście w maszynie stanów.\n/// </summary>\npublic sealed class TransitionModel\n{\n    #region Core Properties\n\n    /// <summary>\n    /// Stan źródłowy przejścia\n    /// </summary>\n    public string FromState { get; set; } = \"\";\n\n    /// <summary>\n    /// Stan docelowy przejścia\n    /// </summary>\n    public string ToState { get; set; } = \"\";\n\n    /// <summary>\n    /// Wyzwalacz przejścia\n    /// </summary>\n    public string Trigger { get; set; } = \"\";\n\n    /// <summary>\n    /// Czy przejście jest wewnętrzne (nie zmienia stanu)\n    /// </summary>\n    // Set explicitly only for [InternalTransition]. Self-transitions [Transition(A, T, A)] are NOT internal.\n    public bool IsInternal { get; set; }\n\n    #endregion\n\n    #region Callback Methods\n\n    /// <summary>\n    /// Nazwa metody guard (warunek przejścia)\n    /// </summary>\n    public string GuardMethod { get; set; }\n\n    /// <summary>\n    /// Nazwa metody akcji wykonywanej podczas przejścia\n    /// </summary>\n    public string ActionMethod { get; set; }\n\n    #endregion\n\n    #region Signature Information\n\n    /// <summary>\n    /// Complete signature information for the guard method\n    /// </summary>\n    public CallbackSignatureInfo GuardSignature { get; set; } = CallbackSignatureInfo.Empty;\n\n    /// <summary>\n    /// Complete signature information for the action method\n    /// </summary>\n    public CallbackSignatureInfo ActionSignature { get; set; } = CallbackSignatureInfo.Empty;\n\n    #endregion\n\n    #region Payload Information\n\n    /// <summary>\n    /// Expected payload type for this transition (null if no payload expected)\n    /// </summary>\n    public string ExpectedPayloadType { get; set; }\n\n    #endregion\n\n    #region Convenience Properties (Derived from Signatures)\n\n    /// <summary>\n    /// Whether the guard method is async\n    /// </summary>\n    public bool GuardIsAsync\n    {\n        get => GuardSignature.IsAsync;\n        set\n        {\n            var sig = GuardSignature;\n            sig.IsAsync = value;\n            GuardSignature = sig;\n        }\n    }\n\n    /// <summary>\n    /// Whether the action method is async\n    /// </summary>\n    public bool ActionIsAsync\n    {\n        get => ActionSignature.IsAsync;\n        set\n        {\n            var sig = ActionSignature;\n            sig.IsAsync = value;\n            ActionSignature = sig;\n        }\n    }\n\n    /// <summary>\n    /// Whether the guard expects a payload parameter\n    /// </summary>\n    public bool GuardExpectsPayload\n    {\n        get => GuardSignature.HasPayloadOnly || GuardSignature.HasPayloadAndToken;\n        set\n        {\n            var sig = GuardSignature;\n            sig.HasPayloadOnly = value;\n            GuardSignature = sig;\n        }\n    }\n\n    /// <summary>\n    /// Whether the guard has a parameterless overload\n    /// </summary>\n    public bool GuardHasParameterlessOverload\n    {\n        get => GuardSignature.HasParameterless;\n        set\n        {\n            var sig = GuardSignature;\n            sig.HasParameterless = value;\n            GuardSignature = sig;\n        }\n    }\n\n    /// <summary>\n    /// Whether the action expects a payload parameter\n    /// </summary>\n    public bool ActionExpectsPayload\n    {\n        get => ActionSignature.HasPayloadOnly || ActionSignature.HasPayloadAndToken;\n        set\n        {\n            var sig = ActionSignature;\n            sig.HasPayloadOnly = value;\n            ActionSignature = sig;\n        }\n    }\n\n    /// <summary>\n    /// Whether the action has a parameterless overload\n    /// </summary>\n    public bool ActionHasParameterlessOverload\n    {\n        get => ActionSignature.HasParameterless;\n        set\n        {\n            var sig = ActionSignature;\n            sig.HasParameterless = value;\n            ActionSignature = sig;\n        }\n    }\n\n    #endregion\n\n    #region Factory Methods\n\n    /// <summary>\n    /// Creates a transition model with all required properties\n    /// </summary>\n    public static TransitionModel Create(\n        string fromState,\n        string toState,\n        string trigger,\n        string guardMethod = null,\n        string actionMethod = null,\n        string expectedPayloadType = null)\n    {\n        return new TransitionModel\n        {\n            FromState = fromState,\n            ToState = toState,\n            Trigger = trigger,\n            GuardMethod = guardMethod,\n            ActionMethod = actionMethod,\n            ExpectedPayloadType = expectedPayloadType\n        };\n    }\n\n    #endregion\n\n    /// <inheritdoc/>\n    public override string ToString() => $\"{FromState} --{Trigger}--> {ToState}\";\n}",
            "Dtos\\FactoryGenerationModel.cs": "﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Generator.Model.Dtos\n{\n    /// <summary>\n    /// Główny model danych dla FactoryCodeGenerator, zawierający wszystkie wstępnie\n    /// przetworzone informacje, eliminując potrzebę posiadania TypeSystemHelper w generatorze.\n    /// </summary>\n    public sealed record FactoryGenerationModel\n    {\n        // Informacje o typach\n        public TypeGenerationInfo StateType { get; set; }\n        public TypeGenerationInfo TriggerType { get; set; }\n        public TypeGenerationInfo? PayloadType { get; set; } // Może nie istnieć\n\n        // Informacje z oryginalnego StateMachineModel\n        public string ClassName { get; set; }\n        public string? UserNamespace { get; set; }\n        public bool ShouldGenerateLogging { get; set; }\n        public GenerationVariant Variant { get; set; } // Wymaga przeniesienia enum GenerationVariant\n\n        // Pre-kalkulowane flagi\n        public bool IsSinglePayloadVariant { get; set; }\n\n        /// <summary>\n        /// Zbiorcza, unikalna lista wszystkich przestrzeni nazw potrzebnych w generowanym pliku.\n        /// </summary>\n        public IReadOnlyCollection<string> AllRequiredNamespaces { get; set; }\n    }\n}\n",
            "Dtos\\TypeGenerationInfo.cs": "﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Generator.Model.Dtos\n{\n    public sealed record TypeGenerationInfo\n    {\n        /// <summary>\n        /// Nazwa typu sformatowana do użycia w kodzie (np. \"string\", \"List<int>\").\n        /// Wynik: TypeSystemHelper.FormatTypeForUsage()\n        /// </summary>\n        public string UsageName { get; set; }\n\n        /// <summary>\n        /// Nazwa typu sformatowana do użycia w typeof() (np. \"global::System.String\", \"List<>\").\n        /// Wynik: TypeSystemHelper.FormatForTypeof()\n        /// </summary>\n        public string TypeOfName { get; set; }\n\n        /// <summary>\n        /// Prosta nazwa typu bez przestrzeni nazw (np. \"String\", \"List\").\n        /// Wynik: TypeSystemHelper.GetSimpleTypeName()\n        /// </summary>\n        public string SimpleName { get; set; }\n\n        /// <summary>\n        /// Przestrzenie nazw wymagane przez ten typ i jego argumenty generyczne.\n        /// Wynik: TypeSystemHelper.GetRequiredNamespaces()\n        /// </summary>\n        public IEnumerable<string> RequiredNamespaces { get; set; }\n    }\n}\n",
            "Generator.Model.csproj": "﻿<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <TargetFramework>netstandard2.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n\t  <LangVersion>latest</LangVersion>\n  </PropertyGroup>\n\n</Project>\n"
        }
    },
    {
        "Source": "C:\\Users\\newon\\source\\repos\\FastFsm\\Generator.Rules",
        "FilesWithContent": {
            "Contexts\\AttributeTypeValidationContext.cs": "﻿namespace Generator.Rules.Contexts;\n\npublic class AttributeTypeValidationContext(\n    string stateTypeName,\n    bool isStateTypeEnum,\n    string triggerTypeName,\n    bool isTriggerTypeEnum)\n{\n    public string StateTypeName { get; } = stateTypeName; // Nazwa typu podanego dla stanu\n    public bool IsStateTypeEnum { get; } = isStateTypeEnum;\n    public string TriggerTypeName { get; } = triggerTypeName; // Nazwa typu podanego dla triggera\n    public bool IsTriggerTypeEnum { get; } = isTriggerTypeEnum;\n}",
            "Contexts\\ConflictingPayloadContext.cs": "﻿namespace Generator.Rules.Contexts;\n\npublic class ConflictingPayloadContext(\n    bool isWithPayloadVariant,\n    int triggerSpecificPayloadCount)\n{\n    public bool IsWithPayloadVariant { get; } = isWithPayloadVariant;\n    public int TriggerSpecificPayloadCount { get; } = triggerSpecificPayloadCount;\n}",
            "Contexts\\DuplicateTransitionContext.cs": "﻿using System.Collections.Generic;\nusing Generator.Rules.Definitions;\n\nnamespace Generator.Rules.Contexts;\n\n/// <summary>\n/// Context for validating a single transition against a set of already processed transitions\n/// to detect duplicates based on FromState and Trigger.\n/// </summary>\npublic class DuplicateTransitionContext(\n    TransitionDefinition currentTransition,\n    HashSet<TransitionDefinition> processedTransitions)\n{\n    /// <summary>\n    /// The current transition being checked for duplication.\n    /// </summary>\n    public TransitionDefinition CurrentTransition { get; } = currentTransition;\n\n    /// <summary>\n    /// A set of transitions that have already been processed.\n    /// The <see cref=\"TransitionDefinition.Equals(object?)\"/> and <see cref=\"TransitionDefinition.GetHashCode()\"/>\n    /// methods of <see cref=\"TransitionDefinition\"/> (which compare FromState and Trigger)\n    /// will be used by the HashSet to determine uniqueness.\n    /// </summary>\n    public HashSet<TransitionDefinition> ProcessedTransitions { get; } = processedTransitions;\n}",
            "Contexts\\EnumValueValidationContext.cs": "﻿namespace Generator.Rules.Contexts;\n\npublic class EnumValueValidationContext(string enumTypeName, string providedValueString, bool isValueDefinedInEnum)\n{\n    public string EnumTypeName { get; } = enumTypeName;\n    public string ProvidedValueString { get; } = providedValueString; // Wartość podana w atrybucie jako string\n    public bool IsValueDefinedInEnum { get; } = isValueDefinedInEnum; // Czy parser/analyzer znalazł tę wartość w enumie\n}",
            "Contexts\\ForcedVariantValidationContext.cs": "﻿namespace Generator.Rules.Contexts;\n\npublic class ForcedVariantValidationContext(\n    string variant,  // \"Pure\", \"WithPayload\", \"Full\" etc.\n    bool isForced,\n    bool hasDefaultPayloadType,\n    bool hasTriggerPayloadTypes,\n    bool hasOnEntryExit,\n    bool hasExtensions,\n    bool generateExtensibleVersion)\n{\n    public string Variant { get; } = variant;\n    public bool IsForced { get; } = isForced;\n    public bool HasDefaultPayloadType { get; } = hasDefaultPayloadType;\n    public bool HasTriggerPayloadTypes { get; } = hasTriggerPayloadTypes;\n    public bool HasOnEntryExit { get; } = hasOnEntryExit;\n    public bool HasExtensions { get; } = hasExtensions;\n    public bool GenerateExtensibleVersion { get; } = generateExtensibleVersion;\n}",
            "Contexts\\GuardWithPayloadContext.cs": "﻿namespace Generator.Rules.Contexts;\n\npublic class GuardWithPayloadContext(\n    string guardMethodName,\n    bool guardExpectsPayload,\n    bool machineHasPayload)\n{\n    public string GuardMethodName { get; } = guardMethodName;\n    public bool GuardExpectsPayload { get; } = guardExpectsPayload;\n    public bool MachineHasPayload { get; } = machineHasPayload;\n}",
            "Contexts\\InvalidVariantConfigContext.cs": "﻿namespace Generator.Rules.Contexts;\n\npublic class InvalidVariantConfigContext(\n    string variantName,\n    string conflictType,\n    bool hasConflict)\n{\n    public string VariantName { get; } = variantName;\n    public string ConflictType { get; } = conflictType; // \"PayloadTypes\", \"Extensions\", \"OnEntryExit\"\n    public bool HasConflict { get; } = hasConflict;\n}",
            "Contexts\\MethodSignatureValidationContext.cs": "﻿\n\nnamespace Generator.Rules.Contexts;\n\n// Kontekst dla walidacji sygnatury metody callback\npublic class MethodSignatureValidationContext(\n    string methodName,\n    string callbackType,\n    string expectedReturnType,\n    bool parametersAllowed)\n{\n    public string MethodName { get; } = methodName;\n    public string CallbackType { get; } = callbackType; // \"Guard\", \"Action\", \"OnEntry\", \"OnExit\"\n    public string ExpectedReturnType { get; } = expectedReturnType; // Np. \"bool\" lub \"void\"\n    public bool ParametersAllowed { get; } = parametersAllowed; // Dla Pure/Basic zazwyczaj false\n\n    // Informacje o rzeczywistej metodzie znalezionej przez parser/analyzer\n    public bool MethodFound { get; set; }\n    public string ActualReturnType { get; set; }\n    public int ActualParameterCount { get; set; }\n    public string? ExpectedParameterType { get; set; } // Oczekiwany typ parametru (jeśli payload)\n    public string? ActualParameterType { get; set; }   // Rzeczywisty typ parametru znaleziony\n}",
            "Contexts\\MissingPayloadTypeContext.cs": "﻿namespace Generator.Rules.Contexts;\n\npublic class MissingPayloadTypeContext(\n    string variant,\n    bool hasDefaultPayloadType,\n    bool hasTriggerPayloadTypes,\n    bool isForced)\n{\n    public string Variant { get; } = variant;\n    public bool HasDefaultPayloadType { get; } = hasDefaultPayloadType;\n    public bool HasTriggerPayloadTypes { get; } = hasTriggerPayloadTypes;\n    public bool IsForced { get; } = isForced;\n}",
            "Contexts\\MissingStateMachineAttributeValidationContext.cs": "﻿namespace Generator.Rules.Contexts;\n\npublic class MissingStateMachineAttributeValidationContext(\n    bool hasAttribute,\n    int argCount,\n    string className,\n    bool isPartial)\n{\n    public bool HasStateMachineAttribute { get; } = hasAttribute;\n    public int FsmAttributeConstructorArgCount { get; } = argCount; \n    public string ClassName { get; } = className;\n    public bool IsClassPartial { get; } = isPartial; \n}",
            "Contexts\\MixedModeRule.cs": "﻿using System.Collections.Generic;\nusing Generator.Rules.Definitions;\nusing Generator.Rules.Rules;\n\nnamespace Generator.Rules.Contexts;\n\n/// <summary>\n/// FSM011 - Validates that a state machine does not mix sync and async callbacks.\n/// </summary>\npublic class MixedModeRule : IValidationRule<MixedModeValidationContext>\n{\n    public IEnumerable<ValidationResult> Validate(MixedModeValidationContext context)\n    {\n        // Ta reguła jest prosta, bo cała logika wykrywania konfliktu\n        // jest w parserze. Reguła tylko formatuje komunikat.\n        if (context.CallbackMode != context.MachineMode)\n        {\n            string message = string.Format(\n                DefinedRules.MixedSyncAsyncCallbacks.MessageFormat,\n                context.MethodName,\n                context.CallbackMode,\n                context.MachineMode\n            );\n\n            yield return ValidationResult.Fail(\n                RuleIdentifiers.MixedSyncAsyncCallbacks,\n                message,\n                DefinedRules.MixedSyncAsyncCallbacks.DefaultSeverity\n            );\n        }\n        else\n        {\n            yield return ValidationResult.Success();\n        }\n    }\n}",
            "Contexts\\MixedModeValidationContext.cs": "﻿namespace Generator.Rules.Contexts;\n\n/// <summary>\n/// Context for validating that a state machine does not mix synchronous and asynchronous callbacks.\n/// </summary>\npublic class MixedModeValidationContext(\n    string methodName,\n    string callbackMode,\n    string machineMode)\n{\n    /// <summary>\n    /// The name of the method that caused the conflict.\n    /// </summary>\n    public string MethodName { get; } = methodName;\n\n    /// <summary>\n    /// The mode of the conflicting callback (e.g., \"asynchronous\").\n    /// </summary>\n    public string CallbackMode { get; } = callbackMode;\n\n    /// <summary>\n    /// The established mode of the state machine (e.g., \"synchronous\").\n    /// </summary>\n    public string MachineMode { get; } = machineMode;\n}",
            "Contexts\\UnreachableStateContext.cs": "﻿using System.Collections.Generic;\nusing Generator.Rules.Definitions;\n\nnamespace Generator.Rules.Contexts;\n\npublic class UnreachableStateContext( // Zmieniona nazwa klasy\n    string initialState,\n    IReadOnlyList<string> allStateNames,\n    IReadOnlyList<TransitionDefinition> allTransitions) // Zmieniony typ dla allTransitions\n{\n    /// <summary>\n    /// The designated initial state of the state machine.\n    /// If not explicitly defined, a default might be assumed by the rule (e.g., the first state alphabetically).\n    /// </summary>\n    public string InitialState { get; } = initialState;\n\n    /// <summary>\n    /// A list of all unique state names defined for the state machine.\n    /// </summary>\n    public IReadOnlyList<string> AllDefinedStateNames { get; } = allStateNames;\n\n    /// <summary>\n    /// A list of all transitions defined in the state machine.\n    /// The rule will use the <see cref=\"TransitionDefinition.ToState\"/> property\n    /// to determine reachability.\n    /// </summary>\n    public IReadOnlyList<TransitionDefinition> AllTransitions { get; } = allTransitions;\n}",
            "Definitions\\RuleDefinition.cs": "﻿\n\nusing System.Collections.Generic;\n\nnamespace Generator.Rules.Definitions;\n\npublic class RuleDefinition(\n    string id,\n    string title,\n    string messageFormat,\n    string category,\n    RuleSeverity defaultSeverity,\n    string description,\n    bool isEnabledByDefault = true)\n{\n    public string Id { get; } = id;\n    public string Title { get; } = title;\n    public string MessageFormat { get; } = messageFormat; // Może być używany bezpośrednio lub jako klucz do zasobów\n    public string Category { get; } = category;\n    public RuleSeverity DefaultSeverity { get; } = defaultSeverity;\n    public string Description { get; } = description;\n    public bool IsEnabledByDefault { get; } = isEnabledByDefault;\n}\n\npublic static class DefinedRules\n{\n    public static readonly RuleDefinition DuplicateTransition = new(\n        id: RuleIdentifiers.DuplicateTransition, // \"FSM001\"\n        title: \"Duplicate transition detected\",\n        messageFormat: \"Duplicate transition from state '{0}' on trigger '{1}'. Only the first one will be used by the generator.\",\n        category: \"FSM.Generator\",\n        defaultSeverity: RuleSeverity.Warning,\n        description: \"There are multiple transitions defined for the same 'from state' and 'trigger'. The generator will only consider the first one encountered.\");\n\n    public static readonly RuleDefinition UnreachableState = new(\n        id: RuleIdentifiers.UnreachableState, // \"FSM002\"\n        title: \"Unreachable state detected\",\n        messageFormat: \"State '{0}' might be unreachable based on defined transitions.\",\n        category: \"FSM.Generator\",\n        defaultSeverity: RuleSeverity.Warning,\n        description: \"A state exists in the state enum that may not be reachable from the initial state or any other state via the defined transitions. This is a simplified check.\");\n\n    public static readonly RuleDefinition InvalidMethodSignature = new(\n        id: RuleIdentifiers.InvalidMethodSignature, // \"FSM003\"\n        title: \"Invalid method signature for FSM callback\",\n        messageFormat: \"Method '{0}' used as {1} has an invalid signature. Expected: '{2}'.\",\n        category: \"FSM.Generator\",\n        defaultSeverity: RuleSeverity.Error,\n        description: \"Guard, Action, OnEntry, or OnExit methods must have a specific signature (e.g., guards return bool, actions are void; both can optionally take object? payload).\");\n\n    public static readonly RuleDefinition MissingStateMachineAttribute = new(\n        id: RuleIdentifiers.MissingStateMachineAttribute, // \"FSM004\"\n        title: \"Potentially missing StateMachine attribute\",\n        messageFormat: \"Class '{0}' uses FSM transition attributes but is missing the [StateMachine(typeof(StateEnum), typeof(TriggerEnum))] attribute, or is not partial.\",\n        category: \"FSM.Generator\",\n        defaultSeverity: RuleSeverity.Warning, \n        description: \"If this class is intended to be a FSM, it needs the [StateMachine] attribute and must be declared as partial.\");\n\n    public static readonly RuleDefinition InvalidTypesInAttribute = new(\n        id: RuleIdentifiers.InvalidTypesInAttribute,          // \"FSM005\"\n        title: \"State/Trigger types must be enums\",\n        messageFormat: \"State and Trigger types must be enums. '{0}' or '{1}' is not an enum.\",\n        category: \"FSM.Generator\",\n        defaultSeverity: RuleSeverity.Error,\n        description: \"The StateType and TriggerType arguments of the StateMachineAttribute must be enum types.\");\n\n\n    public static readonly RuleDefinition InvalidEnumValueInTransition = new(\n        id: RuleIdentifiers.InvalidEnumValueInTransition, // \"FSM006\"\n        title: \"Invalid enum value in transition\",\n        messageFormat: \"Invalid enum value '{0}' for enum type '{1}'. Use a valid enum member.\",\n        category: \"FSM.Generator\",\n        defaultSeverity: RuleSeverity.Error,\n        description: \"Enum values in transition attributes must be valid members of the specified enum type.\");\n\n    public static readonly RuleDefinition MissingPayloadType = new(\n        id: RuleIdentifiers.MissingPayloadType,\n        title: \"Missing payload type definition\",\n        messageFormat: \"State machine forced to use '{0}' variant but no payload type is defined. Add [PayloadType] attribute or change the generation mode.\",\n        category: \"FSM.Generator\",\n        defaultSeverity: RuleSeverity.Error,\n        description: \"WithPayload and Full variants require at least one payload type to be defined via [PayloadType] attribute.\");\n\n    public static readonly RuleDefinition ConflictingPayloadConfiguration = new(\n        id: RuleIdentifiers.ConflictingPayloadConfiguration,\n        title: \"Conflicting payload configuration\",\n        messageFormat: \"Forced 'WithPayload' variant expects single payload type but found {0} trigger-specific types. Use 'Full' variant or remove Force to allow auto-detection.\",\n        category: \"FSM.Generator\",\n        defaultSeverity: RuleSeverity.Error,\n        description: \"WithPayload variant supports only single payload type. For multiple payload types use Full variant.\");\n\n    public static readonly RuleDefinition InvalidForcedVariantConfiguration = new(\n        id: RuleIdentifiers.InvalidForcedVariantConfiguration,\n        title: \"Invalid forced variant configuration\",\n        messageFormat: \"Forced '{0}' variant conflicts with {1}. {2}\",\n        category: \"FSM.Generator\",\n        defaultSeverity: RuleSeverity.Error,\n        description: \"Forced variant has conflicting configuration that prevents proper code generation.\");\n\n\n    public static readonly RuleDefinition GuardWithPayloadInNonPayloadMachine = new(\n        id: RuleIdentifiers.GuardWithPayloadInNonPayloadMachine,\n        title: \"Guard with payload in non-payload machine\",\n        messageFormat: \"{0}\",\n        category: \"StateMachine.Design\",\n        defaultSeverity: RuleSeverity.Error,\n        isEnabledByDefault: true,\n        description: \"Guards that expect payload parameters cannot be used in state machines without payload support.\");\n    public static readonly RuleDefinition MixedSyncAsyncCallbacks = new(\n        id: RuleIdentifiers.MixedSyncAsyncCallbacks,\n        title: \"Mixed synchronous and asynchronous callbacks\",\n        messageFormat: \"Cannot mix synchronous and asynchronous callbacks in the same state machine. Method '{0}' is {1}, but the machine is already configured as {2}.\",\n        category: \"FSM.Generator.Async\",\n        defaultSeverity: RuleSeverity.Error,\n        description: \"All state machine callbacks (OnEntry, OnExit, Action, Guard) must be either all synchronous or all asynchronous to ensure consistent behavior.\");\n\n    public static readonly RuleDefinition InvalidGuardTaskReturnType = new(\n        id: RuleIdentifiers.InvalidGuardTaskReturnType,\n        title: \"Invalid async guard return type\",\n        messageFormat: \"Asynchronous guards must return 'ValueTask<bool>', not 'Task<bool>'. Method '{0}' has an invalid return type.\",\n        category: \"FSM.Generator.Async\",\n        defaultSeverity: RuleSeverity.Error,\n        description: \"Using Task<bool> for guards causes unnecessary memory allocations. Use ValueTask<bool> for optimal performance.\");\n\n    public static readonly RuleDefinition InvalidAsyncVoid = new(\n        id: RuleIdentifiers.InvalidAsyncVoid,\n        title: \"Callback returns 'async void'\",\n        messageFormat: \"Callback method '{0}' returns 'async void'. Use 'Task' or 'ValueTask' instead to allow the state machine to correctly await its completion and handle exceptions.\",\n        category: \"FSM.Generator.Async\",\n        defaultSeverity: RuleSeverity.Warning,\n        description: \"'async void' methods are fire-and-forget and can lead to unhandled exceptions and race conditions. State machine callbacks should always be awaitable.\");\n    public static readonly RuleDefinition AsyncCallbackInSyncMachine = new(\n        id: RuleIdentifiers.AsyncCallbackInSyncMachine,\n        title: \"Asynchronous callback in synchronous state machine\",\n        messageFormat: \"Method '{0}' is asynchronous, but the state machine is synchronous. Either make all callbacks asynchronous or change the return type of this method.\",\n        category: \"FSM.Generator.Async\",\n        defaultSeverity: RuleSeverity.Error,\n        description: \"A state machine must be consistently synchronous or asynchronous. Mixing callback types can lead to unexpected behavior and deadlocks.\");\n\n    // HSM-specific rules (FSM100-FSM105)\n    public static readonly RuleDefinition CircularHierarchy = new(\n        id: RuleIdentifiers.CircularHierarchy,  // FSM100\n        title: \"Circular hierarchy detected\",\n        messageFormat: \"State '{0}' is part of a circular hierarchy chain: {1}. Fix: Review the Parent relationships and remove the circular dependency.\",\n        category: \"FSM.Generator.HSM\",\n        defaultSeverity: RuleSeverity.Error,\n        description: \"State hierarchies cannot contain circular dependencies. A state cannot be its own ancestor or descendant.\");\n\n    public static readonly RuleDefinition OrphanSubstate = new(\n        id: RuleIdentifiers.OrphanSubstate,  // FSM101\n        title: \"Multiple or divergent parent\",\n        messageFormat: \"State '{0}' references parent '{1}' which does not exist. Fix: Either define the parent state with [State({1})], or correct the Parent parameter to reference an existing state.\",\n        category: \"FSM.Generator.HSM\",\n        defaultSeverity: RuleSeverity.Error,\n        description: \"All parent states referenced by substates must be defined in the state machine. Check for typos in the parent state name.\");\n\n    public static readonly RuleDefinition InvalidHierarchyConfiguration = new(\n        id: RuleIdentifiers.InvalidHierarchyConfiguration,  // FSM102\n        title: \"Composite without initial state\",\n        messageFormat: \"Composite state '{0}' has no initial substate defined. Fix: Add [InitialSubstate({0}, YourInitialChild)] attribute, or set History = HistoryMode.Shallow/Deep on the composite state.\",\n        category: \"FSM.Generator.HSM\",\n        defaultSeverity: RuleSeverity.Error,\n        description: \"Composite states must have an initial substate to determine which child state to enter. Either define an initial substate or use history mode to remember the last active child.\");\n\n    public static readonly RuleDefinition MultipleInitialSubstates = new(\n        id: RuleIdentifiers.MultipleInitialSubstates,  // FSM103\n        title: \"Multiple initial children\",\n        messageFormat: \"Composite state '{0}' has multiple initial substates: '{1}' and '{2}'. Fix: Keep only one [InitialSubstate({0}, ...)] attribute.\",\n        category: \"FSM.Generator.HSM\",\n        defaultSeverity: RuleSeverity.Error,\n        description: \"A composite state can only have one initial substate. Remove duplicate InitialSubstate attributes.\");\n\n    public static readonly RuleDefinition InvalidHistoryConfiguration = new(\n        id: RuleIdentifiers.InvalidHistoryConfiguration,  // FSM104\n        title: \"History on non-composite\",\n        messageFormat: \"State '{0}' has History = {1} but is not a composite state (has no children). Fix: Either remove the History parameter, or add child states with Parent = {0}.\",\n        category: \"FSM.Generator.HSM\",\n        defaultSeverity: RuleSeverity.Error,\n        description: \"Only composite states (states with children) can have history mode. History remembers which child was last active.\");\n\n    public static readonly RuleDefinition ConflictingTransitionTargets = new(\n        id: RuleIdentifiers.ConflictingTransitionTargets,  // FSM105\n        title: \"Transition to composite without explicit child\",\n        messageFormat: \"Transition to composite state '{0}' without explicit target substate. The state machine will enter '{1}' (reason: {2}). To be explicit, transition directly to the desired substate.\",\n        category: \"FSM.Generator.HSM\",\n        defaultSeverity: RuleSeverity.Info,\n        description: \"When transitioning to a composite state without specifying a target substate, the entry point is determined by: 1) History mode (if set and previously visited), 2) Initial substate (if defined), or 3) First defined child.\");\n\n    public static readonly IReadOnlyList<RuleDefinition> All = new List<RuleDefinition>\n    {\n        DuplicateTransition,\n        UnreachableState,\n        InvalidMethodSignature,\n        MissingStateMachineAttribute,\n        InvalidTypesInAttribute,\n        InvalidEnumValueInTransition,\n        MissingPayloadType,  \n        ConflictingPayloadConfiguration,  \n        InvalidForcedVariantConfiguration,\n        GuardWithPayloadInNonPayloadMachine,\n        MixedSyncAsyncCallbacks,\n        InvalidGuardTaskReturnType,\n        InvalidAsyncVoid,\n        AsyncCallbackInSyncMachine,\n        // HSM rules (FSM100-FSM105)\n        CircularHierarchy,              // FSM100\n        OrphanSubstate,                 // FSM101\n        InvalidHierarchyConfiguration,  // FSM102\n        MultipleInitialSubstates,       // FSM103\n        InvalidHistoryConfiguration,    // FSM104\n        ConflictingTransitionTargets,   // FSM105\n    }.AsReadOnly();\n}",
            "Definitions\\RuleIdentifiers.cs": "﻿\n\nnamespace Generator.Rules.Definitions;\n\npublic static class RuleIdentifiers\n{\n    public const string DuplicateTransition = \"FSM001\";\n    public const string UnreachableState = \"FSM002\";\n    public const string InvalidMethodSignature = \"FSM003\";\n    public const string MissingStateMachineAttribute = \"FSM004\";\n    public const string InvalidTypesInAttribute = \"FSM005\";\n    public const string InvalidEnumValueInTransition = \"FSM006\";\n    public const string MissingPayloadType = \"FSM007\";\n    public const string ConflictingPayloadConfiguration = \"FSM008\";\n    public const string InvalidForcedVariantConfiguration = \"FSM009\";\n    public const string GuardWithPayloadInNonPayloadMachine = \"FSM010\";\n    public const string MixedSyncAsyncCallbacks = \"FSM011\";\n    public const string InvalidGuardTaskReturnType = \"FSM012\";\n    public const string AsyncCallbackInSyncMachine = \"FSM013\"; // Ta reguła jest logocznie tożsama z FSM011, ale może mieć inny komunikat\n    public const string InvalidAsyncVoid = \"FSM014\";\n    \n    // HSM-specific diagnostics\n    public const string CircularHierarchy = \"FSM100\";                     // Cyclical hierarchy\n    public const string OrphanSubstate = \"FSM101\";                       // Multiple or divergent parent  \n    public const string InvalidHierarchyConfiguration = \"FSM102\";        // Composite without initial state\n    public const string MultipleInitialSubstates = \"FSM103\";             // Multiple initial children\n    public const string InvalidHistoryConfiguration = \"FSM104\";          // History on non-composite\n    public const string ConflictingTransitionTargets = \"FSM105\";         // Transition to composite without explicit child\n\n}\n",
            "Definitions\\RuleSeverity.cs": "﻿namespace Generator.Rules.Definitions;\n\npublic enum RuleSeverity\n{\n    Error,\n    Warning,\n    Info\n\n}",
            "Definitions\\TransitionDefinition.cs": "﻿namespace Generator.Rules.Definitions;\n\npublic class TransitionDefinition(string fromState, string trigger, string? toState = null)\n{\n    public string FromState { get; } = fromState;\n    public string Trigger { get; } = trigger;\n    public string? ToState { get; } = toState;\n\n    /// <summary>\n    /// Determines whether the specified object is equal to the current object.\n    /// For TransitionDefinition, equality for use in sets (like for duplicate detection)\n    /// is based on FromState and Trigger only. ToState is not considered.\n    /// </summary>\n    public override bool Equals(object? obj)\n    {\n        if (obj is not TransitionDefinition other)\n            return false;\n\n        // For the purpose of duplicate transition detection (FSM001),\n        // only FromState and Trigger are considered. ToState can differ.\n        return FromState == other.FromState && Trigger == other.Trigger;\n    }\n\n    /// <summary>\n    /// Serves as the default hash function.\n    /// The hash code is based on FromState and Trigger only, to align with Equals behavior.\n    /// </summary>\n    public override int GetHashCode()\n    {\n        return (FromState, Trigger).GetHashCode();\n    }\n\n\n    public bool EqualsIncludingToState(TransitionDefinition? other)\n    {\n        if (other is null)\n            return false;\n\n        return FromState == other.FromState &&\n               Trigger == other.Trigger &&\n               ToState == other.ToState;\n    }\n}",
            "Definitions\\ValidationResult.cs": "﻿using System;\n\nnamespace Generator.Rules.Definitions;\n\npublic class ValidationResult\n{\n    public bool IsValid { get; }\n    public string? RuleId { get; } \n    public string? Message { get; } \n    public RuleSeverity Severity { get; }\n\n    private ValidationResult(bool isValid, string? ruleId, string? message, RuleSeverity severity)\n    {\n        IsValid = isValid;\n        RuleId = ruleId;\n        Message = message;\n        Severity = severity;\n    }\n\n    public static ValidationResult Success() => new(true, null, null, RuleSeverity.Info); // Info or a specific \"SuccessSeverity\"\n\n    public static ValidationResult Fail(string ruleId, string message, RuleSeverity severity)\n    {\n        if (string.IsNullOrEmpty(ruleId)) throw new ArgumentNullException(nameof(ruleId));\n        if (string.IsNullOrEmpty(message)) throw new ArgumentNullException(nameof(message));\n        return new ValidationResult(false, ruleId, message, severity);\n    }\n}",
            "Rules\\ConflictingPayloadRule.cs": "﻿using Generator.Rules.Contexts;\nusing Generator.Rules.Definitions;\nusing System.Collections.Generic;\n\nnamespace Generator.Rules.Rules;\n\npublic class ConflictingPayloadRule : IValidationRule<ConflictingPayloadContext>\n{\n    public IEnumerable<ValidationResult> Validate(ConflictingPayloadContext context)\n    {\n        if (context.IsWithPayloadVariant && context.TriggerSpecificPayloadCount > 0)\n        {\n            string message = string.Format(\n                DefinedRules.ConflictingPayloadConfiguration.MessageFormat,\n                context.TriggerSpecificPayloadCount);\n\n            yield return ValidationResult.Fail(\n                RuleIdentifiers.ConflictingPayloadConfiguration,\n                message,\n                DefinedRules.ConflictingPayloadConfiguration.DefaultSeverity);\n        }\n        else\n        {\n            yield return ValidationResult.Success();\n        }\n    }\n}",
            "Rules\\DuplicateTransitionRule.cs": "﻿\n\nusing System.Collections.Generic;\nusing Generator.Rules.Contexts;\nusing Generator.Rules.Definitions;\n\n\nnamespace Generator.Rules.Rules;\n\n// Zmieniono typ kontekstu na DuplicateTransitionContext\npublic class DuplicateTransitionRule : IValidationRule<DuplicateTransitionContext>\n{\n    // Zmieniono typ zwracany na IEnumerable<ValidationResult>\n    public IEnumerable<ValidationResult> Validate(DuplicateTransitionContext context)\n    {\n        // Logika .Add() na HashSet<TransitionDefinition> będzie działać zgodnie z oczekiwaniami\n        // dzięki implementacji Equals/GetHashCode w TransitionDefinition (porównującej FromState i Trigger).\n        if (!context.ProcessedTransitions.Add(context.CurrentTransition))\n        {\n            // MessageFormat dla FSM001: \"Duplicate transition from state '{0}' on trigger '{1}'. Only the first one will be used by the generator.\"\n            string message = string.Format(\n                DefinedRules.DuplicateTransition.MessageFormat,\n                context.CurrentTransition.FromState, // {0}\n                context.CurrentTransition.Trigger    // {1}\n            );\n            // Zwracamy kolekcję z jednym wynikiem błędu\n            yield return ValidationResult.Fail(\n                RuleIdentifiers.DuplicateTransition,\n                message,\n                DefinedRules.DuplicateTransition.DefaultSeverity // Używamy domyślnej ważności z RuleDefinition\n            );\n        }\n        else\n        {\n            // Jeśli nie ma duplikatu, zwracamy kolekcję z jednym wynikiem sukcesu.\n            // Alternatywnie można by użyć yield break; jeśli parser byłby przygotowany\n            // na obsługę pustej kolekcji jako \"brak problemów\".\n            // Dla spójności z tym, że każda reguła \"coś\" zwraca, Success() jest tutaj OK.\n            yield return ValidationResult.Success();\n        }\n    }\n}",
            "Rules\\GuardWithPayloadInNonPayloadMachineRule.cs": "﻿using System.Collections.Generic;\nusing Generator.Rules.Contexts;\nusing Generator.Rules.Definitions;\n\nnamespace Generator.Rules.Rules;\n\n/// <summary>\n/// FSM010 – Guard expects payload, ale maszyna nie obsługuje payloadów.\n/// </summary>\npublic class GuardWithPayloadInNonPayloadMachineRule\n    : IValidationRule<GuardWithPayloadContext>\n{\n    public IEnumerable<ValidationResult> Validate(GuardWithPayloadContext context)\n    {\n        if (context.GuardExpectsPayload && !context.MachineHasPayload)\n        {\n            yield return ValidationResult.Fail(\n                RuleIdentifiers.GuardWithPayloadInNonPayloadMachine,\n                $\"Guard method '{context.GuardMethodName}' expects a payload parameter, \" +\n                \"but the state machine is configured without payload support. \" +\n                \"Either remove the parameter from the guard method or configure the state machine \" +\n                \"with payload support using [PayloadType] attribute.\",\n                RuleSeverity.Error);\n        }\n    }\n}",
            "Rules\\InvalidEnumValueInTransitionRule.cs": "﻿\n\nusing System.Collections.Generic;\nusing Generator.Rules.Contexts;\nusing Generator.Rules.Definitions;\n\n// Dodajemy using dla IEnumerable\n\nnamespace Generator.Rules.Rules;\n\npublic class InvalidEnumValueInTransitionRule : IValidationRule<EnumValueValidationContext>\n{\n    // Zmieniono typ zwracany na IEnumerable<ValidationResult>\n    public IEnumerable<ValidationResult> Validate(EnumValueValidationContext context)\n    {\n        if (!context.IsValueDefinedInEnum)\n        {\n            string message = string.Format(\n                DefinedRules.InvalidEnumValueInTransition.MessageFormat,\n                context.ProvidedValueString ?? \"null\", // {0}\n                context.EnumTypeName                  // {1}\n            );\n            // Używamy yield return i DefaultSeverity\n            yield return ValidationResult.Fail(\n                RuleIdentifiers.InvalidEnumValueInTransition,\n                message,\n                DefinedRules.InvalidEnumValueInTransition.DefaultSeverity\n            );\n        }\n        else\n        {\n            // Używamy yield return\n            yield return ValidationResult.Success();\n        }\n    }\n}",
            "Rules\\InvalidMethodSignatureRule.cs": "﻿using System.Collections.Generic;\nusing Generator.Rules.Contexts;\nusing Generator.Rules.Definitions;\n\nnamespace Generator.Rules.Rules;\n\n/// <summary>\n/// Validates method signature for FSM callbacks.\n/// </summary>\npublic class InvalidMethodSignatureRule : IValidationRule<MethodSignatureValidationContext>\n{\n    private const string ParameterlessSignatureFormat = \"{0} {1}()\";\n    private const string ParameterSignatureFormat = \"{0} {1}({2} payload)\";\n    private const string BothSignaturesFormat = \"{0} {1}() or {1}({2} payload)\";\n    private const string UnknownType = \"unknown\";\n    private const string NotFoundSuffix = \" (method not found)\";\n    private const string MustBeParameterlessSuffix = \" (must be parameterless)\";\n    private const string FoundParameterTypeSuffix = \" (found parameter type: {0})\";\n    private const string FoundParameterCountSuffix = \" (found {0} parameters)\";\n\n    public IEnumerable<ValidationResult> Validate(MethodSignatureValidationContext context)\n    {\n        // Method not found\n        if (!context.MethodFound)\n        {\n            string expectedSignature = BuildExpectedSignature(context) + NotFoundSuffix;\n            string message = string.Format(\n                DefinedRules.InvalidMethodSignature.MessageFormat,\n                context.MethodName,\n                context.CallbackType,\n                expectedSignature\n            );\n            yield return ValidationResult.Fail(\n                RuleIdentifiers.InvalidMethodSignature,\n                message,\n                DefinedRules.InvalidMethodSignature.DefaultSeverity\n            );\n            yield break;\n        }\n\n        // Too many parameters for parameterless expected\n        if (!context.ParametersAllowed && context.ActualParameterCount > 0)\n        {\n            string expectedSignature = string.Format(ParameterlessSignatureFormat, context.ExpectedReturnType.ToLowerInvariant(), context.MethodName) + MustBeParameterlessSuffix;\n            string message = string.Format(\n                DefinedRules.InvalidMethodSignature.MessageFormat,\n                context.MethodName,\n                context.CallbackType,\n                expectedSignature\n            );\n            yield return ValidationResult.Fail(\n                RuleIdentifiers.InvalidMethodSignature,\n                message,\n                DefinedRules.InvalidMethodSignature.DefaultSeverity\n            );\n            yield break;\n        }\n\n        // Validate parameter type for payload callbacks\n        if (context.ParametersAllowed && context.ExpectedParameterType != null)\n        {\n            if (context.ActualParameterCount == 0)\n            {\n                // Parameterless method is OK for backward compatibility\n            }\n            else if (context.ActualParameterCount == 1)\n            {\n                if (context.ActualParameterType != context.ExpectedParameterType)\n                {\n                    string expectedSignature = string.Format(ParameterSignatureFormat,\n                        context.ExpectedReturnType.ToLowerInvariant(),\n                        context.MethodName,\n                        GetSimpleTypeName(context.ExpectedParameterType))\n                        + string.Format(FoundParameterTypeSuffix, GetSimpleTypeName(context.ActualParameterType));\n                    string message = string.Format(\n                        DefinedRules.InvalidMethodSignature.MessageFormat,\n                        context.MethodName,\n                        context.CallbackType,\n                        expectedSignature\n                    );\n                    yield return ValidationResult.Fail(\n                        RuleIdentifiers.InvalidMethodSignature,\n                        message,\n                        DefinedRules.InvalidMethodSignature.DefaultSeverity\n                    );\n                    yield break;\n                }\n            }\n            else\n            {\n                string expectedSignature = string.Format(BothSignaturesFormat,\n                        context.ExpectedReturnType.ToLowerInvariant(),\n                        context.MethodName,\n                        GetSimpleTypeName(context.ExpectedParameterType))\n                    + string.Format(FoundParameterCountSuffix, context.ActualParameterCount);\n                string message = string.Format(\n                    DefinedRules.InvalidMethodSignature.MessageFormat,\n                    context.MethodName,\n                    context.CallbackType,\n                    expectedSignature\n                );\n                yield return ValidationResult.Fail(\n                    RuleIdentifiers.InvalidMethodSignature,\n                    message,\n                    DefinedRules.InvalidMethodSignature.DefaultSeverity\n                );\n                yield break;\n            }\n        }\n\n        // Check return type\n        if (context.ActualReturnType?.ToLowerInvariant() != context.ExpectedReturnType.ToLowerInvariant())\n        {\n            string expectedSignature = BuildExpectedSignature(context);\n            string message = string.Format(\n                DefinedRules.InvalidMethodSignature.MessageFormat,\n                context.MethodName,\n                context.CallbackType,\n                expectedSignature\n            );\n            yield return ValidationResult.Fail(\n                RuleIdentifiers.InvalidMethodSignature,\n                message,\n                DefinedRules.InvalidMethodSignature.DefaultSeverity\n            );\n            yield break;\n        }\n\n        yield return ValidationResult.Success();\n    }\n\n    private string BuildExpectedSignature(MethodSignatureValidationContext context)\n    {\n        var returnType = context.ExpectedReturnType.ToLowerInvariant();\n        var methodName = context.MethodName;\n\n        if (!context.ParametersAllowed)\n        {\n            return string.Format(ParameterlessSignatureFormat, returnType, methodName);\n        }\n        else if (context.ExpectedParameterType != null)\n        {\n            var paramType = GetSimpleTypeName(context.ExpectedParameterType);\n            return string.Format(BothSignaturesFormat, returnType, methodName, paramType);\n        }\n        else\n        {\n            return $\"{returnType} {methodName}(...)\";\n        }\n    }\n\n    private string GetSimpleTypeName(string? fullyQualifiedName)\n    {\n        if (string.IsNullOrEmpty(fullyQualifiedName))\n            return UnknownType;\n\n        int lastDot = fullyQualifiedName.LastIndexOf('.');\n        return lastDot >= 0 ? fullyQualifiedName.Substring(lastDot + 1) : fullyQualifiedName;\n    }\n}\n",
            "Rules\\InvalidTypesInAttributeRule.cs": "﻿using System.Collections.Generic;\nusing Generator.Rules.Contexts;\nusing Generator.Rules.Definitions;\n\nnamespace Generator.Rules.Rules;\n\n/// <summary>\n/// Validates that types used in [StateMachineAttribute] are enums.\n/// </summary>\npublic class InvalidTypesInAttributeRule : IValidationRule<AttributeTypeValidationContext>\n{\n    private const string UnknownType = \"Unknown Type\";\n    private const string StateTypeNotEnumFormat = \"Type provided for State ('{0}') in [StateMachineAttribute] must be an enum.\";\n    private const string TriggerTypeNotEnumFormat = \"Type provided for Trigger ('{0}') in [StateMachineAttribute] must be an enum.\";\n\n    public IEnumerable<ValidationResult> Validate(AttributeTypeValidationContext context)\n    {\n        if (!context.IsStateTypeEnum || !context.IsTriggerTypeEnum)\n        {\n            string stateTypeName = context.StateTypeName ?? UnknownType;\n            string triggerTypeName = context.TriggerTypeName ?? UnknownType;\n\n            string finalMessage;\n            if (!context.IsStateTypeEnum && !context.IsTriggerTypeEnum)\n            {\n                // Both types are invalid\n                finalMessage = string.Format(\n                    DefinedRules.InvalidTypesInAttribute.MessageFormat,\n                    stateTypeName,\n                    triggerTypeName);\n            }\n            else if (!context.IsStateTypeEnum)\n            {\n                finalMessage = string.Format(StateTypeNotEnumFormat, stateTypeName);\n            }\n            else // !context.IsTriggerTypeEnum\n            {\n                finalMessage = string.Format(TriggerTypeNotEnumFormat, triggerTypeName);\n            }\n\n            yield return ValidationResult.Fail(\n                RuleIdentifiers.InvalidTypesInAttribute,\n                finalMessage,\n                DefinedRules.InvalidTypesInAttribute.DefaultSeverity\n            );\n        }\n        else\n        {\n            yield return ValidationResult.Success();\n        }\n    }\n}\n",
            "Rules\\InvalidVariantConfigRule.cs": "﻿using Generator.Rules.Contexts;\nusing Generator.Rules.Definitions;\nusing System.Collections.Generic;\n\nnamespace Generator.Rules.Rules;\n\npublic class InvalidVariantConfigRule : IValidationRule<InvalidVariantConfigContext>\n{\n    public IEnumerable<ValidationResult> Validate(InvalidVariantConfigContext context)\n    {\n        if (!context.HasConflict)\n        {\n            yield return ValidationResult.Success();\n            yield break;\n        }\n\n        string reason = context.ConflictType switch\n        {\n            \"PayloadTypes\" => \"Remove PayloadType attributes or use WithPayload/Full variant.\",\n            \"Extensions\" => \"Set GenerateExtensibleVersion=true or use different variant.\",\n            \"OnEntryExit\" => \"Remove OnEntry/OnExit methods or use Basic/WithExtensions/Full variant.\",\n            _ => \"Check variant requirements.\"\n        };\n\n        string message = string.Format(\n            DefinedRules.InvalidForcedVariantConfiguration.MessageFormat,\n            context.VariantName,\n            context.ConflictType,\n            reason);\n\n        yield return ValidationResult.Fail(\n            RuleIdentifiers.InvalidForcedVariantConfiguration,\n            message,\n            DefinedRules.InvalidForcedVariantConfiguration.DefaultSeverity);\n    }\n}",
            "Rules\\IValidationRule.cs": "﻿using System.Collections.Generic;\nusing Generator.Rules.Definitions;\n\nnamespace Generator.Rules.Rules;\n\npublic interface IValidationRule<in TContext> where TContext : class\n{\n    IEnumerable<ValidationResult> Validate(TContext context);\n}",
            "Rules\\MissingPayloadTypeRule.cs": "﻿using Generator.Rules.Contexts;\nusing Generator.Rules.Definitions;\nusing System.Collections.Generic;\n\nnamespace Generator.Rules.Rules;\n\npublic class MissingPayloadTypeRule : IValidationRule<MissingPayloadTypeContext>\n{\n    public IEnumerable<ValidationResult> Validate(MissingPayloadTypeContext context)\n    {\n        if (!context.IsForced)\n        {\n            yield return ValidationResult.Success();\n            yield break;\n        }\n\n        bool requiresPayload = context.Variant == \"WithPayload\" || context.Variant == \"Full\";\n        bool hasPayload = context.HasDefaultPayloadType || context.HasTriggerPayloadTypes;\n\n        if (requiresPayload && !hasPayload)\n        {\n            string message = string.Format(\n                DefinedRules.MissingPayloadType.MessageFormat,\n                context.Variant);\n\n            yield return ValidationResult.Fail(\n                RuleIdentifiers.MissingPayloadType,\n                message,\n                DefinedRules.MissingPayloadType.DefaultSeverity);\n        }\n        else\n        {\n            yield return ValidationResult.Success();\n        }\n    }\n}",
            "Rules\\MissingStateMachineAttributeRule.cs": "﻿using System.Collections.Generic;\nusing Generator.Rules.Contexts;\nusing Generator.Rules.Definitions;\n\nnamespace Generator.Rules.Rules;\n\n/// <summary>\n/// Validates presence and correctness of the [StateMachine] attribute on FSM classes.\n/// </summary>\npublic class MissingStateMachineAttributeRule : IValidationRule<MissingStateMachineAttributeValidationContext>\n{\n    private const string MissingAttributeFormat = \"Class '{0}' is missing the [StateMachine(typeof(StateEnum), typeof(TriggerEnum))] attribute.\";\n    private const string MissingArgumentsFormat = \"The [StateMachine] attribute on class '{0}' requires at least two arguments (state type and trigger type).\";\n    private const string NotPartialFormat = \"Class '{0}' with [StateMachine] attribute must be declared as partial.\";\n\n    public IEnumerable<ValidationResult> Validate(MissingStateMachineAttributeValidationContext context)\n    {\n        if (!context.HasStateMachineAttribute)\n        {\n            string message = string.Format(MissingAttributeFormat, context.ClassName);\n            yield return ValidationResult.Fail(\n                RuleIdentifiers.MissingStateMachineAttribute,\n                message,\n                DefinedRules.MissingStateMachineAttribute.DefaultSeverity\n            );\n            yield break;\n        }\n\n        bool errorFound = false;\n\n        if (context.FsmAttributeConstructorArgCount < 2)\n        {\n            errorFound = true;\n            string message = string.Format(MissingArgumentsFormat, context.ClassName);\n            yield return ValidationResult.Fail(\n                RuleIdentifiers.MissingStateMachineAttribute,\n                message,\n                DefinedRules.MissingStateMachineAttribute.DefaultSeverity\n            );\n        }\n\n        if (!context.IsClassPartial)\n        {\n            errorFound = true;\n            string message = string.Format(NotPartialFormat, context.ClassName);\n            yield return ValidationResult.Fail(\n                RuleIdentifiers.MissingStateMachineAttribute,\n                message,\n                DefinedRules.MissingStateMachineAttribute.DefaultSeverity\n            );\n        }\n\n        // Additional scenario for FSM004: class has transition attributes but is missing [StateMachine].\n        // This is outside the scope of this rule with this context.\n\n        if (!errorFound)\n        {\n            yield return ValidationResult.Success();\n        }\n    }\n}\n",
            "Rules\\UnreachableStateRule.cs": "﻿\n\nusing System.Collections.Generic;\nusing System.Linq;\nusing Generator.Rules.Contexts;\nusing Generator.Rules.Definitions;\n\n\nnamespace Generator.Rules.Rules;\n\n// Implementacja IValidationRule<UnreachableStateContext>\npublic class UnreachableStateRule : IValidationRule<UnreachableStateContext>\n{\n    // Metoda Validate przyjmuje nowy kontekst i zwraca IEnumerable<ValidationResult>\n    public IEnumerable<ValidationResult> Validate(UnreachableStateContext context)\n    {\n        if (context.AllDefinedStateNames == null || !context.AllDefinedStateNames.Any())\n        {\n            // Jeśli nie ma zdefiniowanych stanów, nie ma czego sprawdzać.\n            // Można zwrócić sukces, bo nie znaleziono \"nieosiągalnych\" stanów.\n            yield return ValidationResult.Success();\n            yield break; // lub po prostu yield break; jeśli Success() ma być tylko dla \"aktywnego\" sukcesuFSM005 \n        }\n\n        var reachableStates = new HashSet<string>();\n        var queue = new Queue<string>();\n\n        // Determine initial state for traversal\n        string? effectiveInitialState = null; // Może być null\n        if (!string.IsNullOrEmpty(context.InitialState) && context.AllDefinedStateNames.Contains(context.InitialState))\n        {\n            effectiveInitialState = context.InitialState;\n        }\n        else if (context.AllDefinedStateNames.Any())\n        {\n            // Domyślnie pierwszy stan z listy, jeśli nie podano jawnie stanu początkowego lub jest on nieprawidłowy\n            effectiveInitialState = context.AllDefinedStateNames.First();\n        }\n\n        if (effectiveInitialState != null)\n        {\n            queue.Enqueue(effectiveInitialState);\n            reachableStates.Add(effectiveInitialState);\n        }\n        else\n        {\n            // Jeśli nie można ustalić stanu początkowego (np. brak zdefiniowanych stanów),\n            // wszystkie stany (jeśli jakiekolwiek były oczekiwane) można by uznać za nieosiągalne,\n            // ale praktyczniej jest nic nie sprawdzać lub zgłosić problem z konfiguracją.\n            // Na razie, jeśli nie ma stanu startowego, a są stany, to wszystkie są nieosiągalne z perspektywy braku startu.\n            // Jednak obecna logika poniżej obsłuży to poprawnie - żaden stan nie zostanie dodany do reachableStates.\n            // Jeśli lista AllDefinedStateNames nie jest pusta, poniższa pętla zgłosi je jako nieosiągalne.\n            // Można też rozważyć yield return ValidationResult.Success(); jeśli to jest stan \"nie dotyczy\".\n            // Dla uproszczenia - jeśli nie ma stanu startowego, dalsza logika poprawnie zidentyfikuje wszystkie jako nieosiągalne.\n        }\n\n        while (queue.Count > 0)\n        {\n            var currentState = queue.Dequeue();\n            foreach (var transition in context.AllTransitions.Where(t => t.FromState == currentState))\n            {\n                // Używamy transition.ToState, które jest string?\n                // Interesują nas tylko przejścia, które mają zdefiniowany stan docelowy.\n                if (transition.ToState != null)\n                {\n                    string toState = transition.ToState;\n                    if (context.AllDefinedStateNames.Contains(toState) && reachableStates.Add(toState))\n                    {\n                        queue.Enqueue(toState);\n                    }\n                }\n            }\n        }\n\n        bool foundUnreachable = false;\n        foreach (var stateName in context.AllDefinedStateNames)\n        {\n            if (!reachableStates.Contains(stateName))\n            {\n                foundUnreachable = true;\n                string message = string.Format(\n                    DefinedRules.UnreachableState.MessageFormat,\n                    stateName // {0}\n                );\n                yield return ValidationResult.Fail(\n                    RuleIdentifiers.UnreachableState,\n                    message,\n                    DefinedRules.UnreachableState.DefaultSeverity // Użycie domyślnej ważności\n                );\n            }\n        }\n\n        if (!foundUnreachable && (context.AllDefinedStateNames != null && context.AllDefinedStateNames.Any()))\n        {\n            // Jeśli przeszliśmy przez wszystkie stany i żaden nie był nieosiągalny\n            // (a były jakieś stany do sprawdzenia), zwracamy sukces.\n            yield return ValidationResult.Success();\n        }\n        else if (context.AllDefinedStateNames == null || !context.AllDefinedStateNames.Any())\n        {\n            // Jeśli nie było stanów do sprawdzenia na początku, już zwróciliśmy sukces.\n            // Można by to scalić, ale dla jasności zostawiam.\n        }\n    }\n}",
            "Generator.Rules.csproj": "﻿<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <TargetFramework>netstandard2.0</TargetFramework>\n\t  <LangVersion>latest</LangVersion>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Microsoft.CSharp\" Version=\"4.7.0\" />\n  </ItemGroup>\n\n</Project>\n"
        }
    }
]