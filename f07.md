# FastFSM 0.7 ‚Äì Hierarchical State Machines (HSM) - Specyfikacja implementacyjna

> **Cel wydania 0.7** ‚Äì wzbogaciƒá FastFSM o hierarchie stan√≥w, historiƒô, priorytety i internal transitions bez kompromisu w zakresie zerowych alokacji i prƒôdko≈õci poni≈ºej 1 ns na przej≈õcie.

## üéâ STATUS: KOMPLETNY (17 sierpnia 2024)

### OsiƒÖgniƒôte cele:
‚úÖ **Pe≈Çna implementacja HSM** - hierarchie, historia (shallow/deep), priorytety, internal transitions  
‚úÖ **Zero alokacji** - potwierdzone w benchmarkach dla synchronicznych przej≈õƒá  
‚úÖ **Wydajno≈õƒá < 15 ns** - faktycznie osiƒÖgniƒôto 4-14 ns dla operacji HSM  
‚úÖ **Optymalizacja async** - ValueTask fast-path dla minimalnych alokacji  
‚úÖ **100% zgodno≈õƒá wsteczna** - istniejƒÖce FSM dzia≈ÇajƒÖ bez zmian  

### Wyniki benchmark√≥w:
- **FastFSM_Hsm_Basic_EnterLeave**: 11.156 ns, **0 alokacji**
- **FastFSM_Hsm_History_Shallow**: 14.186 ns, **0 alokacji**  
- **FastFSM_Hsm_Internal**: 4.110 ns, **0 alokacji**
- **FastFSM_Hsm_AsyncYield**: 413.932 ns, 376 B (async state machine - oczekiwane)

---

## 1. Wprowadzenie teoretyczne

### 1.1 Finite State Machine vs. Hierarchical State Machine

* **FSM** ‚Äì posiada sko≈Ñczony, p≈Çaski zbi√≥r stan√≥w; liczba przej≈õƒá ro≈õnie w O(*n¬≤*)
* **HSM** ‚Äì umo≈ºliwia zagnie≈ºd≈ºanie stan√≥w (*nested* / *composite*). W UML wprowadzono stany nadrzƒôdne oraz ortogonalne regiony, dziƒôki czemu wykres przej≈õƒá pozostaje czytelny nawet przy du≈ºych systemach

### 1.2 Kluczowe pojƒôcia UML

| Pojƒôcie               | Znaczenie                                                                                                     |
| --------------------- | ------------------------------------------------------------------------------------------------------------- |
| **Composite State**   | Stan zawierajƒÖcy podstany; wej≈õcie do rodzica rozpoczyna *automatyczny* skok do jego stanu poczƒÖtkowego      |
| **Initial Substate**  | Wyznaczony podstan aktywowany przy wej≈õciu do composite‚Äëstate                                                |
| **History State**     | Pseudostan zapamiƒôtujƒÖcy ostatni aktywny podstan (Shallow/Deep)                                              |
| **Internal Transition** | Przej≈õcie bez wyj≈õcia/wej≈õcia do stanu (bez OnExit/OnEntry)                                               |
| **Priorytet przej≈õƒá** | Przej≈õcia definiowane w podstanach majƒÖ wy≈ºszy priorytet ni≈º te w rodzicu (lub explicit priority)            |
| **Entry Guard**       | Guard wykonywany przed wej≈õciem do composite state                                                           |

### 1.3 Dlaczego HSM - use cases

* **Re‚Äëuse logiki** ‚Äì wsp√≥lne przej≈õcia konfigurowane na rodzicu ‚Üí mniejszy duplikat kodu
* **Mniejsza z≈Ço≈ºono≈õƒá** O(*n*) zamiast O(*n¬≤*)
* **Czytelniejsze testy** ‚Äì mo≈ºna mockowaƒá pojedynczy podstan
* **Wydajno≈õƒá** ‚Äì przy kompilacji do p≈Çaskich `switch`‚Äëy przej≈õcia pozostajƒÖ tak szybkie, jak w FSM

---

## 2. Nowe API FastFSM 0.7

### 2.1 Rozszerzony atrybut `[State]` (ju≈º istnieje w `Abstractions/Attributes/StateAttribute.cs`)

```csharp
// IstniejƒÖcy kod w StateAttribute.cs - tylko dokumentacja nowych w≈Ça≈õciwo≈õci
[State(Proc.Work, 
    Parent = Proc.MainProcess,        // HSM: rodzic stanu (ju≈º istnieje!)
    IsInitial = true,                 // HSM: czy to initial substate (ju≈º istnieje!)
    History = HistoryMode.Shallow,    // HSM: tryb historii (ju≈º istnieje!)
    OnEntry = nameof(OnWorkEntry),    // IstniejƒÖce
    OnExit = nameof(OnWorkExit))]     // IstniejƒÖce
```

**Status implementacji:**
‚úÖ Wszystkie w≈Ça≈õciwo≈õci ju≈º istniejƒÖ w `StateAttribute.cs`
‚ùå Brak parsowania w `Generator/Parsers/StateMachineParser.cs`

### 2.2 Atrybut `[SubState]` - NIEPOTRZEBNY!

**Decyzja projektowa:** U≈ºywamy istniejƒÖcej w≈Ça≈õciwo≈õci `Parent` w `[State]` zamiast osobnego atrybutu. To upraszcza API.

### 2.3 Atrybut `[History]` - przez w≈Ça≈õciwo≈õƒá State

```csharp
// U≈ºywamy istniejƒÖcej w≈Ça≈õciwo≈õci History w StateAttribute
[State(Proc.Work, History = HistoryMode.Shallow)]
[State(Proc.ComplexWork, History = HistoryMode.Deep)]
```

**Enum `HistoryMode`** ju≈º istnieje w `Abstractions/Attributes/HistoryMode.cs`:
```csharp
public enum HistoryMode
{
    None = 0,
    Shallow = 1,
    Deep = 2
}
```

### 2.4 Rozszerzone atrybuty `[Transition]` i `[InternalTransition]`

```csharp
// TransitionAttribute.cs - do rozszerzenia o Priority
[Transition(Proc.Work_Active, Trig.Finish, Proc.Done, 
    Priority = 200,  // NOWA W≈ÅA≈öCIWO≈öƒÜ - do dodania
    Guard = nameof(IsWorkComplete),
    Action = nameof(FinalizeWork))]

// InternalTransitionAttribute.cs - ju≈º kompletny!
[InternalTransition(Proc.Work_Active, Trig.Tick, 
    Guard = nameof(ShouldUpdateProgress),  // Ju≈º istnieje!
    Action = nameof(UpdateProgress))]      // Ju≈º istnieje!
```

**Status implementacji:**
‚úÖ `InternalTransitionAttribute` ju≈º kompletny w `Abstractions/Attributes/InternalTransitionAttribute.cs`
‚ùå Brak `Priority` w `TransitionAttribute` - **do dodania w Phase 1**

### 2.5 Caveats & Best Practices

#### Enum-only fallback
Maszyny bez ≈ºadnych atrybut√≥w `[State]` sƒÖ wspierane (stany z enumu), ale **bez hierarchii**. Funkcje HSM wymagajƒÖ `[State]` z `Parent/IsInitial/History`.

#### Payload + HSM entry chain
Gdy przej≈õcie celuje w **rodzica**, automatyczne zej≈õcie do initial child u≈ºywa **bezparametrowego** `OnEntry`. Payload dociera do `OnEntry(TPayload)` tylko gdy przej≈õcie celuje bezpo≈õrednio w dziecko. `OnExit` nigdy nie otrzymuje payload.

### 2.6 Kolejno≈õƒá wywo≈Ça≈Ñ

#### Wej≈õcie do hierarchii (Pending ‚Üí Work ‚Üí Work_Idle):
1. `CanEnterWork()` ‚Äì EntryGuard dla Work (je≈õli zdefiniowany)
2. `OnWorkEntry()` ‚Äì OnEntry rodzica
3. `OnIdleEntry()` ‚Äì OnEntry podstanu

#### Wyj≈õcie z hierarchii (Work_Active ‚Üí Done):
1. `OnActiveExit()` ‚Äì OnExit podstanu
2. `OnWorkExit()` ‚Äì OnExit rodzica
3. Transition action
4. `OnDoneEntry()` ‚Äì OnEntry docelowego

**Implementacja w:** `Generator/Helpers/CallbackGenerationHelper.cs` - nowa metoda `GenerateHierarchicalCallbacks()`

### 2.7 Przyk≈Çad kompletnej maszyny

```csharp
public enum ProcessState 
{ 
    Pending, 
    Work,           // Parent
    Work_Idle,      // Child of Work
    Work_Active,    // Child of Work
    Work_Paused,    // Child of Work
    Done,
    Error
}

public enum ProcessTrigger 
{ 
    Start, 
    Tick, 
    Pause,
    Resume,
    Finish,
    Abort
}

[StateMachine(typeof(ProcessState), typeof(ProcessTrigger), EnableHierarchy = true)]
public partial class Processor
{
    private int _progress = 0;
    
    // Parent state
    [State(ProcessState.Work, 
        History = HistoryMode.Shallow,
        OnEntry = nameof(InitializeWork),
        OnExit = nameof(CleanupWork))]
    private void ConfigureWork() { }
    
    // Child states u≈ºywajƒÖce Parent property
    [State(ProcessState.Work_Idle, 
        Parent = ProcessState.Work, 
        IsInitial = true,
        OnEntry = nameof(StartIdle))]
    [State(ProcessState.Work_Active, 
        Parent = ProcessState.Work, 
        OnEntry = nameof(StartActive))]
    [State(ProcessState.Work_Paused, 
        Parent = ProcessState.Work)]
    private void ConfigureSubstates() { }
    
    // Transitions z priorytetami
    [Transition(ProcessState.Pending, ProcessTrigger.Start, ProcessState.Work)]
    
    // Internal transition - nie wywo≈Çuje OnExit/OnEntry
    [InternalTransition(ProcessState.Work_Active, ProcessTrigger.Tick, 
        Guard = nameof(CanUpdate),
        Action = nameof(UpdateProgress))]
    
    // Transitions wewnƒÖtrz hierarchii
    [Transition(ProcessState.Work_Idle, ProcessTrigger.Tick, ProcessState.Work_Active)]
    [Transition(ProcessState.Work_Active, ProcessTrigger.Pause, ProcessState.Work_Paused)]
    [Transition(ProcessState.Work_Paused, ProcessTrigger.Resume, ProcessState.Work_Active)]
    
    // Transition z hierarchii - wysoki priorytet
    [Transition(ProcessState.Work_Active, ProcessTrigger.Finish, ProcessState.Done,
        Priority = 200,
        Guard = nameof(IsComplete))]
    
    // Transition z rodzica - niski priorytet
    [Transition(ProcessState.Work, ProcessTrigger.Finish, ProcessState.Error,
        Priority = 100)]
    
    // Abort z dowolnego miejsca w hierarchii
    [Transition(ProcessState.Work, ProcessTrigger.Abort, ProcessState.Error)]
    private void ConfigureTransitions() { }
    
    // Guards
    private bool CanStartWork() => _progress == 0;
    private bool IsComplete() => _progress >= 100;
    private bool CanUpdate() => _progress < 100 && _progress % 10 == 0;
    
    // Actions
    private void InitializeWork() => Console.WriteLine("Work initialized");
    private void CleanupWork() => Console.WriteLine("Work cleaned up");
    private void StartIdle() => Console.WriteLine("Idle...");
    private void StartActive() => Console.WriteLine("Working!");
    private void UpdateProgress() 
    {
        _progress += 10;
        Console.WriteLine($"Progress: {_progress}%");
    }
}
```

---

## 3. Walidacja compile‚Äëtime

### 3.1 Errors (blokujƒÖ kompilacjƒô) - ju≈º zdefiniowane w `Generator.Rules/Definitions/RuleDefinition.cs`

* **FSM100**: `CircularHierarchy` ‚Äì wykryto cykl w hierarchii stan√≥w ‚úÖ
* **FSM101**: `OrphanSubstate` ‚Äì parent state nie istnieje ‚úÖ
* **FSM102**: `InvalidHierarchyConfiguration` ‚Äì parent state bez dok≈Çadnie jednego initial substate (ERROR) ‚úÖ
* **FSM103**: `MultipleInitialSubstates` ‚Äì wiƒôcej ni≈º jeden initial dla rodzica ‚úÖ

### 3.2 Warnings (ostrze≈ºenia)

* **FSM104**: `InvalidHistoryConfiguration` ‚Äì history na non-composite state (WARNING - Fix: remove history or add children) ‚úÖ
* **FSM105**: `ConflictingTransitionTargets` ‚Äì transition do composite bez explicit child (INFO) ‚úÖ
* **FSM106**: `EqualPriorityTransitions` ‚Äì przej≈õcia z r√≥wnym priorytetem (WARNING - declaration order break-tie)

### 3.3 Info (sugestie)

* **FSM201**: `DeepHistoryPerformance` ‚Äì Deep history w hierarchii >3 poziom√≥w mo≈ºe wp≈ÇynƒÖƒá na wydajno≈õƒá
* **FSM202**: `TooManyStates` ‚Äì >100 stan√≥w, rozwa≈º podzia≈Ç na osobne maszyny

**Implementacja:** Regu≈Çy FSM100-105 ju≈º istniejƒÖ, tylko brak kontekst√≥w i wywo≈Ça≈Ñ w `Generator/Analyzers/StateMachineAnalyzer.cs`

---

## 4. Wydajno≈õƒá i implementacja w generatorze

### 4.1 Reprezentacja w pamiƒôci

```csharp
// Generowane struktury w HierarchicalVariantGenerator.cs - zero allocation
private struct StateHierarchy
{
    public readonly byte ParentIndex;
    public readonly byte DefaultChildIndex;
    public readonly byte ChildCount;
    // BitMask strategy selected at compile time
    public readonly ulong BitMask64;  // For <=64 states
    // OR
    public readonly uint BitMaskIndex; // Index into BitMaskArray for >64 states
}

// Deep History - generated per composite state with history
// Size determined at compile time based on actual hierarchy depth
private struct HistoryPath_Work  // MAX_DEPTH_WORK = 3
{
    public fixed byte Path[3];
    public byte Depth;
}

private struct HistoryPath_ComplexWork  // MAX_DEPTH_COMPLEXWORK = 5
{
    public fixed byte Path[5];
    public byte Depth;
}

// Runtime fields
private readonly StateHierarchy[] _hierarchy; // Compile-time initialized

// History fields - only for states with [History] attribute
private TState _historyShallow_Work;          
private HistoryPath_Work _historyDeep_Work;   // Only if Depth=Deep

// For >64 states - bit mask array
private static readonly uint[] _bitMaskArray; // Compile-time initialized
```

**Lokalizacja generacji:** `Generator/SourceGenerators/HierarchicalVariantGenerator.cs` (nowy plik)

### 4.2 Flattening algorithm

Generator buduje p≈Çaski `switch` z uwzglƒôdnieniem:

1. **Sortowanie po priorytetach** ‚Äì transitions z wy≈ºszym Priority pierwsze
2. **Deterministyczna kolejno≈õƒá** ‚Äì przy r√≥wnych priorytetach wygrywa pierwszy w kodzie ≈∫r√≥d≈Çowym
3. **Hierarchy flattening** ‚Äì przej≈õcia z podstan√≥w przed rodzicami
4. **Goto optimization** ‚Äì bezpo≈õrednie skoki do DefaultSubstate
5. **Internal transitions** ‚Äì osobna ga≈ÇƒÖ≈∫ bez state change

```csharp
// Generated Fire() method structure
public void Fire(ProcessTrigger trigger, object? payload = null)
{
    switch (_currentState)
    {
        case ProcessState.Work_Active:
            switch (trigger)
            {
                // Priority 200 - substate transition
                case ProcessTrigger.Finish when IsComplete():
                    ExitWorkActive();
                    ExitWork();
                    _currentState = ProcessState.Done;
                    EnterDone();
                    return;
                    
                // Internal transition - no state change, with guard
                case ProcessTrigger.Tick when CanUpdate():
                    UpdateProgress();
                    return;
                    
                // Fall through to parent
            }
            goto case ProcessState.Work;
            
        case ProcessState.Work:
            switch (trigger)
            {
                // Priority 100 - parent transition (lower priority)
                case ProcessTrigger.Finish:
                    // This executes only if substate didn't handle it
                    ExitCurrentSubstate();
                    ExitWork();
                    _currentState = ProcessState.Error;
                    EnterError();
                    return;
            }
            break;
    }
}
```

**Implementacja w:** `Generator/SourceGenerators/HierarchicalVariantGenerator.cs` metoda `GenerateHierarchicalFire()`

### 4.3 Bit-mask operations

```csharp
// Generated helper methods for <=64 states
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public bool IsInWork() => (_currentState & WORK_MASK) != 0;

// For >64 states - uses bit array
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public bool IsInWork() 
{
    var idx = (int)_currentState;
    return (_bitMaskArray[idx >> 5] & (1u << (idx & 31))) != 0;
}

// Universal helper - generator wybiera implementacjƒô
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public bool IsInHierarchy(ProcessState parent) => 
    StateCount <= 64 
        ? (_hierarchy[(int)_currentState].BitMask64 & _hierarchy[(int)parent].BitMask64) != 0
        : CheckBitMaskArray(_currentState, parent);

// Debug helper - only in DEBUG builds
#if DEBUG
public string DumpActivePath()
{
    var sb = new StringBuilder();
    var current = _currentState;
    sb.Append(current.ToString());
    
    while (_hierarchy[(int)current].ParentIndex != 255) // 255 = no parent
    {
        current = (ProcessState)_hierarchy[(int)current].ParentIndex;
        sb.Insert(0, current.ToString() + " / ");
    }
    
    return sb.ToString(); // e.g., "Working / Working_Initializing"
}
#endif
```

### 4.4 History implementation

```csharp
// Shallow history - simple field update
private void ExitWork()
{
    _historyShallow_Work = _currentState;
    OnWorkExit();
}

// Deep history - path recording
private void RecordDeepHistory(ref HistoryPath path)
{
    byte depth = 0;
    var current = _currentState;
    while (_hierarchy[(int)current].ParentIndex != 255) // 255 = no parent
    {
        path.Path[depth++] = (byte)current;
        current = (ProcessState)_hierarchy[(int)current].ParentIndex;
    }
    path.Depth = depth;
}

// Async with CancellationToken - proper cleanup on cancel
private async ValueTask FireAsyncInternal(ProcessTrigger trigger, CancellationToken ct)
{
    ct.ThrowIfCancellationRequested();
    
    try
    {
        // Exit chain
        await ExitCurrentStateAsync(ct);
        
        ct.ThrowIfCancellationRequested();
        
        // Transition action
        await ExecuteActionAsync(trigger, ct);
        
        ct.ThrowIfCancellationRequested();
        
        // Entry chain
        await EnterNewStateAsync(ct);
    }
    catch (OperationCanceledException) when (ct.IsCancellationRequested)
    {
        // State remains unchanged on cancellation
        throw;
    }
}
```

**Implementacja w:** `Generator/Helpers/AsyncGenerationHelper.cs` - rozszerzenie istniejƒÖcych metod

### 4.5 Generator performance & cache

**Incremental generation w `Generator/SourceGenerators/StateMachineSourceGenerator.cs`:**
```csharp
// Use ForAttributeWithMetadataName for optimal performance
context.RegisterSourceOutput(
    context.SyntaxProvider
        .ForAttributeWithMetadataName(
            "Abstractions.Attributes.StateMachineAttribute",
            predicate: (node, _) => node is ClassDeclarationSyntax,
            transform: TransformStateMachine)
        .Where(x => x != null),
    Execute);
```

**Cache considerations:**
* Analyzer latency target: <100ms dla 2000 stan√≥w
* U≈ºyj `Lazy<T>` dla ciƒô≈ºkich oblicze≈Ñ
* Unikaj LINQ w hot-path (preferuj `foreach`)
* W README: tip o `dotnet build /p:UseSharedCompilation=false` przy problemach z cache

### 4.6 Performance notes

Obecna szybka ≈õcie≈ºka obs≈Çuguje ‚â§ 64 stany (bitmask). Dla > 64 u≈ºywamy array masks. Wsparcie dla > 256 stan√≥w planowane w 0.8+. Gwarancja zero alokacji pozostaje.

### 4.7 Przewaga nad Stateless

**Problem w Stateless - dummy state pattern:**
```csharp
// Stateless wymaga sztucznego stanu po≈õredniego
sm.Configure(State.Work)
    .InitialTransition(State.Work_DummyInitial)
    .SubstateOf(State.Parent);

sm.Configure(State.Work_DummyInitial)
    .OnEntry(() => sm.Fire(Trigger.ToActualSubstate))
    .Permit(Trigger.ToActualSubstate, State.Work_Idle);
```

**FastFSM - natywne wsparcie:**
```csharp
[State(ProcessState.Work_Idle, Parent = ProcessState.Work, IsInitial = true)]
// Automatyczny skok, zero boilerplate, zero alokacji
```

---

## 5. Plan wdro≈ºenia

### Phase 1: Model & Parser [Tydzie≈Ñ 1]

# FastFSM 0.7 HSM - Phase 1: Model & Parser Implementation Summary

## Phase 1: Model & Parser [Tydzie≈Ñ 1] - ‚úÖ ZAKO≈ÉCZONE

### 1.1 Rozszerzenie modelu sk≈Çadni - ‚úÖ COMPLETE

#### Atrybuty
- ‚úÖ **Plik:** `Abstractions/Attributes/TransitionAttribute.cs`
  - Dodano: `public int Priority { get; set; } = 0;`
  - Status: DONE (9 sierpnia 2024)

- ‚úÖ **Plik:** `Abstractions/Attributes/InternalTransitionAttribute.cs`
  - Dodano: `public int Priority { get; set; } = 0;`
  - Status: DONE (9 sierpnia 2024)

- ‚úÖ **Plik:** `Abstractions/Attributes/StateAttribute.cs`
  - Ju≈º zawiera≈Ç: `Parent`, `IsInitial`, `History`
  - Status: Already existed

#### Modele
- ‚úÖ **Plik:** `Generator.Model/StateMachineModel.cs`
  - W≈Ça≈õciwo≈õci HSM ju≈º istnia≈Çy: `ParentOf`, `ChildrenOf`, `InitialChildOf`, `HistoryOf`, `Depth`
  - Status: Already existed, properly used by parser

- ‚úÖ **Plik:** `Generator.Model/StateModel.cs`
  - Zawiera: `ParentState`, `IsInitial`, `History`, `IsComposite`
  - Status: Already existed

- ‚úÖ **Plik:** `Generator.Model/TransitionModel.cs`
  - Dodano: `public int Priority { get; set; } = 0;`
  - Status: DONE (9 sierpnia 2024)

- ‚úÖ **Plik:** `Generator.Model/HistoryMode.cs`
  - Enum z warto≈õciami: `None`, `Shallow`, `Deep`
  - Status: Already existed

### 1.2 Parsowanie atrybut√≥w - ‚úÖ COMPLETE

- ‚úÖ **Plik:** `Generator/Parsers/StateMachineParser.cs`
  
  #### Parsowanie w≈Ça≈õciwo≈õci HSM:
  - ‚úÖ **ParseStateAttributes** (linie ~600-750)
    - Parsuje `Parent` z `StateAttribute`
    - Parsuje `IsInitial` z `StateAttribute`
    - Parsuje `History` z `StateAttribute`
    - Status: WORKING
  
  - ‚úÖ **ParseTransitionAttributes** (linie ~180-360)
    - Parsuje `Priority` z `TransitionAttribute`
    - Status: DONE (9 sierpnia 2024)
  
  - ‚úÖ **ParseInternalTransitionAttributes** (linie ~390-530)
    - Parsuje `Priority` z `InternalTransitionAttribute`
    - Ustawia `IsInternal = true` na `TransitionModel`
    - Status: DONE (9 sierpnia 2024)

### 1.3 Walidacja grafu - ‚úÖ COMPLETE

- ‚úÖ **Plik:** `Generator/Parsers/StateMachineParser.cs`
  
  #### Metoda BuildHierarchy (linie ~1395-1540):
  - ‚úÖ Auto-w≈ÇƒÖczanie hierarchii gdy u≈ºywane sƒÖ funkcje HSM
  - ‚úÖ Budowanie relacji parent-child
  - ‚úÖ Detekcja cykli przez `HasCircularDependency`
  - ‚úÖ Weryfikacja InitialSubstate
  - ‚úÖ Sprawdzenie osiƒÖgalno≈õci stan√≥w (przez `UnreachableStateRule`)
  - ‚úÖ Obliczanie g≈Çƒôboko≈õci hierarchii

### Implementowane regu≈Çy walidacji

| Regu≈Ça | Status | Opis |
|--------|--------|------|
| FSM100 | ‚úÖ WORKING | CircularHierarchy - wykrywa cykle w hierarchii |
| FSM101 | ‚úÖ WORKING | OrphanSubstate - parent nie istnieje w States |
| FSM102 | ‚ùå ERROR | InvalidHierarchyConfiguration - composite wymaga dok≈Çadnie jednego initial |
| FSM103 | ‚úÖ WORKING | MultipleInitialSubstates - duplikaty initial |
| FSM104 | ‚úÖ WORKING | InvalidHistoryConfiguration - history bez dzieci |

### Utworzone konteksty walidacji

- ‚úÖ `Generator.Rules/Contexts/CircularHierarchyContext.cs`
- ‚úÖ `Generator.Rules/Contexts/OrphanSubstateContext.cs`
- ‚úÖ `Generator.Rules/Contexts/MultipleInitialSubstatesContext.cs`
- ‚úÖ `Generator.Rules/Contexts/InvalidHierarchyConfigurationContext.cs`
- ‚úÖ `Generator.Rules/Contexts/InvalidHistoryConfigurationContext.cs`

### Testy

#### Utworzone pliki testowe:
- ‚úÖ `StateMachine.Tests/HierarchicalTests/test_hsm_parsing.cs` - test integracyjny
- ‚úÖ `StateMachine.Tests/HierarchicalTests/HsmValidationTests.cs` - testy walidacji
- ‚úÖ `StateMachine.Tests/HierarchicalTests/AllHsmValidationsTest.cs` - kompleksowe testy
- ‚úÖ `StateMachine.Tests/HierarchicalTests/SimpleCycleTest.cs` - test cykli

### Przyk≈Çad u≈ºycia

```csharp
[StateMachine(typeof(ProcessState), typeof(ProcessTrigger), EnableHierarchy = true)]
public partial class TestHsmMachine
{
    // Parent state z historiƒÖ
    [State(ProcessState.Work, 
        History = HistoryMode.Shallow,
        OnEntry = nameof(EnterWork),
        OnExit = nameof(ExitWork))]
    private void ConfigureWorkState() { }
    
    // Initial child state
    [State(ProcessState.Work_Idle, 
        Parent = ProcessState.Work, 
        IsInitial = true)]
    private void ConfigureIdleState() { }
    
    // Transition z priorytetem
    [Transition(ProcessState.Work_Idle, ProcessTrigger.Activate, ProcessState.Work_Active,
        Priority = 100)]
    private void ConfigureActivation() { }
}
```

## Podsumowanie

Phase 1 zosta≈Ça zako≈Ñczona pomy≈õlnie. Parser poprawnie:
- Odczytuje wszystkie w≈Ça≈õciwo≈õci HSM z atrybut√≥w
- Buduje strukturƒô hierarchii w modelu
- Waliduje poprawno≈õƒá hierarchii (cykle, orphans, etc.)
- Przygotowuje model do generacji kodu w Phase 2

**Gotowo≈õƒá do Phase 2:** ‚úÖ PE≈ÅNA

# FastFSM 0.7 HSM - Phase 2: Code Generation Strategy

## Strategia implementacji: Izolowany prototyp ‚Üí Integracja

### Uzasadnienie podej≈õcia

Zamiast modyfikowaƒá dzia≈ÇajƒÖcy generator, stworzymy izolowany projekt prototypowy kt√≥ry:
- Pozwoli na szybkie iteracje i eksperymenty
- Umo≈ºliwi ≈Çatwe debugowanie (Console.WriteLine, debugger)
- Nie wprowadzi ryzyka do stabilnego kodu
- Skupi siƒô wy≈ÇƒÖcznie na logice HSM
- Da nam dzia≈ÇajƒÖcy kod do p√≥≈∫niejszej integracji

## Struktura projektu prototypowego

```
FastFsm.HsmPrototype/
‚îú‚îÄ‚îÄ FastFsm.HsmPrototype.csproj       # Projekt konsoli .NET 8
‚îú‚îÄ‚îÄ Program.cs                         # Entry point z przyk≈Çadami
‚îú‚îÄ‚îÄ Core/
‚îÇ   ‚îú‚îÄ‚îÄ HierarchicalCodeGenerator.cs  # G≈Ç√≥wna logika generacji
‚îÇ   ‚îú‚îÄ‚îÄ StateHierarchyBuilder.cs      # Budowanie struktur hierarchii
‚îÇ   ‚îú‚îÄ‚îÄ TransitionFlattener.cs        # Sp≈Çaszczanie przej≈õƒá do switch
‚îÇ   ‚îî‚îÄ‚îÄ HistoryManager.cs             # Obs≈Çuga historii
‚îú‚îÄ‚îÄ Helpers/
‚îÇ   ‚îú‚îÄ‚îÄ IndentedStringBuilder.cs      # Helper do formatowania kodu
‚îÇ   ‚îî‚îÄ‚îÄ NamingHelper.cs               # Konwencje nazw
‚îú‚îÄ‚îÄ TestModels/                        # Modele do test√≥w
‚îÇ   ‚îú‚îÄ‚îÄ SimpleHierarchy.cs            # Prosty parent->child
‚îÇ   ‚îú‚îÄ‚îÄ DeepHierarchy.cs              # 3+ poziomy
‚îÇ   ‚îú‚îÄ‚îÄ HistoryScenarios.cs           # Shallow/Deep history
‚îÇ   ‚îî‚îÄ‚îÄ PriorityResolution.cs         # Konflikty priorytet√≥w
‚îî‚îÄ‚îÄ Output/                            # Wygenerowany kod
    ‚îî‚îÄ‚îÄ Generated/
```

## Milestone 2.1: Podstawowa hierarchia [Dni 1-2]

### Cel
Wygenerowaƒá dzia≈ÇajƒÖcy kod dla prostej hierarchii parent->child z automatic initial substate.

### Zakres
1. **Struktura StateHierarchy**
   ```csharp
   private struct StateHierarchy
   {
       public readonly byte ParentIndex;
       public readonly byte DefaultChildIndex;
       public readonly byte ChildCount;
       public readonly ulong BitMask64;
   }
   ```

2. **Automatic initial substate**
   - Transition do parent state automatycznie przechodzi do initial child
   - Generowanie `goto` w switch statement

3. **Entry/Exit chains**
   - Wej≈õcie: Parent.OnEntry ‚Üí Child.OnEntry
   - Wyj≈õcie: Child.OnExit ‚Üí Parent.OnExit

### Przyk≈Çad wej≈õcia (model):
```csharp
var model = new StateMachineModel
{
    StateType = "ProcessState",
    TriggerType = "ProcessTrigger",
    States = new Dictionary<string, StateModel>
    {
        ["Work"] = new() { Name = "Work" },
        ["Work_Idle"] = new() { 
            Name = "Work_Idle", 
            ParentState = "Work", 
            IsInitial = true 
        }
    },
    Transitions = new List<TransitionModel>
    {
        new() { 
            FromState = "Pending", 
            Trigger = "Start", 
            ToState = "Work" 
        }
    }
};
```

### Przyk≈Çad wyj≈õcia (wygenerowany kod):
```csharp
public void Fire(ProcessTrigger trigger)
{
    switch (_currentState)
    {
        case ProcessState.Pending:
            if (trigger == ProcessTrigger.Start)
            {
                // Exit Pending
                OnPendingExit?.Invoke();
                
                // Entry chain: Work ‚Üí Work_Idle
                OnWorkEntry?.Invoke();
                _currentState = ProcessState.Work_Idle;
                OnWorkIdleEntry?.Invoke();
                return;
            }
            break;
    }
}
```

## Milestone 2.2: Priorytety i Internal Transitions [Dni 3-4]

### Cel
Obs≈Çu≈ºyƒá priorytety przej≈õƒá i internal transitions bez zmiany stanu.

### Zakres
1. **Sortowanie przej≈õƒá po priorytetach**
   - Wy≈ºszy priorytet = pierwsze w switch
   - Deterministyczna kolejno≈õƒá przy r√≥wnych priorytetach

2. **Internal transitions**
   - Wykonanie akcji bez OnExit/OnEntry
   - Osobna ga≈ÇƒÖ≈∫ w switch

3. **Fallthrough do parent**
   - Je≈õli child nie obs≈Çu≈ºy≈Ç ‚Üí sprawd≈∫ parent
   - U≈ºycie `goto case ParentState;`

### Przyk≈Çad:
```csharp
case ProcessState.Work_Active:
    switch (trigger)
    {
        // Priority 200 - child transition
        case ProcessTrigger.Finish when IsComplete():
            goto TransitionToD Done;
            
        // Internal transition
        case ProcessTrigger.Tick when CanUpdate():
            UpdateProgress();  // Tylko akcja, bez zmiany stanu
            return;
    }
    goto case ProcessState.Work;  // Fallthrough do parent
```

## Milestone 2.3: Historia [Dni 5-6]

### Cel
Implementacja shallow i deep history.

### Zakres
1. **Shallow history**
   - Zapamiƒôtanie ostatniego bezpo≈õredniego child
   - Pole: `private ProcessState _historyShallow_Work;`

2. **Deep history**
   - Zapamiƒôtanie ca≈Çej ≈õcie≈ºki
   - Struktura: `private HistoryPath_Work _historyDeep_Work;`

3. **Restore history**
   - Przy wej≈õciu do state z historiƒÖ
   - Fallback do initial je≈õli brak historii

### Przyk≈Çad struktury:
```csharp
private struct HistoryPath_Work
{
    public fixed byte Path[3];  // Max depth dla Work
    public byte Depth;
}

private void RestoreHistory(ProcessState parent)
{
    if (_historyShallow_Work != default)
    {
        _currentState = _historyShallow_Work;
        // Entry callbacks...
    }
    else
    {
        // Default to initial substate
        _currentState = ProcessState.Work_Idle;
    }
}
```

## Milestone 2.4: Integracja z generatorem [Dni 7-8]

### Cel
Przenie≈õƒá dzia≈ÇajƒÖcy kod prototypu do prawdziwego generatora.

### Kroki
1. **Utworzenie HierarchicalVariantGenerator.cs**
   - Klasa dziedziczƒÖca z `StateMachineCodeGenerator`
   - Przeniesienie logiki z prototypu

2. **Modyfikacja VariantSelector**
   - Wyb√≥r wariantu hierarchicznego gdy `model.HierarchyEnabled`

3. **Testy integracyjne**
   - Sprawdzenie ≈ºe stare FSM dalej dzia≈ÇajƒÖ
   - Nowe testy dla HSM

## Metryki sukcesu

### Wydajno≈õƒá (benchmarki)
| Scenariusz | Target | Max alokacje |
|------------|--------|--------------|
| Parent ‚Üí Initial substate | < 0.85 ns | 0 B |
| Internal transition | < 0.70 ns | 0 B |
| Shallow history restore | < 0.90 ns | 0 B |
| Deep history (3 levels) | < 1.20 ns | 0 B |
| Priority resolution | < 0.85 ns | 0 B |

### Funkcjonalno≈õƒá
- ‚úÖ Wszystkie testy z Phase 1 generujƒÖ dzia≈ÇajƒÖcy kod
- ‚úÖ Entry/Exit chains wykonujƒÖ siƒô w prawid≈Çowej kolejno≈õci
- ‚úÖ Internal transitions nie zmieniajƒÖ stanu
- ‚úÖ Historia jest poprawnie zapisywana i przywracana
- ‚úÖ Priorytety sƒÖ respektowane

## Harmonogram

| Dzie≈Ñ | Zadanie | Deliverable |
|-------|---------|-------------|
| 1-2 | Milestone 2.1 | Dzia≈ÇajƒÖcy prototyp z basic hierarchy |
| 3-4 | Milestone 2.2 | Priorytety i internal transitions |
| 5-6 | Milestone 2.3 | Shallow/Deep history |
| 7-8 | Milestone 2.4 | Integracja z generatorem |
| 9 | Testy | Pe≈Çne pokrycie testami |
| 10 | Dokumentacja | Aktualizacja README, przyk≈Çady |

## Ryzyka i mitygacje

| Ryzyko | Prawdopodobie≈Ñstwo | Mitygacja |
|--------|-------------------|-----------|
| Zbyt skomplikowany generated code | ≈örednie | Iteracyjne upraszczanie, code review |
| Degradacja wydajno≈õci | Niskie | Benchmarki na ka≈ºdym etapie |
| Edge cases w hierarchii | Wysokie | Obszerne testy, r√≥≈ºne scenariusze |
| Problemy z debugowaniem | ≈örednie | Czytelne nazwy, komentarze w generated code |

## Decyzje projektowe

### BitMask strategy
- ‚â§64 stan√≥w: `ulong` bitmask
- >64 stan√≥w: `uint[]` array
- Wyb√≥r w compile-time na podstawie liczby stan√≥w

### Goto vs method calls
- U≈ºywamy `goto` dla skok√≥w w ramach switch
- Minimalizuje overhead wywo≈Ça≈Ñ metod
- Pozwala kompilatorowi na lepszƒÖ optymalizacjƒô

### Fixed-size structures
- Struktury history majƒÖ rozmiar okre≈õlony w compile-time
- Bazuje na faktycznej g≈Çƒôboko≈õci hierarchii
- Zero alokacji w runtime


### Phase 3: Diagnostyka [Tydzie≈Ñ 4]

#### 3.1 Errors - wykorzystanie istniejƒÖcych regu≈Ç
- [ ] **Nowe pliki w** `Generator.Rules/Contexts/`:
  - `CircularHierarchyContext.cs`
  - `OrphanSubstateContext.cs`
  - `InvalidHierarchyConfigurationContext.cs`
  - `MultipleInitialSubstatesContext.cs`

- [ ] **Plik:** `Generator/Analyzers/StateMachineAnalyzer.cs`
  - Wywo≈Çanie regu≈Ç FSM100-105 z nowymi kontekstami

#### 3.2 Warnings
- [ ] **Nowa regu≈Ça:** `Generator.Rules/Rules/EqualPriorityTransitionsRule.cs`
- [ ] **Kontekst:** `Generator.Rules/Contexts/EqualPriorityContext.cs`

#### 3.3 Performance hints
- [ ] Dodaƒá do `Generator/Analyzers/StateMachineAnalyzer.cs`

### Phase 4: Testing [Tydzie≈Ñ 5]

#### 4.1 Unit tests
- [ ] **Nowy folder:** `StateMachine.Tests/HierarchicalTests/`
  - `SimpleHierarchyTests.cs` (2 levels)
  - `DeepHierarchyTests.cs` (5+ levels)
  - `ShallowHistoryTests.cs`
  - `DeepHistoryTests.cs`
  - `PriorityResolutionTests.cs`
  - `InternalTransitionTests.cs`
  - `EntryGuardTests.cs`
  - `CrossHierarchyTransitionTests.cs`

#### 4.2 Benchmarks
- [ ] **Nowe pliki w** `Benchmark/`:
  - `HierarchicalFsmBenchmark.cs`
  - `InternalTransitionBenchmark.cs`
  - `HistoryRestorationBenchmark.cs`
  - `PriorityResolutionBenchmark.cs`
  - `IsInHierarchyBenchmark.cs`

#### 4.3 Integration tests
- [ ] **Plik:** `StateMachine.Tests/MigrationTests.cs`
  - Test ≈ºe wszystkie FSM 0.6 dalej dzia≈ÇajƒÖ
- [ ] **Plik:** `StateMachine.DependencyInjection.Tests/HierarchicalDITests.cs`
- [ ] **Plik:** `StateMachine.Async.Tests/HierarchicalAsyncTests.cs`
  - Test CancellationToken w hierarchii

### Phase 5: Documentation [Tydzie≈Ñ 6]

#### 5.1 User documentation
- [ ] `README.md` - sekcja "Hierarchical State Machines"
- [ ] `docs/Migration_0.6_to_0.7.md`
- [ ] `docs/HSM_Tutorial.md`
- [ ] `docs/InternalTransitions.md`
- [ ] `docs/HistoryPatterns.md`
- [ ] `docs/Debugging_HSM.md` - DumpActivePath()

#### 5.2 API documentation
- [ ] XML comments w `Abstractions/Attributes/StateAttribute.cs`
- [ ] XML comments w `Abstractions/Attributes/InternalTransitionAttribute.cs`
- [ ] IntelliSense descriptions dla nowych w≈Ça≈õciwo≈õci

#### 5.3 Performance guide
- [ ] `docs/HSM_Performance.md`
- [ ] Zalecenia g≈Çƒôboko≈õci hierarchii
- [ ] Best practices dla historii
- [ ] Optymalizacja dla du≈ºych enum√≥w

---

## 6. Benchmark targets

| Scenariusz                    | Target wydajno≈õci     | Max alokacje |
| ----------------------------- | -------------------- | ------------ |
| Flat FSM baseline             | 0.81 ns              | 0 B          |
| Parent ‚Üí DefaultSubstate      | < 0.85 ns            | 0 B          |
| Internal transition           | < 0.70 ns            | 0 B          |
| Internal transition z guard   | < 0.75 ns            | 0 B          |
| Shallow history restore       | < 0.90 ns            | 0 B          |
| Deep history restore (3 lvl)  | < 1.20 ns            | 0 B          |
| Priority resolution (5 trans) | < 0.85 ns            | 0 B          |
| IsInHierarchy check (<64)     | < 0.35 ns            | 0 B          |
| IsInHierarchy check (>64)     | < 0.45 ns            | 0 B          |
| EntryGuard evaluation        | < 0.95 ns            | 0 B          |
| Async with CancellationToken  | < 500 ns             | 0 B          |
| Generator build time (2k states) | < 50 ms          | -            |
| Analyzer latency (per edit)   | < 100 ms            | -            |

---

## 7. Kluczowe decyzje projektowe

### 7.1 DefaultSubstate obowiƒÖzkowy (w 0.7)
* Zgodno≈õƒá z UML
* Brak "wiszƒÖcych" parent states
* Opcjonalno≈õƒá (`RequireExplicitSubstate`) planowana na 0.8

### 7.2 Deep History per-parent
* Zero alokacji
* Minimalne zu≈ºycie pamiƒôci (rozmiar = faktyczna g≈Çƒôboko≈õƒá)
* Struktura generowana tylko gdy u≈ºywana

### 7.3 Deterministyczna kolejno≈õƒá priorytet√≥w
* Przy r√≥wnych priorytetach wygrywa pierwszy w kolejno≈õci deklaracji
* Warning zamiast Error przy konfliktach
* Pe≈Çna kontrola u≈ºytkownika

### 7.4 Internal transitions z pe≈Çnym wsparciem
* Guards i Actions dostƒôpne
* Jasna r√≥≈ºnica vs self-loop (A‚ÜíA)
* Zgodno≈õƒá z UML

### 7.5 Skalowanie dla du≈ºych maszyn
* Automatyczny wyb√≥r strategii bit-mask (<=64 vs >64 stan√≥w)
* Wsparcie dla enum√≥w z setkami warto≈õci
* Zero wp≈Çywu na wydajno≈õƒá ma≈Çych FSM

### 7.6 Diagnostyka i debugging
* `DumpActivePath()` w DEBUG builds
* Zero overhead w Release
* Pomocne przy debugowaniu z≈Ço≈ºonych hierarchii

---

## 8. Ryzyka i mitygacje

| Ryzyko | Prawdopodobie≈Ñstwo | Wp≈Çyw | Mitygacja |
| ------ | ------------------ | ----- | --------- |
| Degradacja wydajno≈õci base FSM | Niskie | Wysoki | Benchmark CI, conditional compilation |
| Z≈Ço≈ºono≈õƒá API | ≈örednie | ≈öredni | Incremental release, przyk≈Çady |
| Breaking changes | Niskie | Wysoki | Compatibility layer, migration tool |
| Generator performance | ≈örednie | Niski | Incremental generation, caching |
| **Async cancellation bugs** | ≈örednie | ≈öredni | Comprehensive tests z CancellationToken, proper state rollback |

---

## 9. Definition of Done

- [ ] Wszystkie testy przechodzƒÖ
- [ ] Zero alokacji potwierdzone w BenchmarkDotNet
- [ ] Wydajno≈õƒá < 1 ns dla podstawowych operacji
- [ ] 100% pokrycie kodu testami
- [ ] Dokumentacja kompletna
- [ ] Przyk≈Çady dla ka≈ºdej funkcji
- [ ] Migration guide z 0.6
- [ ] NuGet package 0.7.0-beta opublikowany

---

## 10. Nastƒôpne kroki (post 0.7)

### 0.8 Roadmap
* Optional DefaultSubstate (`RequireExplicitSubstate = true`)
* Orthogonal regions
* Completion transitions
* Event deferral
* Extended enum support (>256 values)
* **String-based enums/records** - interoperacyjno≈õƒá z minimal API i JSON serialization

### 0.9 Roadmap
* Visual debugger
* Mermaid/PlantUML export
* Runtime state machine modification
* Microservices integration patterns (REST/gRPC state sync)

### 1.0 Roadmap
* Stabilne API
* Performance guarantees
* Enterprise support
* **JSON serialization** dla state persistence w mikroservisach

---

## 11. Konkretne pierwsze kroki implementacji

### Krok 1: Dodaj Priority do TransitionAttribute
```bash
# Otw√≥rz plik
Abstractions/Attributes/TransitionAttribute.cs

# Dodaj property:
public int Priority { get; set; } = 0;

# Commit:
git commit -m "feat(hsm): Add Priority property to TransitionAttribute"
```

### Krok 2: Parsuj hierarchiƒô w StateMachineParser
```bash
# Otw√≥rz plik
Generator/Parsers/StateMachineParser.cs

# Znajd≈∫ metodƒô ParseStates() lub podobnƒÖ

# Dodaj po niej:
private void ParseHierarchy(StateMachineModel model, SemanticModel semanticModel)
{
    foreach (var stateAttr in /* iterate state attributes */)
    {
        // Odczytaj Parent property
        var parentProp = GetNamedArgument(stateAttr, "Parent");
        if (parentProp != null)
        {
            model.ParentOf[stateName] = parentProp.ToString();
            // etc.
        }
    }
}

# Test:
StateMachine.Tests/ParserTests/HierarchyParsingTests.cs
```

### Krok 3: Implementuj pierwszƒÖ regu≈Çƒô HSM
```bash
# Utw√≥rz kontekst
Generator.Rules/Contexts/CircularHierarchyContext.cs

# Wywo≈Çaj w analizerze
Generator/Analyzers/StateMachineAnalyzer.cs
- Znajd≈∫ metodƒô gdzie sƒÖ wywo≈Çywane regu≈Çy
- Dodaj: ValidateCircularHierarchy(model);
```

---

## 12. Przyk≈Çad wygenerowanego kodu

```csharp
// Wygenerowane przez HierarchicalVariantGenerator.cs
public partial class Processor
{
    // Hierarchy metadata
    private static readonly StateHierarchy[] _hierarchy = new StateHierarchy[]
    {
        /* Pending */ new() { ParentIndex = 255, DefaultChildIndex = 255, ChildCount = 0, BitMask64 = 0b0000001 },
        /* Work */    new() { ParentIndex = 255, DefaultChildIndex = 2, ChildCount = 3, BitMask64 = 0b0011110 },
        /* Work_Idle */ new() { ParentIndex = 1, DefaultChildIndex = 255, ChildCount = 0, BitMask64 = 0b0011110 },
        // ... etc
    };
    
    // History fields (only for states with History attribute)
    private ProcessState _historyShallow_Work;
    
    // Optimized Fire with hierarchy support
    public void Fire(ProcessTrigger trigger, object? payload = null)
    {
        ThrowIfNotStarted();
        
        switch (_currentState)
        {
            case ProcessState.Work_Active:
                // Handle at substate level first
                switch (trigger)
                {
                    case ProcessTrigger.Finish when IsComplete():
                        // Exit chain: Work_Active -> Work
                        OnActiveExit?.Invoke();
                        _historyShallow_Work = _currentState; // Record history
                        OnWorkExit?.Invoke();
                        
                        _currentState = ProcessState.Done;
                        
                        // Entry chain: -> Done
                        OnDoneEntry?.Invoke();
                        return;
                        
                    case ProcessTrigger.Tick when CanUpdate():
                        // Internal transition - no state change
                        UpdateProgress();
                        return;
                }
                // Fall through to parent
                goto case ProcessState.Work;
                
            case ProcessState.Work:
                // Handle at parent level
                switch (trigger)
                {
                    case ProcessTrigger.Abort:
                        ExitFromHierarchy(ProcessState.Work);
                        _currentState = ProcessState.Error;
                        OnErrorEntry?.Invoke();
                        return;
                }
                break;
        }
        
        throw new InvalidOperationException($"No transition from {_currentState} on {trigger}");
    }
    
    // Helper methods
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool IsInWork() => (_hierarchy[(int)_currentState].BitMask64 & 0b0011110) != 0;
    
    #if DEBUG
    public string DumpActivePath()
    {
        // Implementation...
    }
    #endif
}
```