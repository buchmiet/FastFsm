# FastFSM 0.7 – Hierarchical State Machines (HSM) - Specyfikacja implementacyjna

> **Cel wydania 0.7** – wzbogacić FastFSM o hierarchie stanów, historię, priorytety i internal transitions bez kompromisu w zakresie zerowych alokacji i prędkości poniżej 1 ns na przejście.

---

## 1. Wprowadzenie teoretyczne

### 1.1 Finite State Machine vs. Hierarchical State Machine

* **FSM** – posiada skończony, płaski zbiór stanów; liczba przejść rośnie w O(*n²*)
* **HSM** – umożliwia zagnieżdżanie stanów (*nested* / *composite*). W UML wprowadzono stany nadrzędne oraz ortogonalne regiony, dzięki czemu wykres przejść pozostaje czytelny nawet przy dużych systemach

### 1.2 Kluczowe pojęcia UML

| Pojęcie               | Znaczenie                                                                                                     |
| --------------------- | ------------------------------------------------------------------------------------------------------------- |
| **Composite State**   | Stan zawierający podstany; wejście do rodzica rozpoczyna *automatyczny* skok do jego stanu początkowego      |
| **Initial Substate**  | Wyznaczony podstan aktywowany przy wejściu do composite‑state                                                |
| **History State**     | Pseudostan zapamiętujący ostatni aktywny podstan (Shallow/Deep)                                              |
| **Internal Transition** | Przejście bez wyjścia/wejścia do stanu (bez OnExit/OnEntry)                                               |
| **Priorytet przejść** | Przejścia definiowane w podstanach mają wyższy priorytet niż te w rodzicu (lub explicit priority)            |
| **Entry Guard**       | Guard wykonywany przed wejściem do composite state                                                           |

### 1.3 Dlaczego HSM - use cases

* **Re‑use logiki** – wspólne przejścia konfigurowane na rodzicu → mniejszy duplikat kodu
* **Mniejsza złożoność** O(*n*) zamiast O(*n²*)
* **Czytelniejsze testy** – można mockować pojedynczy podstan
* **Wydajność** – przy kompilacji do płaskich `switch`‑y przejścia pozostają tak szybkie, jak w FSM

---

## 2. Nowe API FastFSM 0.7

### 2.1 Rozszerzony atrybut `[State]` (już istnieje w `Abstractions/Attributes/StateAttribute.cs`)

```csharp
// Istniejący kod w StateAttribute.cs - tylko dokumentacja nowych właściwości
[State(Proc.Work, 
    Parent = Proc.MainProcess,        // HSM: rodzic stanu (już istnieje!)
    IsInitial = true,                 // HSM: czy to initial substate (już istnieje!)
    History = HistoryMode.Shallow,    // HSM: tryb historii (już istnieje!)
    OnEntry = nameof(OnWorkEntry),    // Istniejące
    OnExit = nameof(OnWorkExit))]     // Istniejące
```

**Status implementacji:**
✅ Wszystkie właściwości już istnieją w `StateAttribute.cs`
❌ Brak parsowania w `Generator/Parsers/StateMachineParser.cs`

### 2.2 Atrybut `[SubState]` - NIEPOTRZEBNY!

**Decyzja projektowa:** Używamy istniejącej właściwości `Parent` w `[State]` zamiast osobnego atrybutu. To upraszcza API.

### 2.3 Atrybut `[History]` - przez właściwość State

```csharp
// Używamy istniejącej właściwości History w StateAttribute
[State(Proc.Work, History = HistoryMode.Shallow)]
[State(Proc.ComplexWork, History = HistoryMode.Deep)]
```

**Enum `HistoryMode`** już istnieje w `Abstractions/Attributes/HistoryMode.cs`:
```csharp
public enum HistoryMode
{
    None = 0,
    Shallow = 1,
    Deep = 2
}
```

### 2.4 Rozszerzone atrybuty `[Transition]` i `[InternalTransition]`

```csharp
// TransitionAttribute.cs - do rozszerzenia o Priority
[Transition(Proc.Work_Active, Trig.Finish, Proc.Done, 
    Priority = 200,  // NOWA WŁAŚCIWOŚĆ - do dodania
    Guard = nameof(IsWorkComplete),
    Action = nameof(FinalizeWork))]

// InternalTransitionAttribute.cs - już kompletny!
[InternalTransition(Proc.Work_Active, Trig.Tick, 
    Guard = nameof(ShouldUpdateProgress),  // Już istnieje!
    Action = nameof(UpdateProgress))]      // Już istnieje!
```

**Status implementacji:**
✅ `InternalTransitionAttribute` już kompletny w `Abstractions/Attributes/InternalTransitionAttribute.cs`
❌ Brak `Priority` w `TransitionAttribute` - **do dodania w Phase 1**

### 2.5 Caveats & Best Practices

#### Enum-only fallback
Maszyny bez żadnych atrybutów `[State]` są wspierane (stany z enumu), ale **bez hierarchii**. Funkcje HSM wymagają `[State]` z `Parent/IsInitial/History`.

#### Payload + HSM entry chain
Gdy przejście celuje w **rodzica**, automatyczne zejście do initial child używa **bezparametrowego** `OnEntry`. Payload dociera do `OnEntry(TPayload)` tylko gdy przejście celuje bezpośrednio w dziecko. `OnExit` nigdy nie otrzymuje payload.

### 2.6 Kolejność wywołań

#### Wejście do hierarchii (Pending → Work → Work_Idle):
1. `CanEnterWork()` – EntryGuard dla Work (jeśli zdefiniowany)
2. `OnWorkEntry()` – OnEntry rodzica
3. `OnIdleEntry()` – OnEntry podstanu

#### Wyjście z hierarchii (Work_Active → Done):
1. `OnActiveExit()` – OnExit podstanu
2. `OnWorkExit()` – OnExit rodzica
3. Transition action
4. `OnDoneEntry()` – OnEntry docelowego

**Implementacja w:** `Generator/Helpers/CallbackGenerationHelper.cs` - nowa metoda `GenerateHierarchicalCallbacks()`

### 2.7 Przykład kompletnej maszyny

```csharp
public enum ProcessState 
{ 
    Pending, 
    Work,           // Parent
    Work_Idle,      // Child of Work
    Work_Active,    // Child of Work
    Work_Paused,    // Child of Work
    Done,
    Error
}

public enum ProcessTrigger 
{ 
    Start, 
    Tick, 
    Pause,
    Resume,
    Finish,
    Abort
}

[StateMachine(typeof(ProcessState), typeof(ProcessTrigger), EnableHierarchy = true)]
public partial class Processor
{
    private int _progress = 0;
    
    // Parent state
    [State(ProcessState.Work, 
        History = HistoryMode.Shallow,
        OnEntry = nameof(InitializeWork),
        OnExit = nameof(CleanupWork))]
    private void ConfigureWork() { }
    
    // Child states używające Parent property
    [State(ProcessState.Work_Idle, 
        Parent = ProcessState.Work, 
        IsInitial = true,
        OnEntry = nameof(StartIdle))]
    [State(ProcessState.Work_Active, 
        Parent = ProcessState.Work, 
        OnEntry = nameof(StartActive))]
    [State(ProcessState.Work_Paused, 
        Parent = ProcessState.Work)]
    private void ConfigureSubstates() { }
    
    // Transitions z priorytetami
    [Transition(ProcessState.Pending, ProcessTrigger.Start, ProcessState.Work)]
    
    // Internal transition - nie wywołuje OnExit/OnEntry
    [InternalTransition(ProcessState.Work_Active, ProcessTrigger.Tick, 
        Guard = nameof(CanUpdate),
        Action = nameof(UpdateProgress))]
    
    // Transitions wewnątrz hierarchii
    [Transition(ProcessState.Work_Idle, ProcessTrigger.Tick, ProcessState.Work_Active)]
    [Transition(ProcessState.Work_Active, ProcessTrigger.Pause, ProcessState.Work_Paused)]
    [Transition(ProcessState.Work_Paused, ProcessTrigger.Resume, ProcessState.Work_Active)]
    
    // Transition z hierarchii - wysoki priorytet
    [Transition(ProcessState.Work_Active, ProcessTrigger.Finish, ProcessState.Done,
        Priority = 200,
        Guard = nameof(IsComplete))]
    
    // Transition z rodzica - niski priorytet
    [Transition(ProcessState.Work, ProcessTrigger.Finish, ProcessState.Error,
        Priority = 100)]
    
    // Abort z dowolnego miejsca w hierarchii
    [Transition(ProcessState.Work, ProcessTrigger.Abort, ProcessState.Error)]
    private void ConfigureTransitions() { }
    
    // Guards
    private bool CanStartWork() => _progress == 0;
    private bool IsComplete() => _progress >= 100;
    private bool CanUpdate() => _progress < 100 && _progress % 10 == 0;
    
    // Actions
    private void InitializeWork() => Console.WriteLine("Work initialized");
    private void CleanupWork() => Console.WriteLine("Work cleaned up");
    private void StartIdle() => Console.WriteLine("Idle...");
    private void StartActive() => Console.WriteLine("Working!");
    private void UpdateProgress() 
    {
        _progress += 10;
        Console.WriteLine($"Progress: {_progress}%");
    }
}
```

---

## 3. Walidacja compile‑time

### 3.1 Errors (blokują kompilację) - już zdefiniowane w `Generator.Rules/Definitions/RuleDefinition.cs`

* **FSM100**: `CircularHierarchy` – wykryto cykl w hierarchii stanów ✅
* **FSM101**: `OrphanSubstate` – parent state nie istnieje ✅
* **FSM102**: `InvalidHierarchyConfiguration` – parent state bez dokładnie jednego initial substate (ERROR) ✅
* **FSM103**: `MultipleInitialSubstates` – więcej niż jeden initial dla rodzica ✅

### 3.2 Warnings (ostrzeżenia)

* **FSM104**: `InvalidHistoryConfiguration` – history na non-composite state (WARNING - Fix: remove history or add children) ✅
* **FSM105**: `ConflictingTransitionTargets` – transition do composite bez explicit child (INFO) ✅
* **FSM106**: `EqualPriorityTransitions` – przejścia z równym priorytetem (WARNING - declaration order break-tie)

### 3.3 Info (sugestie)

* **FSM201**: `DeepHistoryPerformance` – Deep history w hierarchii >3 poziomów może wpłynąć na wydajność
* **FSM202**: `TooManyStates` – >100 stanów, rozważ podział na osobne maszyny

**Implementacja:** Reguły FSM100-105 już istnieją, tylko brak kontekstów i wywołań w `Generator/Analyzers/StateMachineAnalyzer.cs`

---

## 4. Wydajność i implementacja w generatorze

### 4.1 Reprezentacja w pamięci

```csharp
// Generowane struktury w HierarchicalVariantGenerator.cs - zero allocation
private struct StateHierarchy
{
    public readonly byte ParentIndex;
    public readonly byte DefaultChildIndex;
    public readonly byte ChildCount;
    // BitMask strategy selected at compile time
    public readonly ulong BitMask64;  // For <=64 states
    // OR
    public readonly uint BitMaskIndex; // Index into BitMaskArray for >64 states
}

// Deep History - generated per composite state with history
// Size determined at compile time based on actual hierarchy depth
private struct HistoryPath_Work  // MAX_DEPTH_WORK = 3
{
    public fixed byte Path[3];
    public byte Depth;
}

private struct HistoryPath_ComplexWork  // MAX_DEPTH_COMPLEXWORK = 5
{
    public fixed byte Path[5];
    public byte Depth;
}

// Runtime fields
private readonly StateHierarchy[] _hierarchy; // Compile-time initialized

// History fields - only for states with [History] attribute
private TState _historyShallow_Work;          
private HistoryPath_Work _historyDeep_Work;   // Only if Depth=Deep

// For >64 states - bit mask array
private static readonly uint[] _bitMaskArray; // Compile-time initialized
```

**Lokalizacja generacji:** `Generator/SourceGenerators/HierarchicalVariantGenerator.cs` (nowy plik)

### 4.2 Flattening algorithm

Generator buduje płaski `switch` z uwzględnieniem:

1. **Sortowanie po priorytetach** – transitions z wyższym Priority pierwsze
2. **Deterministyczna kolejność** – przy równych priorytetach wygrywa pierwszy w kodzie źródłowym
3. **Hierarchy flattening** – przejścia z podstanów przed rodzicami
4. **Goto optimization** – bezpośrednie skoki do DefaultSubstate
5. **Internal transitions** – osobna gałąź bez state change

```csharp
// Generated Fire() method structure
public void Fire(ProcessTrigger trigger, object? payload = null)
{
    switch (_currentState)
    {
        case ProcessState.Work_Active:
            switch (trigger)
            {
                // Priority 200 - substate transition
                case ProcessTrigger.Finish when IsComplete():
                    ExitWorkActive();
                    ExitWork();
                    _currentState = ProcessState.Done;
                    EnterDone();
                    return;
                    
                // Internal transition - no state change, with guard
                case ProcessTrigger.Tick when CanUpdate():
                    UpdateProgress();
                    return;
                    
                // Fall through to parent
            }
            goto case ProcessState.Work;
            
        case ProcessState.Work:
            switch (trigger)
            {
                // Priority 100 - parent transition (lower priority)
                case ProcessTrigger.Finish:
                    // This executes only if substate didn't handle it
                    ExitCurrentSubstate();
                    ExitWork();
                    _currentState = ProcessState.Error;
                    EnterError();
                    return;
            }
            break;
    }
}
```

**Implementacja w:** `Generator/SourceGenerators/HierarchicalVariantGenerator.cs` metoda `GenerateHierarchicalFire()`

### 4.3 Bit-mask operations

```csharp
// Generated helper methods for <=64 states
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public bool IsInWork() => (_currentState & WORK_MASK) != 0;

// For >64 states - uses bit array
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public bool IsInWork() 
{
    var idx = (int)_currentState;
    return (_bitMaskArray[idx >> 5] & (1u << (idx & 31))) != 0;
}

// Universal helper - generator wybiera implementację
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public bool IsInHierarchy(ProcessState parent) => 
    StateCount <= 64 
        ? (_hierarchy[(int)_currentState].BitMask64 & _hierarchy[(int)parent].BitMask64) != 0
        : CheckBitMaskArray(_currentState, parent);

// Debug helper - only in DEBUG builds
#if DEBUG
public string DumpActivePath()
{
    var sb = new StringBuilder();
    var current = _currentState;
    sb.Append(current.ToString());
    
    while (_hierarchy[(int)current].ParentIndex != 255) // 255 = no parent
    {
        current = (ProcessState)_hierarchy[(int)current].ParentIndex;
        sb.Insert(0, current.ToString() + " / ");
    }
    
    return sb.ToString(); // e.g., "Working / Working_Initializing"
}
#endif
```

### 4.4 History implementation

```csharp
// Shallow history - simple field update
private void ExitWork()
{
    _historyShallow_Work = _currentState;
    OnWorkExit();
}

// Deep history - path recording
private void RecordDeepHistory(ref HistoryPath path)
{
    byte depth = 0;
    var current = _currentState;
    while (_hierarchy[(int)current].ParentIndex != 255) // 255 = no parent
    {
        path.Path[depth++] = (byte)current;
        current = (ProcessState)_hierarchy[(int)current].ParentIndex;
    }
    path.Depth = depth;
}

// Async with CancellationToken - proper cleanup on cancel
private async ValueTask FireAsyncInternal(ProcessTrigger trigger, CancellationToken ct)
{
    ct.ThrowIfCancellationRequested();
    
    try
    {
        // Exit chain
        await ExitCurrentStateAsync(ct);
        
        ct.ThrowIfCancellationRequested();
        
        // Transition action
        await ExecuteActionAsync(trigger, ct);
        
        ct.ThrowIfCancellationRequested();
        
        // Entry chain
        await EnterNewStateAsync(ct);
    }
    catch (OperationCanceledException) when (ct.IsCancellationRequested)
    {
        // State remains unchanged on cancellation
        throw;
    }
}
```

**Implementacja w:** `Generator/Helpers/AsyncGenerationHelper.cs` - rozszerzenie istniejących metod

### 4.5 Generator performance & cache

**Incremental generation w `Generator/SourceGenerators/StateMachineSourceGenerator.cs`:**
```csharp
// Use ForAttributeWithMetadataName for optimal performance
context.RegisterSourceOutput(
    context.SyntaxProvider
        .ForAttributeWithMetadataName(
            "Abstractions.Attributes.StateMachineAttribute",
            predicate: (node, _) => node is ClassDeclarationSyntax,
            transform: TransformStateMachine)
        .Where(x => x != null),
    Execute);
```

**Cache considerations:**
* Analyzer latency target: <100ms dla 2000 stanów
* Użyj `Lazy<T>` dla ciężkich obliczeń
* Unikaj LINQ w hot-path (preferuj `foreach`)
* W README: tip o `dotnet build /p:UseSharedCompilation=false` przy problemach z cache

### 4.6 Performance notes

Obecna szybka ścieżka obsługuje ≤ 64 stany (bitmask). Dla > 64 używamy array masks. Wsparcie dla > 256 stanów planowane w 0.8+. Gwarancja zero alokacji pozostaje.

### 4.7 Przewaga nad Stateless

**Problem w Stateless - dummy state pattern:**
```csharp
// Stateless wymaga sztucznego stanu pośredniego
sm.Configure(State.Work)
    .InitialTransition(State.Work_DummyInitial)
    .SubstateOf(State.Parent);

sm.Configure(State.Work_DummyInitial)
    .OnEntry(() => sm.Fire(Trigger.ToActualSubstate))
    .Permit(Trigger.ToActualSubstate, State.Work_Idle);
```

**FastFSM - natywne wsparcie:**
```csharp
[State(ProcessState.Work_Idle, Parent = ProcessState.Work, IsInitial = true)]
// Automatyczny skok, zero boilerplate, zero alokacji
```

---

## 5. Plan wdrożenia

### Phase 1: Model & Parser [Tydzień 1]

# FastFSM 0.7 HSM - Phase 1: Model & Parser Implementation Summary

## Phase 1: Model & Parser [Tydzień 1] - ✅ ZAKOŃCZONE

### 1.1 Rozszerzenie modelu składni - ✅ COMPLETE

#### Atrybuty
- ✅ **Plik:** `Abstractions/Attributes/TransitionAttribute.cs`
  - Dodano: `public int Priority { get; set; } = 0;`
  - Status: DONE (9 sierpnia 2024)

- ✅ **Plik:** `Abstractions/Attributes/InternalTransitionAttribute.cs`
  - Dodano: `public int Priority { get; set; } = 0;`
  - Status: DONE (9 sierpnia 2024)

- ✅ **Plik:** `Abstractions/Attributes/StateAttribute.cs`
  - Już zawierał: `Parent`, `IsInitial`, `History`
  - Status: Already existed

#### Modele
- ✅ **Plik:** `Generator.Model/StateMachineModel.cs`
  - Właściwości HSM już istniały: `ParentOf`, `ChildrenOf`, `InitialChildOf`, `HistoryOf`, `Depth`
  - Status: Already existed, properly used by parser

- ✅ **Plik:** `Generator.Model/StateModel.cs`
  - Zawiera: `ParentState`, `IsInitial`, `History`, `IsComposite`
  - Status: Already existed

- ✅ **Plik:** `Generator.Model/TransitionModel.cs`
  - Dodano: `public int Priority { get; set; } = 0;`
  - Status: DONE (9 sierpnia 2024)

- ✅ **Plik:** `Generator.Model/HistoryMode.cs`
  - Enum z wartościami: `None`, `Shallow`, `Deep`
  - Status: Already existed

### 1.2 Parsowanie atrybutów - ✅ COMPLETE

- ✅ **Plik:** `Generator/Parsers/StateMachineParser.cs`
  
  #### Parsowanie właściwości HSM:
  - ✅ **ParseStateAttributes** (linie ~600-750)
    - Parsuje `Parent` z `StateAttribute`
    - Parsuje `IsInitial` z `StateAttribute`
    - Parsuje `History` z `StateAttribute`
    - Status: WORKING
  
  - ✅ **ParseTransitionAttributes** (linie ~180-360)
    - Parsuje `Priority` z `TransitionAttribute`
    - Status: DONE (9 sierpnia 2024)
  
  - ✅ **ParseInternalTransitionAttributes** (linie ~390-530)
    - Parsuje `Priority` z `InternalTransitionAttribute`
    - Ustawia `IsInternal = true` na `TransitionModel`
    - Status: DONE (9 sierpnia 2024)

### 1.3 Walidacja grafu - ✅ COMPLETE

- ✅ **Plik:** `Generator/Parsers/StateMachineParser.cs`
  
  #### Metoda BuildHierarchy (linie ~1395-1540):
  - ✅ Auto-włączanie hierarchii gdy używane są funkcje HSM
  - ✅ Budowanie relacji parent-child
  - ✅ Detekcja cykli przez `HasCircularDependency`
  - ✅ Weryfikacja InitialSubstate
  - ✅ Sprawdzenie osiągalności stanów (przez `UnreachableStateRule`)
  - ✅ Obliczanie głębokości hierarchii

### Implementowane reguły walidacji

| Reguła | Status | Opis |
|--------|--------|------|
| FSM100 | ✅ WORKING | CircularHierarchy - wykrywa cykle w hierarchii |
| FSM101 | ✅ WORKING | OrphanSubstate - parent nie istnieje w States |
| FSM102 | ❌ ERROR | InvalidHierarchyConfiguration - composite wymaga dokładnie jednego initial |
| FSM103 | ✅ WORKING | MultipleInitialSubstates - duplikaty initial |
| FSM104 | ✅ WORKING | InvalidHistoryConfiguration - history bez dzieci |

### Utworzone konteksty walidacji

- ✅ `Generator.Rules/Contexts/CircularHierarchyContext.cs`
- ✅ `Generator.Rules/Contexts/OrphanSubstateContext.cs`
- ✅ `Generator.Rules/Contexts/MultipleInitialSubstatesContext.cs`
- ✅ `Generator.Rules/Contexts/InvalidHierarchyConfigurationContext.cs`
- ✅ `Generator.Rules/Contexts/InvalidHistoryConfigurationContext.cs`

### Testy

#### Utworzone pliki testowe:
- ✅ `StateMachine.Tests/HierarchicalTests/test_hsm_parsing.cs` - test integracyjny
- ✅ `StateMachine.Tests/HierarchicalTests/HsmValidationTests.cs` - testy walidacji
- ✅ `StateMachine.Tests/HierarchicalTests/AllHsmValidationsTest.cs` - kompleksowe testy
- ✅ `StateMachine.Tests/HierarchicalTests/SimpleCycleTest.cs` - test cykli

### Przykład użycia

```csharp
[StateMachine(typeof(ProcessState), typeof(ProcessTrigger), EnableHierarchy = true)]
public partial class TestHsmMachine
{
    // Parent state z historią
    [State(ProcessState.Work, 
        History = HistoryMode.Shallow,
        OnEntry = nameof(EnterWork),
        OnExit = nameof(ExitWork))]
    private void ConfigureWorkState() { }
    
    // Initial child state
    [State(ProcessState.Work_Idle, 
        Parent = ProcessState.Work, 
        IsInitial = true)]
    private void ConfigureIdleState() { }
    
    // Transition z priorytetem
    [Transition(ProcessState.Work_Idle, ProcessTrigger.Activate, ProcessState.Work_Active,
        Priority = 100)]
    private void ConfigureActivation() { }
}
```

## Podsumowanie

Phase 1 została zakończona pomyślnie. Parser poprawnie:
- Odczytuje wszystkie właściwości HSM z atrybutów
- Buduje strukturę hierarchii w modelu
- Waliduje poprawność hierarchii (cykle, orphans, etc.)
- Przygotowuje model do generacji kodu w Phase 2

**Gotowość do Phase 2:** ✅ PEŁNA

# FastFSM 0.7 HSM - Phase 2: Code Generation Strategy

## Strategia implementacji: Izolowany prototyp → Integracja

### Uzasadnienie podejścia

Zamiast modyfikować działający generator, stworzymy izolowany projekt prototypowy który:
- Pozwoli na szybkie iteracje i eksperymenty
- Umożliwi łatwe debugowanie (Console.WriteLine, debugger)
- Nie wprowadzi ryzyka do stabilnego kodu
- Skupi się wyłącznie na logice HSM
- Da nam działający kod do późniejszej integracji

## Struktura projektu prototypowego

```
FastFsm.HsmPrototype/
├── FastFsm.HsmPrototype.csproj       # Projekt konsoli .NET 8
├── Program.cs                         # Entry point z przykładami
├── Core/
│   ├── HierarchicalCodeGenerator.cs  # Główna logika generacji
│   ├── StateHierarchyBuilder.cs      # Budowanie struktur hierarchii
│   ├── TransitionFlattener.cs        # Spłaszczanie przejść do switch
│   └── HistoryManager.cs             # Obsługa historii
├── Helpers/
│   ├── IndentedStringBuilder.cs      # Helper do formatowania kodu
│   └── NamingHelper.cs               # Konwencje nazw
├── TestModels/                        # Modele do testów
│   ├── SimpleHierarchy.cs            # Prosty parent->child
│   ├── DeepHierarchy.cs              # 3+ poziomy
│   ├── HistoryScenarios.cs           # Shallow/Deep history
│   └── PriorityResolution.cs         # Konflikty priorytetów
└── Output/                            # Wygenerowany kod
    └── Generated/
```

## Milestone 2.1: Podstawowa hierarchia [Dni 1-2]

### Cel
Wygenerować działający kod dla prostej hierarchii parent->child z automatic initial substate.

### Zakres
1. **Struktura StateHierarchy**
   ```csharp
   private struct StateHierarchy
   {
       public readonly byte ParentIndex;
       public readonly byte DefaultChildIndex;
       public readonly byte ChildCount;
       public readonly ulong BitMask64;
   }
   ```

2. **Automatic initial substate**
   - Transition do parent state automatycznie przechodzi do initial child
   - Generowanie `goto` w switch statement

3. **Entry/Exit chains**
   - Wejście: Parent.OnEntry → Child.OnEntry
   - Wyjście: Child.OnExit → Parent.OnExit

### Przykład wejścia (model):
```csharp
var model = new StateMachineModel
{
    StateType = "ProcessState",
    TriggerType = "ProcessTrigger",
    States = new Dictionary<string, StateModel>
    {
        ["Work"] = new() { Name = "Work" },
        ["Work_Idle"] = new() { 
            Name = "Work_Idle", 
            ParentState = "Work", 
            IsInitial = true 
        }
    },
    Transitions = new List<TransitionModel>
    {
        new() { 
            FromState = "Pending", 
            Trigger = "Start", 
            ToState = "Work" 
        }
    }
};
```

### Przykład wyjścia (wygenerowany kod):
```csharp
public void Fire(ProcessTrigger trigger)
{
    switch (_currentState)
    {
        case ProcessState.Pending:
            if (trigger == ProcessTrigger.Start)
            {
                // Exit Pending
                OnPendingExit?.Invoke();
                
                // Entry chain: Work → Work_Idle
                OnWorkEntry?.Invoke();
                _currentState = ProcessState.Work_Idle;
                OnWorkIdleEntry?.Invoke();
                return;
            }
            break;
    }
}
```

## Milestone 2.2: Priorytety i Internal Transitions [Dni 3-4]

### Cel
Obsłużyć priorytety przejść i internal transitions bez zmiany stanu.

### Zakres
1. **Sortowanie przejść po priorytetach**
   - Wyższy priorytet = pierwsze w switch
   - Deterministyczna kolejność przy równych priorytetach

2. **Internal transitions**
   - Wykonanie akcji bez OnExit/OnEntry
   - Osobna gałąź w switch

3. **Fallthrough do parent**
   - Jeśli child nie obsłużył → sprawdź parent
   - Użycie `goto case ParentState;`

### Przykład:
```csharp
case ProcessState.Work_Active:
    switch (trigger)
    {
        // Priority 200 - child transition
        case ProcessTrigger.Finish when IsComplete():
            goto TransitionToD Done;
            
        // Internal transition
        case ProcessTrigger.Tick when CanUpdate():
            UpdateProgress();  // Tylko akcja, bez zmiany stanu
            return;
    }
    goto case ProcessState.Work;  // Fallthrough do parent
```

## Milestone 2.3: Historia [Dni 5-6]

### Cel
Implementacja shallow i deep history.

### Zakres
1. **Shallow history**
   - Zapamiętanie ostatniego bezpośredniego child
   - Pole: `private ProcessState _historyShallow_Work;`

2. **Deep history**
   - Zapamiętanie całej ścieżki
   - Struktura: `private HistoryPath_Work _historyDeep_Work;`

3. **Restore history**
   - Przy wejściu do state z historią
   - Fallback do initial jeśli brak historii

### Przykład struktury:
```csharp
private struct HistoryPath_Work
{
    public fixed byte Path[3];  // Max depth dla Work
    public byte Depth;
}

private void RestoreHistory(ProcessState parent)
{
    if (_historyShallow_Work != default)
    {
        _currentState = _historyShallow_Work;
        // Entry callbacks...
    }
    else
    {
        // Default to initial substate
        _currentState = ProcessState.Work_Idle;
    }
}
```

## Milestone 2.4: Integracja z generatorem [Dni 7-8]

### Cel
Przenieść działający kod prototypu do prawdziwego generatora.

### Kroki
1. **Utworzenie HierarchicalVariantGenerator.cs**
   - Klasa dziedzicząca z `StateMachineCodeGenerator`
   - Przeniesienie logiki z prototypu

2. **Modyfikacja VariantSelector**
   - Wybór wariantu hierarchicznego gdy `model.HierarchyEnabled`

3. **Testy integracyjne**
   - Sprawdzenie że stare FSM dalej działają
   - Nowe testy dla HSM

## Metryki sukcesu

### Wydajność (benchmarki)
| Scenariusz | Target | Max alokacje |
|------------|--------|--------------|
| Parent → Initial substate | < 0.85 ns | 0 B |
| Internal transition | < 0.70 ns | 0 B |
| Shallow history restore | < 0.90 ns | 0 B |
| Deep history (3 levels) | < 1.20 ns | 0 B |
| Priority resolution | < 0.85 ns | 0 B |

### Funkcjonalność
- ✅ Wszystkie testy z Phase 1 generują działający kod
- ✅ Entry/Exit chains wykonują się w prawidłowej kolejności
- ✅ Internal transitions nie zmieniają stanu
- ✅ Historia jest poprawnie zapisywana i przywracana
- ✅ Priorytety są respektowane

## Harmonogram

| Dzień | Zadanie | Deliverable |
|-------|---------|-------------|
| 1-2 | Milestone 2.1 | Działający prototyp z basic hierarchy |
| 3-4 | Milestone 2.2 | Priorytety i internal transitions |
| 5-6 | Milestone 2.3 | Shallow/Deep history |
| 7-8 | Milestone 2.4 | Integracja z generatorem |
| 9 | Testy | Pełne pokrycie testami |
| 10 | Dokumentacja | Aktualizacja README, przykłady |

## Ryzyka i mitygacje

| Ryzyko | Prawdopodobieństwo | Mitygacja |
|--------|-------------------|-----------|
| Zbyt skomplikowany generated code | Średnie | Iteracyjne upraszczanie, code review |
| Degradacja wydajności | Niskie | Benchmarki na każdym etapie |
| Edge cases w hierarchii | Wysokie | Obszerne testy, różne scenariusze |
| Problemy z debugowaniem | Średnie | Czytelne nazwy, komentarze w generated code |

## Decyzje projektowe

### BitMask strategy
- ≤64 stanów: `ulong` bitmask
- >64 stanów: `uint[]` array
- Wybór w compile-time na podstawie liczby stanów

### Goto vs method calls
- Używamy `goto` dla skoków w ramach switch
- Minimalizuje overhead wywołań metod
- Pozwala kompilatorowi na lepszą optymalizację

### Fixed-size structures
- Struktury history mają rozmiar określony w compile-time
- Bazuje na faktycznej głębokości hierarchii
- Zero alokacji w runtime


### Phase 3: Diagnostyka [Tydzień 4]

#### 3.1 Errors - wykorzystanie istniejących reguł
- [ ] **Nowe pliki w** `Generator.Rules/Contexts/`:
  - `CircularHierarchyContext.cs`
  - `OrphanSubstateContext.cs`
  - `InvalidHierarchyConfigurationContext.cs`
  - `MultipleInitialSubstatesContext.cs`

- [ ] **Plik:** `Generator/Analyzers/StateMachineAnalyzer.cs`
  - Wywołanie reguł FSM100-105 z nowymi kontekstami

#### 3.2 Warnings
- [ ] **Nowa reguła:** `Generator.Rules/Rules/EqualPriorityTransitionsRule.cs`
- [ ] **Kontekst:** `Generator.Rules/Contexts/EqualPriorityContext.cs`

#### 3.3 Performance hints
- [ ] Dodać do `Generator/Analyzers/StateMachineAnalyzer.cs`

### Phase 4: Testing [Tydzień 5]

#### 4.1 Unit tests
- [ ] **Nowy folder:** `StateMachine.Tests/HierarchicalTests/`
  - `SimpleHierarchyTests.cs` (2 levels)
  - `DeepHierarchyTests.cs` (5+ levels)
  - `ShallowHistoryTests.cs`
  - `DeepHistoryTests.cs`
  - `PriorityResolutionTests.cs`
  - `InternalTransitionTests.cs`
  - `EntryGuardTests.cs`
  - `CrossHierarchyTransitionTests.cs`

#### 4.2 Benchmarks
- [ ] **Nowe pliki w** `Benchmark/`:
  - `HierarchicalFsmBenchmark.cs`
  - `InternalTransitionBenchmark.cs`
  - `HistoryRestorationBenchmark.cs`
  - `PriorityResolutionBenchmark.cs`
  - `IsInHierarchyBenchmark.cs`

#### 4.3 Integration tests
- [ ] **Plik:** `StateMachine.Tests/MigrationTests.cs`
  - Test że wszystkie FSM 0.6 dalej działają
- [ ] **Plik:** `StateMachine.DependencyInjection.Tests/HierarchicalDITests.cs`
- [ ] **Plik:** `StateMachine.Async.Tests/HierarchicalAsyncTests.cs`
  - Test CancellationToken w hierarchii

### Phase 5: Documentation [Tydzień 6]

#### 5.1 User documentation
- [ ] `README.md` - sekcja "Hierarchical State Machines"
- [ ] `docs/Migration_0.6_to_0.7.md`
- [ ] `docs/HSM_Tutorial.md`
- [ ] `docs/InternalTransitions.md`
- [ ] `docs/HistoryPatterns.md`
- [ ] `docs/Debugging_HSM.md` - DumpActivePath()

#### 5.2 API documentation
- [ ] XML comments w `Abstractions/Attributes/StateAttribute.cs`
- [ ] XML comments w `Abstractions/Attributes/InternalTransitionAttribute.cs`
- [ ] IntelliSense descriptions dla nowych właściwości

#### 5.3 Performance guide
- [ ] `docs/HSM_Performance.md`
- [ ] Zalecenia głębokości hierarchii
- [ ] Best practices dla historii
- [ ] Optymalizacja dla dużych enumów

---

## 6. Benchmark targets

| Scenariusz                    | Target wydajności     | Max alokacje |
| ----------------------------- | -------------------- | ------------ |
| Flat FSM baseline             | 0.81 ns              | 0 B          |
| Parent → DefaultSubstate      | < 0.85 ns            | 0 B          |
| Internal transition           | < 0.70 ns            | 0 B          |
| Internal transition z guard   | < 0.75 ns            | 0 B          |
| Shallow history restore       | < 0.90 ns            | 0 B          |
| Deep history restore (3 lvl)  | < 1.20 ns            | 0 B          |
| Priority resolution (5 trans) | < 0.85 ns            | 0 B          |
| IsInHierarchy check (<64)     | < 0.35 ns            | 0 B          |
| IsInHierarchy check (>64)     | < 0.45 ns            | 0 B          |
| EntryGuard evaluation        | < 0.95 ns            | 0 B          |
| Async with CancellationToken  | < 500 ns             | 0 B          |
| Generator build time (2k states) | < 50 ms          | -            |
| Analyzer latency (per edit)   | < 100 ms            | -            |

---

## 7. Kluczowe decyzje projektowe

### 7.1 DefaultSubstate obowiązkowy (w 0.7)
* Zgodność z UML
* Brak "wiszących" parent states
* Opcjonalność (`RequireExplicitSubstate`) planowana na 0.8

### 7.2 Deep History per-parent
* Zero alokacji
* Minimalne zużycie pamięci (rozmiar = faktyczna głębokość)
* Struktura generowana tylko gdy używana

### 7.3 Deterministyczna kolejność priorytetów
* Przy równych priorytetach wygrywa pierwszy w kolejności deklaracji
* Warning zamiast Error przy konfliktach
* Pełna kontrola użytkownika

### 7.4 Internal transitions z pełnym wsparciem
* Guards i Actions dostępne
* Jasna różnica vs self-loop (A→A)
* Zgodność z UML

### 7.5 Skalowanie dla dużych maszyn
* Automatyczny wybór strategii bit-mask (<=64 vs >64 stanów)
* Wsparcie dla enumów z setkami wartości
* Zero wpływu na wydajność małych FSM

### 7.6 Diagnostyka i debugging
* `DumpActivePath()` w DEBUG builds
* Zero overhead w Release
* Pomocne przy debugowaniu złożonych hierarchii

---

## 8. Ryzyka i mitygacje

| Ryzyko | Prawdopodobieństwo | Wpływ | Mitygacja |
| ------ | ------------------ | ----- | --------- |
| Degradacja wydajności base FSM | Niskie | Wysoki | Benchmark CI, conditional compilation |
| Złożoność API | Średnie | Średni | Incremental release, przykłady |
| Breaking changes | Niskie | Wysoki | Compatibility layer, migration tool |
| Generator performance | Średnie | Niski | Incremental generation, caching |
| **Async cancellation bugs** | Średnie | Średni | Comprehensive tests z CancellationToken, proper state rollback |

---

## 9. Definition of Done

- [ ] Wszystkie testy przechodzą
- [ ] Zero alokacji potwierdzone w BenchmarkDotNet
- [ ] Wydajność < 1 ns dla podstawowych operacji
- [ ] 100% pokrycie kodu testami
- [ ] Dokumentacja kompletna
- [ ] Przykłady dla każdej funkcji
- [ ] Migration guide z 0.6
- [ ] NuGet package 0.7.0-beta opublikowany

---

## 10. Następne kroki (post 0.7)

### 0.8 Roadmap
* Optional DefaultSubstate (`RequireExplicitSubstate = true`)
* Orthogonal regions
* Completion transitions
* Event deferral
* Extended enum support (>256 values)
* **String-based enums/records** - interoperacyjność z minimal API i JSON serialization

### 0.9 Roadmap
* Visual debugger
* Mermaid/PlantUML export
* Runtime state machine modification
* Microservices integration patterns (REST/gRPC state sync)

### 1.0 Roadmap
* Stabilne API
* Performance guarantees
* Enterprise support
* **JSON serialization** dla state persistence w mikroservisach

---

## 11. Konkretne pierwsze kroki implementacji

### Krok 1: Dodaj Priority do TransitionAttribute
```bash
# Otwórz plik
Abstractions/Attributes/TransitionAttribute.cs

# Dodaj property:
public int Priority { get; set; } = 0;

# Commit:
git commit -m "feat(hsm): Add Priority property to TransitionAttribute"
```

### Krok 2: Parsuj hierarchię w StateMachineParser
```bash
# Otwórz plik
Generator/Parsers/StateMachineParser.cs

# Znajdź metodę ParseStates() lub podobną

# Dodaj po niej:
private void ParseHierarchy(StateMachineModel model, SemanticModel semanticModel)
{
    foreach (var stateAttr in /* iterate state attributes */)
    {
        // Odczytaj Parent property
        var parentProp = GetNamedArgument(stateAttr, "Parent");
        if (parentProp != null)
        {
            model.ParentOf[stateName] = parentProp.ToString();
            // etc.
        }
    }
}

# Test:
StateMachine.Tests/ParserTests/HierarchyParsingTests.cs
```

### Krok 3: Implementuj pierwszą regułę HSM
```bash
# Utwórz kontekst
Generator.Rules/Contexts/CircularHierarchyContext.cs

# Wywołaj w analizerze
Generator/Analyzers/StateMachineAnalyzer.cs
- Znajdź metodę gdzie są wywoływane reguły
- Dodaj: ValidateCircularHierarchy(model);
```

---

## 12. Przykład wygenerowanego kodu

```csharp
// Wygenerowane przez HierarchicalVariantGenerator.cs
public partial class Processor
{
    // Hierarchy metadata
    private static readonly StateHierarchy[] _hierarchy = new StateHierarchy[]
    {
        /* Pending */ new() { ParentIndex = 255, DefaultChildIndex = 255, ChildCount = 0, BitMask64 = 0b0000001 },
        /* Work */    new() { ParentIndex = 255, DefaultChildIndex = 2, ChildCount = 3, BitMask64 = 0b0011110 },
        /* Work_Idle */ new() { ParentIndex = 1, DefaultChildIndex = 255, ChildCount = 0, BitMask64 = 0b0011110 },
        // ... etc
    };
    
    // History fields (only for states with History attribute)
    private ProcessState _historyShallow_Work;
    
    // Optimized Fire with hierarchy support
    public void Fire(ProcessTrigger trigger, object? payload = null)
    {
        ThrowIfNotStarted();
        
        switch (_currentState)
        {
            case ProcessState.Work_Active:
                // Handle at substate level first
                switch (trigger)
                {
                    case ProcessTrigger.Finish when IsComplete():
                        // Exit chain: Work_Active -> Work
                        OnActiveExit?.Invoke();
                        _historyShallow_Work = _currentState; // Record history
                        OnWorkExit?.Invoke();
                        
                        _currentState = ProcessState.Done;
                        
                        // Entry chain: -> Done
                        OnDoneEntry?.Invoke();
                        return;
                        
                    case ProcessTrigger.Tick when CanUpdate():
                        // Internal transition - no state change
                        UpdateProgress();
                        return;
                }
                // Fall through to parent
                goto case ProcessState.Work;
                
            case ProcessState.Work:
                // Handle at parent level
                switch (trigger)
                {
                    case ProcessTrigger.Abort:
                        ExitFromHierarchy(ProcessState.Work);
                        _currentState = ProcessState.Error;
                        OnErrorEntry?.Invoke();
                        return;
                }
                break;
        }
        
        throw new InvalidOperationException($"No transition from {_currentState} on {trigger}");
    }
    
    // Helper methods
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool IsInWork() => (_hierarchy[(int)_currentState].BitMask64 & 0b0011110) != 0;
    
    #if DEBUG
    public string DumpActivePath()
    {
        // Implementation...
    }
    #endif
}
```