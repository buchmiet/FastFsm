\# FastFSMÂ 0.7 â€“Â Specyfikacja funkcji Hierarchical State Machines (HSM)



> \*\*Cel wydania 0.7\*\*Â â€“ wzbogaciÄ‡ FastFSM oÂ hierarchie stanÃ³w, historiÄ™ iÂ regiony rÃ³wnolegÅ‚e bez kompromisu wÂ zakresie zerowych alokacji iÂ prÄ™dkoÅ›ci poniÅ¼ej 1â€¯ns na przejÅ›cie.



---



\## 1Â Â·Â Wprowadzenie teoretyczne



\### 1.1Â Finite State Machine vs.Â Hierarchical State Machine



\* \*\*FSM\*\* â€“ posiada skoÅ„czony, pÅ‚aski zbiÃ³r stanÃ³w; liczba przejÅ›Ä‡ roÅ›nie wÂ O(\*nÂ²\*).

\* \*\*HSM\*\* â€“ umoÅ¼liwia zagnieÅ¼dÅ¼anie stanÃ³w (ang. \*nested\* / \*composite\*). WÂ UML wprowadzono stany nadrzÄ™dne oraz ortogonalne regiony, dziÄ™ki czemu wykres przejÅ›Ä‡ pozostaje czytelny nawet przy duÅ¼ych systemachÂ (\[en.wikipedia.org](https://en.wikipedia.org/wiki/UML\_state\_machine?utm\_source=chatgpt.com)).



\### 1.2Â Kluczowe pojÄ™cia UML



| PojÄ™cie               | Znaczenie                                                                                                                                                                                                    |

| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |

| \*\*Compositeâ€¯State\*\*   | stan zawierajÄ…cy podstany; wejÅ›cie do rodzica rozpoczyna \*automatyczny\* skok do jego stanu poczÄ…tkowegoÂ (\[adel-mamin.github.io](https://adel-mamin.github.io/amast/hsm.html?utm\_source=chatgpt.com)).        |

| \*\*Initialâ€¯Substate\*\*  | wyznaczony podstan aktywowany przy wejÅ›ciu do compositeâ€‘state.                                                                                                                                               |

| \*\*HistoryÂ State\*\*     | pseudostan zapamiÄ™tujÄ…cy ostatni aktywny podstan (Shallow/Deep).                                                                                                                                             |

| \*\*OrthogonalÂ Region\*\* | wspÃ³Å‚bieÅ¼ny region wÂ obrÄ™bie compositeâ€‘state; stany wszystkich regionÃ³w sÄ… aktywne rÃ³wnolegleÂ (\[barrgroup.com](https://barrgroup.com/blog/introduction-hierarchical-state-machines?utm\_source=chatgpt.com)). |

| \*\*Priorytet przejÅ›Ä‡\*\* | przejÅ›cia definiowane wÂ podstanach majÄ… wyÅ¼szy priorytet niÅ¼ te wÂ rodzicuÂ (\[www-sop.inria.fr](https://www-sop.inria.fr/members/Charles.Andre/CAdoc/ESINSA/Chap7-StateMachine.pdf?utm\_source=chatgpt.com)).   |



\### 1.3Â Dlaczego HSMÂ $useâ€‘cases$



\* \*\*Reâ€‘use logiki\*\* â€“ wspÃ³lne przejÅ›cia konfigurowane na rodzicuÂ â†’ mniejszy duplikat kodu.

\* \*\*Mniejsza zÅ‚oÅ¼onoÅ›Ä‡ O(\*n\*)\*\* zamiast O(\*nÂ²\*).

\* \*\*Czytelniejsze testy\*\* â€“ moÅ¼na mockowaÄ‡ pojedynczy podstan.

\* \*\*WydajnoÅ›Ä‡\*\* â€“ przy kompilacji do pÅ‚askich `switch`â€‘y przejÅ›cia pozostajÄ… tak szybkie, jak wÂ FSM; przykÅ‚adowo Boost.SML osiÄ…ga <â€¯0.8â€¯nsÂ (\[github.com](https://github.com/ooxi/boost-experimental-sml?utm\_source=chatgpt.com)).



---



\## 2Â Â·Â Nowe API FastFSMÂ 0.7



\### 2.1Â Rozszerzony atrybut `\[State]`



```csharp

\[State(Proc.Work, IsParent = true, DefaultSubstate = Proc.Work\_Idle)]

```



\* `IsParent`Â â€“ flaga mÃ³wiÄ…ca kompilatorowi/generatorowi, Å¼eÂ stan posiada dzieci.

\* `DefaultSubstate`Â â€“ wymagany, jedyny podstan aktywowany przy wejÅ›ciu do rodzica. JeÅ›li nie zostanie wskazany lub nieÂ naleÅ¼y do listy dzieciÂ â†’ bÅ‚Ä…d kompilacji.



\### 2.2Â Atrybut `\[SubState]`



```csharp

\[SubState(Proc.Work\_Idle,  Proc.Work)]

```



Deklaruje relacjÄ™ \*childÂ â†’Â parent\*. Generator zweryfikuje istnienie obu stanÃ³w oraz brak cykli.



\### 2.3Â Atrybut `\[History]`



```csharp

\[History(Proc.Work, Depth = HistoryDepth.Shallow)]

```



WÅ‚Ä…cza automatyczne zapamiÄ™tywanie ostatniego podstanu; `Depth.Deep` odtwarza caÅ‚e drzewo.



\### 2.4Â KolejnoÅ›Ä‡ wywoÅ‚aÅ„ `OnEntry` / `OnExit`



Przy przejÅ›ciu `Parent â†’ Child`:



1\. `Parent.OnEntry`

2\. `Child.OnEntry`

&nbsp;  Analogicznie przy wyjÅ›ciu â€“ najpierw podstan, potem rodzicÂ (\[stackoverflow.com](https://stackoverflow.com/questions/14681522/uml-state-machine-substate-transition?utm\_source=chatgpt.com)).



\### 2.5Â PrzykÅ‚ad kompletnej maszyny



```csharp

public enum Proc { Pending, Work, Work\_Idle, Work\_Active, Done }

public enum Trig { Start, Tick, Finish }



\[StateMachine(typeof(Proc), typeof(Trig))]

public partial class Processor

{

&nbsp;   \[State(Proc.Work, IsParent = true, DefaultSubstate = Proc.Work\_Idle)]

&nbsp;   \[SubState(Proc.Work\_Idle,  Proc.Work, OnEntry = nameof(StartIdle))]

&nbsp;   \[SubState(Proc.Work\_Active, Proc.Work, OnEntry = nameof(StartActive))]



&nbsp;   \[Transition(Proc.Pending, Trig.Start, Proc.Work)]

&nbsp;   \[Transition(Proc.Work\_Idle, Trig.Tick, Proc.Work\_Active)]

&nbsp;   \[Transition(Proc.Work, Trig.Finish, Proc.Done)]

&nbsp;   private void Configure() { }



&nbsp;   void StartIdle()   => Console.WriteLine("idleâ€¦");

&nbsp;   void StartActive() => Console.WriteLine("work!");

}

```



\* WejÅ›cie wÂ `Work` natychmiast aktywuje `Work\_Idle` bez koniecznoÅ›ci â€dummy stateâ€ znanego ze StatelessÂ (\[stackoverflow.com](https://stackoverflow.com/questions/24798110/stateless-how-to-define-the-initial-substate-of-a-state?utm\_source=chatgpt.com)).

\* Migracja zÂ Stateless: zamieniasz konfiguracjÄ™ `SubstateOf` naÂ atrybuty `\[State]/\[SubState]` â€“ reszta kodu pozostaje nieÂ­zmienionaÂ (\[github.com](https://github.com/dotnet-state-machine/stateless?utm\_source=chatgpt.com)).



\### 2.6Â Walidacja compileâ€‘time



Generator zgÅ‚osi \*\*diagnostykÄ™ Roslyn\*\* (severityÂ â†’Â `Error`) wÂ przypadkach:



\* `IsParent=true` bez `DefaultSubstate`.

\* `SubState` wskazuje nieistniejÄ…cego rodzica/dziecko.

\* Cykl wÂ grafie hierarchii.

&nbsp; Mechanizm opiera siÄ™ na `DiagnosticDescriptor` iÂ wyÅ›wietla siÄ™ wÂ IDE wraz zÂ podkreÅ›leniemÂ (\[learn.microsoft.com](https://learn.microsoft.com/en-us/dotnet/fundamentals/syslib-diagnostics/source-generator-overview?utm\_source=chatgpt.com)).



---



\## 3Â Â·Â WydajnoÅ›Ä‡ iÂ implementacja wÂ generatorze



\### 3.1Â Reprezentacja grafu



Generator buduje jednokierunkowÄ… tablicÄ™ `StateNode\[]` (struct) +Â tablicÄ™ indeksÃ³w dzieci. DziÄ™ki temu wÂ IL nieÂ pojawiajÄ… siÄ™ Å¼adne kolekcje zarzÄ…dzane.



\### 3.2Â Flattening toÂ `switch`



\* PrzejÅ›cia zÂ hierarchiÄ… sÄ… \*\*spÅ‚aszczane\*\* do jednego `switch` po enumie koÅ„cowego stanu.

\* Wstawka `goto` realizuje automatyczny skok do `DefaultSubstate`.

\* ÅšcieÅ¼ki `ParentÂ â†’Â History` rozwiÄ…zane poprzez przechowywanÄ… zmiennÄ… `\_histParent`.

&nbsp; Efekt: nadal \\~0,8â€¯ns na `Fire()` (baseline Boost.SML)Â (\[github.com](https://github.com/ooxi/boost-experimental-sml?utm\_source=chatgpt.com)).



\### 3.3Â Bitâ€‘mask â€isâ€‘inâ€‘hierarchyâ€



Generator wylicza maskÄ™ bitowÄ… rodzica; sprawdzenie `IsIn<Parent>()` to pojedyncze `and`. Technika analogiczna do zeroâ€‘alloc optymalizacji `readonly struct`Â (\[andrebaltieri.com](https://andrebaltieri.com/zero-allocation-techniques-in-csharp-using-ref-struct-and-readonly-struct/?utm\_source=chatgpt.com)).



\### 3.4Â Historia



Zapis `\_histParent` nastÄ™puje przy kaÅ¼dym wyjÅ›ciu zÂ podstanu; przy wejÅ›ciu do rodzica, jeÅ›li flaga `HistoryEnabled`, stan docelowy odczytywany jest zÂ historii zamiast `DefaultSubstate`.



\### 3.5Â Regiony ortogonalne (etapÂ 2)



Region = osobna maszyna jako pole klasy hosta; wywoÅ‚anie `Fire()` deleguje do regionu zaleÅ¼nego od triggera. Semantyka orthogonalna zgodna zÂ UMLÂ (\[en.wikipedia.org](https://en.wikipedia.org/wiki/UML\_state\_machine?utm\_source=chatgpt.com)).



\### 3.6Â Diagnostyka iÂ wydajnoÅ›Ä‡ generatora



\* Wykorzystaj \*\*IncrementalSourceGenerator\*\* zÂ memoizacjÄ…, aby uniknÄ…Ä‡ peÅ‚nej analizy przy kaÅ¼dym zapisieÂ (\[thinktecture.com](https://www.thinktecture.com/en/net/roslyn-source-generators-performance/?utm\_source=chatgpt.com)).

\* Sprawdzaj czas dziaÅ‚ania narzÄ™dziem `MSBuild -binaryLog` iÂ `Analyzer Performance`Â (\[meziantou.net](https://www.meziantou.net/measuring-performance-of-roslyn-source-generators.htm?utm\_source=chatgpt.com)).

\* Unikaj â€gorÄ…cychâ€ operacji LINQ â€“ patrz bestâ€‘practicesÂ (\[andrewlock.net](https://andrewlock.net/creating-a-source-generator-part-9-avoiding-performance-pitfalls-in-incremental-generators/?utm\_source=chatgpt.com)).



\### 3.7Â Benchmark plan



| Scenariusz                                                                               | Metryka                |

| ---------------------------------------------------------------------------------------- | ---------------------- |

| FlatÂ FSM 100Â przejÅ›Ä‡                                                                     | baselineÂ â€“ 0.81â€¯ns     |

| HSMÂ parentâ€‘toâ€‘default                                                                    | +0â€¯ns (inlined jump)   |

| HSMÂ historyÂ deep                                                                         | +0.07â€¯ns (odczyt pola) |

| Generator czas build                                                                     | <45â€¯ms przy 2k stanÃ³w  |

| Benchmarki uruchamiaj `BenchmarkDotNet` wÂ konfiguracji \*InProcess\*â€¯+â€¯`AllowUnsafe=True`. |                        |



---



\## 4Â Â·Â Plan wdroÅ¼enia



1\. \*\*Parser atrybutÃ³w\*\* (`State`, `SubState`, `History`)

2\. \*\*Budowa grafu iÂ detekcja cykli\*\*

3\. \*\*Generator kodu flattening\*\*

4\. \*\*Diagnostyki Roslyn\*\*

5\. \*\*Benchmarky iÂ Regression CI\*\*

6\. \*\*Dokumentacja iÂ diagramy Mermaid\*\* (export via generator)



---



\## 5Â Â·Â MateriaÅ‚y do dokumentacji / bloga



\* KrÃ³tkie wprowadzenie do HSM (diagram UML)Â (\[uml-diagrams.org](https://www.uml-diagrams.org/state-machine-diagrams.html?utm\_source=chatgpt.com)).

\* PorÃ³wnanie zÂ podejÅ›ciem \*dummy state\* wÂ StatelessÂ (\[stackoverflow.com](https://stackoverflow.com/questions/24798110/stateless-how-to-define-the-initial-substate-of-a-state?utm\_source=chatgpt.com)).

\* Wskazanie korzyÅ›ci compileâ€‘time vs runtime (przykÅ‚ad JSON/Logger source generator)Â (\[andrewlock.net](https://andrewlock.net/exploring-dotnet-6-part-8-improving-logging-performance-with-source-generators/?utm\_source=chatgpt.com)).

\* Link do wpisu oÂ zerowych alokacjach wÂ C#Â (\[andrebaltieri.com](https://andrebaltieri.com/zero-allocation-techniques-in-csharp-using-ref-struct-and-readonly-struct/?utm\_source=chatgpt.com)).



> \*\*NextÂ step:\*\*Â Po merge gaÅ‚Ä™zi `feature/hsm` oznacz \*tagÂ v0.7.0â€‘preview\* iÂ opublikuj paczkÄ™ naÂ NuGetÂ `FastFsm` zÂ przydrostkiem `-beta`. ğŸ



