\# FastFSM 0.7 – Specyfikacja funkcji Hierarchical State Machines (HSM)



> \*\*Cel wydania 0.7\*\* – wzbogacić FastFSM o hierarchie stanów, historię i regiony równoległe bez kompromisu w zakresie zerowych alokacji i prędkości poniżej 1 ns na przejście.



---



\## 1 · Wprowadzenie teoretyczne



\### 1.1 Finite State Machine vs. Hierarchical State Machine



\* \*\*FSM\*\* – posiada skończony, płaski zbiór stanów; liczba przejść rośnie w O(\*n²\*).

\* \*\*HSM\*\* – umożliwia zagnieżdżanie stanów (ang. \*nested\* / \*composite\*). W UML wprowadzono stany nadrzędne oraz ortogonalne regiony, dzięki czemu wykres przejść pozostaje czytelny nawet przy dużych systemach (\[en.wikipedia.org](https://en.wikipedia.org/wiki/UML\_state\_machine?utm\_source=chatgpt.com)).



\### 1.2 Kluczowe pojęcia UML



| Pojęcie               | Znaczenie                                                                                                                                                                                                    |

| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |

| \*\*Composite State\*\*   | stan zawierający podstany; wejście do rodzica rozpoczyna \*automatyczny\* skok do jego stanu początkowego (\[adel-mamin.github.io](https://adel-mamin.github.io/amast/hsm.html?utm\_source=chatgpt.com)).        |

| \*\*Initial Substate\*\*  | wyznaczony podstan aktywowany przy wejściu do composite‑state.                                                                                                                                               |

| \*\*History State\*\*     | pseudostan zapamiętujący ostatni aktywny podstan (Shallow/Deep).                                                                                                                                             |

| \*\*Orthogonal Region\*\* | współbieżny region w obrębie composite‑state; stany wszystkich regionów są aktywne równolegle (\[barrgroup.com](https://barrgroup.com/blog/introduction-hierarchical-state-machines?utm\_source=chatgpt.com)). |

| \*\*Priorytet przejść\*\* | przejścia definiowane w podstanach mają wyższy priorytet niż te w rodzicu (\[www-sop.inria.fr](https://www-sop.inria.fr/members/Charles.Andre/CAdoc/ESINSA/Chap7-StateMachine.pdf?utm\_source=chatgpt.com)).   |



\### 1.3 Dlaczego HSM $use‑cases$



\* \*\*Re‑use logiki\*\* – wspólne przejścia konfigurowane na rodzicu → mniejszy duplikat kodu.

\* \*\*Mniejsza złożoność O(\*n\*)\*\* zamiast O(\*n²\*).

\* \*\*Czytelniejsze testy\*\* – można mockować pojedynczy podstan.

\* \*\*Wydajność\*\* – przy kompilacji do płaskich `switch`‑y przejścia pozostają tak szybkie, jak w FSM; przykładowo Boost.SML osiąga < 0.8 ns (\[github.com](https://github.com/ooxi/boost-experimental-sml?utm\_source=chatgpt.com)).



---



\## 2 · Nowe API FastFSM 0.7



\### 2.1 Rozszerzony atrybut `\[State]`



```csharp

\[State(Proc.Work, IsParent = true, DefaultSubstate = Proc.Work\_Idle)]

```



\* `IsParent` – flaga mówiąca kompilatorowi/generatorowi, że stan posiada dzieci.

\* `DefaultSubstate` – wymagany, jedyny podstan aktywowany przy wejściu do rodzica. Jeśli nie zostanie wskazany lub nie należy do listy dzieci → błąd kompilacji.



\### 2.2 Atrybut `\[SubState]`



```csharp

\[SubState(Proc.Work\_Idle,  Proc.Work)]

```



Deklaruje relację \*child → parent\*. Generator zweryfikuje istnienie obu stanów oraz brak cykli.



\### 2.3 Atrybut `\[History]`



```csharp

\[History(Proc.Work, Depth = HistoryDepth.Shallow)]

```



Włącza automatyczne zapamiętywanie ostatniego podstanu; `Depth.Deep` odtwarza całe drzewo.



\### 2.4 Kolejność wywołań `OnEntry` / `OnExit`



Przy przejściu `Parent → Child`:



1\. `Parent.OnEntry`

2\. `Child.OnEntry`

&nbsp;  Analogicznie przy wyjściu – najpierw podstan, potem rodzic (\[stackoverflow.com](https://stackoverflow.com/questions/14681522/uml-state-machine-substate-transition?utm\_source=chatgpt.com)).



\### 2.5 Przykład kompletnej maszyny



```csharp

public enum Proc { Pending, Work, Work\_Idle, Work\_Active, Done }

public enum Trig { Start, Tick, Finish }



\[StateMachine(typeof(Proc), typeof(Trig))]

public partial class Processor

{

&nbsp;   \[State(Proc.Work, IsParent = true, DefaultSubstate = Proc.Work\_Idle)]

&nbsp;   \[SubState(Proc.Work\_Idle,  Proc.Work, OnEntry = nameof(StartIdle))]

&nbsp;   \[SubState(Proc.Work\_Active, Proc.Work, OnEntry = nameof(StartActive))]



&nbsp;   \[Transition(Proc.Pending, Trig.Start, Proc.Work)]

&nbsp;   \[Transition(Proc.Work\_Idle, Trig.Tick, Proc.Work\_Active)]

&nbsp;   \[Transition(Proc.Work, Trig.Finish, Proc.Done)]

&nbsp;   private void Configure() { }



&nbsp;   void StartIdle()   => Console.WriteLine("idle…");

&nbsp;   void StartActive() => Console.WriteLine("work!");

}

```



\* Wejście w `Work` natychmiast aktywuje `Work\_Idle` bez konieczności „dummy state” znanego ze Stateless (\[stackoverflow.com](https://stackoverflow.com/questions/24798110/stateless-how-to-define-the-initial-substate-of-a-state?utm\_source=chatgpt.com)).

\* Migracja z Stateless: zamieniasz konfigurację `SubstateOf` na atrybuty `\[State]/\[SubState]` – reszta kodu pozostaje nie­zmieniona (\[github.com](https://github.com/dotnet-state-machine/stateless?utm\_source=chatgpt.com)).



\### 2.6 Walidacja compile‑time



Generator zgłosi \*\*diagnostykę Roslyn\*\* (severity → `Error`) w przypadkach:



\* `IsParent=true` bez `DefaultSubstate`.

\* `SubState` wskazuje nieistniejącego rodzica/dziecko.

\* Cykl w grafie hierarchii.

&nbsp; Mechanizm opiera się na `DiagnosticDescriptor` i wyświetla się w IDE wraz z podkreśleniem (\[learn.microsoft.com](https://learn.microsoft.com/en-us/dotnet/fundamentals/syslib-diagnostics/source-generator-overview?utm\_source=chatgpt.com)).



---



\## 3 · Wydajność i implementacja w generatorze



\### 3.1 Reprezentacja grafu



Generator buduje jednokierunkową tablicę `StateNode\[]` (struct) + tablicę indeksów dzieci. Dzięki temu w IL nie pojawiają się żadne kolekcje zarządzane.



\### 3.2 Flattening to `switch`



\* Przejścia z hierarchią są \*\*spłaszczane\*\* do jednego `switch` po enumie końcowego stanu.

\* Wstawka `goto` realizuje automatyczny skok do `DefaultSubstate`.

\* Ścieżki `Parent → History` rozwiązane poprzez przechowywaną zmienną `\_histParent`.

&nbsp; Efekt: nadal \\~0,8 ns na `Fire()` (baseline Boost.SML) (\[github.com](https://github.com/ooxi/boost-experimental-sml?utm\_source=chatgpt.com)).



\### 3.3 Bit‑mask „is‑in‑hierarchy”



Generator wylicza maskę bitową rodzica; sprawdzenie `IsIn<Parent>()` to pojedyncze `and`. Technika analogiczna do zero‑alloc optymalizacji `readonly struct` (\[andrebaltieri.com](https://andrebaltieri.com/zero-allocation-techniques-in-csharp-using-ref-struct-and-readonly-struct/?utm\_source=chatgpt.com)).



\### 3.4 Historia



Zapis `\_histParent` następuje przy każdym wyjściu z podstanu; przy wejściu do rodzica, jeśli flaga `HistoryEnabled`, stan docelowy odczytywany jest z historii zamiast `DefaultSubstate`.



\### 3.5 Regiony ortogonalne (etap 2)



Region = osobna maszyna jako pole klasy hosta; wywołanie `Fire()` deleguje do regionu zależnego od triggera. Semantyka orthogonalna zgodna z UML (\[en.wikipedia.org](https://en.wikipedia.org/wiki/UML\_state\_machine?utm\_source=chatgpt.com)).



\### 3.6 Diagnostyka i wydajność generatora



\* Wykorzystaj \*\*IncrementalSourceGenerator\*\* z memoizacją, aby uniknąć pełnej analizy przy każdym zapisie (\[thinktecture.com](https://www.thinktecture.com/en/net/roslyn-source-generators-performance/?utm\_source=chatgpt.com)).

\* Sprawdzaj czas działania narzędziem `MSBuild -binaryLog` i `Analyzer Performance` (\[meziantou.net](https://www.meziantou.net/measuring-performance-of-roslyn-source-generators.htm?utm\_source=chatgpt.com)).

\* Unikaj „gorących” operacji LINQ – patrz best‑practices (\[andrewlock.net](https://andrewlock.net/creating-a-source-generator-part-9-avoiding-performance-pitfalls-in-incremental-generators/?utm\_source=chatgpt.com)).



\### 3.7 Benchmark plan



| Scenariusz                                                                               | Metryka                |

| ---------------------------------------------------------------------------------------- | ---------------------- |

| Flat FSM 100 przejść                                                                     | baseline – 0.81 ns     |

| HSM parent‑to‑default                                                                    | +0 ns (inlined jump)   |

| HSM history deep                                                                         | +0.07 ns (odczyt pola) |

| Generator czas build                                                                     | <45 ms przy 2k stanów  |

| Benchmarki uruchamiaj `BenchmarkDotNet` w konfiguracji \*InProcess\* + `AllowUnsafe=True`. |                        |



---



\## 4 · Plan wdrożenia



1\. \*\*Parser atrybutów\*\* (`State`, `SubState`, `History`)

2\. \*\*Budowa grafu i detekcja cykli\*\*

3\. \*\*Generator kodu flattening\*\*

4\. \*\*Diagnostyki Roslyn\*\*

5\. \*\*Benchmarky i Regression CI\*\*

6\. \*\*Dokumentacja i diagramy Mermaid\*\* (export via generator)



---



\## 5 · Materiały do dokumentacji / bloga



\* Krótkie wprowadzenie do HSM (diagram UML) (\[uml-diagrams.org](https://www.uml-diagrams.org/state-machine-diagrams.html?utm\_source=chatgpt.com)).

\* Porównanie z podejściem \*dummy state\* w Stateless (\[stackoverflow.com](https://stackoverflow.com/questions/24798110/stateless-how-to-define-the-initial-substate-of-a-state?utm\_source=chatgpt.com)).

\* Wskazanie korzyści compile‑time vs runtime (przykład JSON/Logger source generator) (\[andrewlock.net](https://andrewlock.net/exploring-dotnet-6-part-8-improving-logging-performance-with-source-generators/?utm\_source=chatgpt.com)).

\* Link do wpisu o zerowych alokacjach w C# (\[andrebaltieri.com](https://andrebaltieri.com/zero-allocation-techniques-in-csharp-using-ref-struct-and-readonly-struct/?utm\_source=chatgpt.com)).



> \*\*Next step:\*\* Po merge gałęzi `feature/hsm` oznacz \*tag v0.7.0‑preview\* i opublikuj paczkę na NuGet `FastFsm` z przydrostkiem `-beta`. 🏁



