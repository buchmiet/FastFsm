# FastFSM 0.8 – Refaktoryzacja generatora na „features” – Specyfikacja implementacyjna

> Cel wydania 0.8 – uprościć architekturę generatora (odejście od wariantów na rzecz cech/„features”), zachować wydajność i ergonomię API, oraz zamrozić publiczne API na poziomie „production‑ready”. Od wersji 0.8 kolejne funkcjonalności nadbudowują istniejące API bez jego łamania.

---

## 1. Podsumowanie zmian w 0.8

- Architektura generatorów uproszczona: „warianty” zastąpione przez cechy (features) w jednym generatorze.
- Wprowadzono `UnifiedStateMachineGenerator` obsługujący wszystkie kombinacje cech przez flagi w modelu.
- Usunięto stare klasy wariantów (Core/Payload/Extensions/Full) i dziedziczenie między nimi.
- Uporządkowano kolejność hooków rozszerzeń (Extensions) zgodnie z UML run‑to‑completion.
- Ujednolicono generowanie kodu (sync/async, payload/single/multi, flat/HSM) bez rozgałęzień na poziomie klas.
- Zredukowano rozmiar kluczowych klas generatora ~o połowę; zniknęła zbędna złożoność.
- Ustandaryzowano kontrolę wcięć: generatory używają `IndentedStringBuilder` i `using sb.Block(...)` – brak ręcznego zarządzania odstępami.
- Oczyszczono diagnostykę: brak intruzywnych komunikatów w generatorach/parserach; diagnozy przechodzą przez scentralizowane reguły.
- Brak zmian w publicznym sposobie definiowania maszyn – zmiany dotyczą wyłącznie implementacji generatora i jakości wygenerowanego kodu.

---

## 2. Architektura po refaktoryzacji

### 2.1 Z „wariantów” na „features”
Zamiast osobnych klas generatorów wariantów, pojedynczy `UnifiedStateMachineGenerator` włącza fragmenty generacji warunkowo, bazując na:
- `HasOnEntryExit` – czy emitować OnEntry/OnExit,
- `HasPayload` i `HasMultiPayload` – payload (pojedynczy/typu wielokrotnego),
- `HasExtensions` – integracja z rozszerzeniami,
- `IsAsyncMachine` – ścieżki async/await z `ValueTask`,
- `HierarchyEnabled` – funkcje HSM (Parent/IsInitial/History, itp.).

Efekt: mniej klas, brak dziedziczenia, jedna ścieżka generacji z czytelnymi if‑ami od cech.

### 2.2 Usunięte elementy
- Usunięte: `CoreVariantGenerator`, `PayloadVariantGenerator`, `ExtensionsVariantGenerator`, `FullVariantGenerator` (kod przeniesiony do Unified).
- W `Generator.cs` używany jest wyłącznie `UnifiedStateMachineGenerator`.
- Ewentualne pozostałości po „variant” (np. enumy, stare modele) są przeznaczone do wyczyszczenia w ramach zamknięcia 0.8 (lista w sekcji 7).
 - Usunięto `VariantSelector` i wszystkie ścieżki jego użycia (Parser/Generator).
 - Usunięto atrybut i enum wymuszania wariantów: `GenerationModeAttribute` oraz `GenerationMode` (brak zewnętrznego API związanego z wariantami).
 - Usunięto `GenerationVariant` z modelu generatora (`GenerationConfig`, `StateMachineModel`, DTO DI). Bramkowanie odbywa się wyłącznie po cechach (`HasOnEntryExit`, `HasPayload`, `HasExtensions`, `HierarchyEnabled`).

### 2.3 Indentation/whitespace – standard
- Generatory używają wyłącznie `IndentedStringBuilder`.
- Bloki emitujemy przez `using sb.Block("header")` albo `using sb.Block(null)` – żadnych ręcznych `\t`/spacji.
- Przykład:
  ```csharp
  using (Sb.Block("try"))
  {
      Sb.AppendLine("// code");
  }
  using (Sb.Block("catch (Exception ex) when (ex is not System.OperationCanceledException)"))
  {
      Sb.AppendLine("// error path");
  }
  ```

---

## 3. Zachowanie funkcji i API

### 3.1 Bez zmian w definicji maszyn
- Atrybuty `[StateMachine]`, `[State]`, `[Transition]`, `[InternalTransition]` – bez zmian.
- HSM: Parent/IsInitial/History – bez zmian w semantyce.
- Payload: zasady jak w 0.7 – w tym multi‑payload i walidacja typu payload „upfront”.
- Async: `ValueTask`, poprawne `ConfigureAwait`, propagacja `OperationCanceledException`.

### 3.2 Kolejność hooków Extensions (UML)
- Kolejność: Before → GuardEvaluation → GuardEvaluated → Exit → Action → State change → Entry → After(success/fail).
- Guard=false: `After(false)`.
- Wyjątek w Exit/Action/Entry: `After(false)`.
- Hooki guarda nie są emitowane w `CanFire/GetPermittedTriggers`.

### 3.3 OnEntry startowe a payload
- Startowe `OnEntry` wywołuje wyłącznie przeciążenia bezparametrowe (`OnEntry()`), również w HSM (łańcuch rodzic→dziecko).

---

## 4. Implementacja w generatorze (skrót)

- Klasa: `Generator/SourceGenerators/UnifiedStateMachineGenerator.cs`.
- Interfejs/baza wybierane dynamicznie: rozszerzalne vs zwykłe, sync vs async.
- Payload: generowane publiczne przeciążenia `TryFire/Fire` (też generyczne dla multi‑payload), mapa `trigger→type` do walidacji typu.
- HSM: generowane tablice `s_parent`, `s_initialChild`, maski hierarchii oraz metody wspierające (np. `IsInHierarchy(...)`), inicjalizacja historii w konstruktorze.
- Async: spójna obsługa `CancellationToken` i `ConfigureAwait`, ścieżka błędów zachowuje stan.
- Extensions: `_ext.WriteFields(...)`, `_ext.WriteManagementMethods(...)` oraz spójna kolejność hooków w ścieżkach sync/async.
- Logowanie (opcjonalne): zgodnie z istniejącym schematem loggera; brak dodatkowych/intruzywnych logów w generatorach.

---

## 5. Diagnostyka i zgodność z .NET

### 5.1 Diagnostyka (generator/parsers)
- Brak intruzywnej diagnostyki w generatorach i parserach (brak `Console.*`, brak „gadatliwości” w Release).
- Diagnozy przechodzą przez `Generator.Rules` (zdefiniowane ID, severity, opisy). Wymagane: centralne użycie reguł (FSMxxx) z czytelnymi komunikatami.

### 5.2 Zgodność z wytycznymi .NET
- Generowany kod nie emituje ostrzeżeń kompilatora (weryfikowany z włączonymi analizatorami – zalecenie: `TreatWarningsAsErrors=true` w CI na repo FastFSM).
- Async: `ValueTask` w hot‑paths, `ConfigureAwait` honoruje `ContinueOnCapturedContext`.
- Nullability: generowany kod nie powinien naruszać adnotacji (brak niepotrzebnych `!`, bezpieczne rzutowania payload).
- Styl: brak zbędnych `#pragma`, brak generowania nieużywanych pól/metod.

---

## 6. Wydajność i charakterystyka

- Zerowe alokacje utrzymane; przejścia pozostają płaskimi `switch`‑ami.
- Ścieżki HSM zachowują optymalizacje (maski bitowe ≤64 stanów, tablice dla >64).
- Łańcuch wyjść/wejść (Exit/Entry) i akcje nie generują alokacji; w async używamy `ValueTask`.
- Rozmiar kodu generatora zmniejszony ~o połowę; prostsza ścieżka utrudnia wprowadzenie regresji.

---

## 7. Zadania do domknięcia 0.8 (blockery „production‑ready”)

- Testy: wszystkie istniejące muszą przechodzić. — ZROBIONE (sync/async zielone)
- Pokrycie: zapewnić testy dla wszystkich kombinacji cech (flat/HSM × sync/async × payload single/multi × extensions on/off) z walidacją logiki. — ZROBIONE (pokrycie wg Features)
- Porządki po wariantach: — ZROBIONE
  - Usunięto pozostałości architektury „variants” (VariantSelector, atrybuty wymuszania, typy „GenerationVariant” i bramkowanie po wariancie);
  - Zaktualizowano testy (feature-based) i README (Migracja 0.8). Uzupełnienie `api.md` — W TOKU.
- Brak ostrzeżeń: wygenerowany kod nie emituje żadnych warnings (Release + włączone analizatory). — W TOKU (weryfikacja w CI)
- Whitespace/indentacja: wszędzie `IndentedStringBuilder` + `using sb.Block(...)`; brak ręcznej kontroli wcięć. — ZACHOWANE
- Zalecenia .NET: końcowy kod zgodny z aktualnymi rekomendacjami (.NET analyzers, async, nullability, brak nieużywanych członów). — ZACHOWANE
- Diagnostyka: w generatorach/parserach brak intruzywnej diagnostyki; wyłącznie reguły z `Generator.Rules`. — ZACHOWANE

---

## 8. Kryteria akceptacyjne 0.8

- API „zamrożone”: brak zmian łamiących w atrybutach i runtime API; 0.8 oznaczona jako „production‑ready”.
- 100% testów zielonych (w tym async/HSM/payload/multi/DI/logging/extensions). — SPEŁNIONE (na poziomie projektów FSM)
- Pokrycie testami obejmuje wszystkie konfiguracje cech. — SPEŁNIONE
- Brak ostrzeżeń w wygenerowanym kodzie (Release + analyzers). — DO POTWIERDZENIA W CI
- Repo wolne od kodu „wariantów” (w tym wymuszeń i typów): generator, parser, DI. — SPEŁNIONE
- Dokumentacja i testy używają pojęcia „features”. — W TOKU (pełne domknięcie w `api.md`)
- Kod generatora nie używa ręcznego zarządzania wcięciami. — SPEŁNIONE
- Brak intruzywnej diagnostyki w generatorze i parserach. — SPEŁNIONE

---

## 9. Migracja 0.7 → 0.8

- Użytkownicy API: brak zmian koniecznych – atrybuty i wzorce użycia pozostają.
- Kontrybutorzy generatora:
  - Prace wykonujemy w `UnifiedStateMachineGenerator` + helpery (`GuardGenerationHelper`, `CallbackGenerationHelper`, `ExtensionsFeatureWriter`, `AsyncGenerationHelper`, itp.).
  - Testy powinny być pogrupowane według cech (features), a nie „wariantów”.
  - Dokumentację (`api.md`, README) należy zaktualizować – sekcje „Variants” → „Features”.

---

## 10. Status implementacji (na bazie refactor.md)

- Faza 1: UnifiedStateMachineGenerator – zakończona.
- Faza 2: Core/Basic w Unified – zakończona.
- Faza 3: Payload (single/multi, sync/async, flat/HSM) – zakończona.
- Faza 4: Extensions – zakończona (kolejność hooków, `OnGuardEvaluated`).
- Faza 5: Full – zakończona (wszystkie kombinacje cech w Unified).
- Faza 6: Usunięcie starych generatorów wariantów – zakończona.
- Faza 7: Porządki/opt – ZAKOŃCZONA (usunięto VariantSelector, GenerationMode, GenerationVariant; feature‑gating kompletny).

---

## 11. Dodatkowe szczegóły implementacyjne

### 11.1 Start/OnInitialEntry
- Dla HSM budowany jest łańcuch wejścia rodzic→dziecko; wywoływane tylko bezparametrowe `OnEntry()`.
- Async: odpowiednik `OnInitialEntryAsync(CancellationToken)` z poprawnym `ConfigureAwait`.

### 11.2 TryFire/Fire – multi‑payload
- Dla multi‑payload oceń typ payload na wejściu (słownik `trigger→type`).
- W przypadku błędnego typu: szybkie zakończenie (opcjonalny warning log), brak alokacji pośrednich.

### 11.3 Hierarchia (HSM)
- Emisja struktur rodzic/dziecko i masek – tylko gdy `HierarchyEnabled`.
- `IsInHierarchy(state)` i pomocnicze metody generowane warunkowo.

### 11.4 Async + anulowanie
- Anulowanie (OperationCanceledException) nie zmienia stanu; wyjątki propagują się zgodnie z konwencją.
- `ContinueOnCapturedContext` respektowany w całej ścieżce.

---

## 14. Architektura Generatora (po refaktorze)

Poniżej pełny, praktyczny opis działania generatora po przejściu z „wariantów” na „features”. Ma on zastąpić wcześniejsze mentalne modele „Variant Generatorów” i stać się punktem odniesienia dla współtwórców i użytkowników API.

### 14.1 Cele
- Minimalny, jednorodny punkt wejścia: jeden generator obsługujący wszystkie cechy.
- Emisja wyłącznie potrzebnego kodu (feature gating) bez rozgałęzień klasowych.
- Zachowanie bezalokacyjnych, płaskich ścieżek wykonania oraz deterministycznych reguł rozstrzygania.

### 14.2 Pipeline (od atrybutów do kodu)
- Parsery: zbierają z atrybutów pełny obraz maszyny (stany, przejścia, guards, callbacks, HSM Parent/IsInitial/History, payloady oraz sygnatury metod).
- Model (`StateMachineModel`): spina wszystko razem – typy `TState/TTrigger`, słowniki stanów, lista przejść, flagi cech (`HasPayload`, `HasExtensions`, `HierarchyEnabled`, `IsAsyncMachine`, `HasMultiPayload`), konfiguracje (logging, DI, `ContinueOnCapturedContext`).
- Planowanie (HSM): wyliczane tablice rodziców, dzieci, masek i historii; przygotowanie danych do emisyjnego flatteningu.
- Emisja (`UnifiedStateMachineGenerator` + helpery): dobór fragmentów w zależności od cech i złożenie pliku wynikowego (interfejs, klasa, pola, metody runtime, ścieżki TryFire/Fire/CanFire/GetPermittedTriggers/IsIn itp.).

### 14.3 Feature Gating – które fragmenty są emitowane
- Payload: dodatkowe przeciążenia `TryFire/Fire/CanFire` dla jednego typu lub `TPayload` (multi). W multi generujemy mapę `trigger→type` i walidację typu upfront.
- Extensions: pola `_extensions`, runner i hooki w ściśle określonej kolejności (UML) – Before → GuardEvaluation → GuardEvaluated → Exit → Action → State change → Entry → After.
- Async: metody zwracają `ValueTask`/`Task`, poprawne `ConfigureAwait(ContinueOnCapturedContext)` i propagacja `OperationCanceledException`; dla async maszyn także „sync wrappers” rzucające `SyncCallOnAsyncMachineException` (np. `CanFire(trigger, payload)`), aby API było spójne i przewidywalne.
- HSM: pola i metody hierarchiczne (tablice `s_parent/s_initialChild`, historia, `IsIn`, `GetActivePath`, DEBUG `DumpActivePath`), specjalne ścieżki CanFire/GetPermitted oraz TryFire z selekcją zwycięzcy (patrz 14.5–14.6).
- Logging/DI: emitowane tylko gdy włączone. Brak intruzywnych logów w generatorze; logowanie w wygenerowanym runtime.

### 14.4 Emisja TryFire/Fire – płaskie FSM
- Dla płaskich maszyn generujemy prosty `switch(currentState){ switch(trigger){ ... } }`.
- Kolejność: Guard → (OnExit) → State change → (OnEntry) → Action → Success/AfterHook.
- Dla extensions kolejność pozostaje zgodna z UML (Action przed OnEntry), z After(success/fail) i hookami guardów.
- Warianty payloadowe emitują odgałęzienia do właściwych przeciążeń/zamian typów bez alokacji.

### 14.5 Emisja TryFire/Fire – HSM (selektor zwycięzcy)
- Generator buduje inline „selektor zwycięzcy” bez funkcji lokalnych/goto:
  - Przechodzimy po bieżącym stanie i jego rodzicach (parent chain) – „od liścia do korzenia”.
  - Dla par (state, trigger) budujemy kandydata: Priority, głębokość względem bieżącego (child ma przewagę), kolejność deklaracji (break-tie).
  - W async przechowujemy najlepszą akcję jako `Func<ValueTask>? bestActionAsync` i `await`ujemy ją po wyborze zwycięzcy; w sync jako `Action? bestAction`.
  - Guardy (jeżeli są) są oceniane na etapie kandydatury; brak zgodnej sygnatury → kandydat odrzucony.
  - Zewnętrzna tranzycja: przed zmianą stanu zapisujemy historię (jeśli włączona) i wchodzimy do złożonego celu (Initial/History) przez `GetCompositeEntryTarget`.

Reguły rozstrzygania:
- Wyższy `Priority` wygrywa; przy remisie bliżej aktualnego (child nad parentem); przy dalszym remisie wygrywa wcześniejsza deklaracja.
- Internal transitions nie zmieniają stanu; wykonują tylko akcję (await/try-catch w async) i zwracają sukces.

### 14.6 CanFire/GetPermittedTriggers – flat i HSM
- Flat: `CanFireInternal[Async]` to po prostu analiza guardów w gałęziach aktualnego stanu/triggera.
- HSM: unia triggerów – generator łączy wynik dla bieżącego stanu i wszystkich przodków (dziecko dziedziczy przejścia rodzica). W async guardy są oceniane w try/catch (opcjonalnie z rozdzielnym traktowaniem anulowania), a `GetPermittedTriggersInternalAsync` zwraca listę triggerów dozwolonych dla bieżącego liścia z uwzględnieniem rodzica.
- Payload-resolver: dla maszyn z payloadem dostępne są przeciążenia `GetPermittedTriggersAsync(Func<TTrigger, object?> resolver, CancellationToken)` (async) i `GetPermittedTriggers(Func<TTrigger, object?>)` (sync), które dynamicznie dostarczają payload do guardów per-trigger.

### 14.7 Guards i Callbacks – rozpoznawanie przeciążeń
- Analiza sygnatur (sync/async, payload/token/parameterless) i wybór „najlepszej” wersji funkcji: preferencje Payload+Token > Payload > Token > Parameterless.
- Dla multi‑payload generujemy ścieżki rzutowań i awaryjne fallbacki zgodnie z dostępnymi przeciążeniami.
- Dla async generator zawsze `await`uje asynchroniczne action/entry/exit; w ścieżkach, gdzie akceptujemy sync callback w async maszynie, wywołanie odbywa się synchronicznie bez alokacji.

### 14.8 Białe znaki i formatowanie
- Cały kod generowany jest przez `IndentedStringBuilder` i „blokowy” wzorzec `using (sb.Block("header")) { ... }`. Nie ma ręcznego sterowania wcięciami.

### 14.9 Diagnostyka
- Generator nie wypisuje intruzywnych logów; wszystkie diagnozy przechodzą przez `Generator.Rules` (FSMxxx), a wygenerowany runtime używa loggera (jeśli włączony).

### 14.10 Wydajność i brak alokacji
- Płaskie `switch`‑e, brak struktur alokujących na ścieżce wykonania, `ValueTask` w async, hierarchia spłaszczona do tablic i prostych operacji.

---

## 12. Plan testów (skrót)

- Macierz cech: flat/HSM × sync/async × payload (none/single/multi) × extensions (off/on).
- Scenariusze: Guards/Actions/OnEntry/OnExit, InternalTransition, priorytety, Enum‑only fallback, historia HSM (shallow/deep), anulowanie w async (na Exit/Action/Entry), DI/logging.
- Dodatkowo: brak ostrzeżeń w Release (kompilacja próbna, analyzers on), brak alokacji runtime (próbki benchmarkowe bez regresji względem 0.7).

---

## 13. Release notes (0.8)

- Uproszczona architektura generatora (features zamiast variants) – mniej klas, lepsza utrzymywalność.
- Zachowane gwarancje wydajności i zero‑alloc dla wszystkich ścieżek.
- Stabilizacja API – 0.8 jako pierwsze „production‑ready” (zamrożone publiczne API).
- Standaryzacja whitespace/indentacji w generatorach.
- Brak intruzywnej diagnostyki – przejrzyste, scentralizowane reguły.
- Porządki i spójność: aktualizacje README/api, porządkowanie testów wg cech.
