# Analiza ostrzeżeń CS0108 - Member Hiding

## Podsumowanie
Ostrzeżenia CS0108 występują, gdy generator kodu tworzy członki w klasie pochodnej, które ukrywają (hide) dziedziczone członki z klasy bazowej bez użycia słowa kluczowego `new`.

## Ostrzeżenia występujące w projekcie

```
WorkflowMachine.s_parent hides inherited member 'StateMachineBase<WorkflowState, WorkflowTrigger>.s_parent'
WorkflowMachine.s_depth hides inherited member 'StateMachineBase<WorkflowState, WorkflowTrigger>.s_depth'
WorkflowMachine.s_initialChild hides inherited member 'StateMachineBase<WorkflowState, WorkflowTrigger>.s_initialChild'
WorkflowMachine.s_history hides inherited member 'StateMachineBase<WorkflowState, WorkflowTrigger>.s_history'
WorkflowMachine._lastActiveChild hides inherited member 'StateMachineBase<WorkflowState, WorkflowTrigger>._lastActiveChild'
WorkflowMachine.GetCompositeEntryTarget(int) hides inherited member 'StateMachineBase<WorkflowState, WorkflowTrigger>.GetCompositeEntryTarget(int)'
```

## Źródło problemu

### 1. Klasa bazowa: StateMachineBase.cs
Lokalizacja: `/FastFsm/Runtime/StateMachineBase.cs`

```csharp
public abstract class StateMachineBase<TState, TTrigger>
{
    // Hierarchical state machine support fields
    protected static int[]? s_parent;  
    protected static int[]? s_depth;   
    protected static int[]? s_initialChild;  
    protected static HistoryMode[]? s_history;  
    protected int[]? _lastActiveChild;  
    
    protected int GetCompositeEntryTarget(int compositeIndex)
    {
        // ... implementacja ...
    }
}
```

### 2. Klasa generowana: WorkflowMachine.Generated.cs
Generator (`StateMachineCodeGenerator.cs`) tworzy te same pola w klasie pochodnej:

```csharp
public partial class WorkflowMachine : StateMachineBase<WorkflowState, WorkflowTrigger>
{
    // Generator tworzy te same pola BEZ słowa 'new'
    private static readonly int[] s_parent = new int[] { ... };
    private static readonly int[] s_depth = new int[] { ... };
    private static readonly int[] s_initialChild = new int[] { ... };
    private static readonly HistoryMode[] s_history = new HistoryMode[] { ... };
    private readonly int[] _lastActiveChild;
    
    protected int GetCompositeEntryTarget(int compositeIndex)
    {
        // ... implementacja specyficzna dla tej maszyny ...
    }
}
```

## Dlaczego tak się dzieje?

### Architektura HSM (Hierarchical State Machines)
1. **Klasa bazowa** definiuje pola jako `protected static` z wartościami `null`
2. **Generator** musi wypełnić te pola konkretnymi wartościami dla każdej maszyny stanowej
3. **Problem**: Generator tworzy NOWE pola zamiast inicjalizować istniejące

### Lokalizacja generowania w kodzie

**Plik**: `/Generator/SourceGenerators/StateMachineCodeGenerator.cs`

Linie 74-115 generują statyczne pola:
```csharp
// Line 74
Sb.Append("        private static readonly int[] s_parent = new int[] { ");

// Line 88
Sb.Append("        private static readonly int[] s_depth = new int[] { ");

// Line 101  
Sb.Append("        private static readonly int[] s_initialChild = new int[] { ");

// Line 115
Sb.Append("        private static readonly HistoryMode[] s_history = new HistoryMode[] { ");
```

Linia 366 generuje pole instancji:
```csharp
Sb.AppendLine("        private readonly int[] _lastActiveChild;");
```

## Dlaczego to problem?

1. **Ukrywanie zamiast nadpisywania**: Nowe pola ukrywają dziedziczone, co może prowadzić do nieoczekiwanego zachowania
2. **Podwójne dane**: Istnieją dwa zestawy tych samych pól (w klasie bazowej i pochodnej)
3. **Potencjalne błędy**: Kod w klasie bazowej może używać swoich pól (null), a nie tych z klasy pochodnej

## Rozwiązania

### Opcja 1: Dodać słowo kluczowe `new` (szybkie)
```csharp
// W StateMachineCodeGenerator.cs
Sb.Append("        private static readonly new int[] s_parent = new int[] { ");
Sb.Append("        private static readonly new int[] s_depth = new int[] { ");
// itd.
```

### Opcja 2: Inicjalizacja w konstruktorze statycznym (lepsze)
Zamiast tworzyć nowe pola, inicjalizować istniejące:
```csharp
static WorkflowMachine()
{
    s_parent = new int[] { ... };
    s_depth = new int[] { ... };
    s_initialChild = new int[] { ... };
    s_history = new HistoryMode[] { ... };
}
```

### Opcja 3: Abstrakcyjne właściwości (najlepsze architektonicznie)
Klasa bazowa mogłaby definiować abstrakcyjne właściwości, które klasy pochodne muszą zaimplementować:
```csharp
// W klasie bazowej
protected abstract int[] ParentArray { get; }
protected abstract int[] DepthArray { get; }
// itd.

// W klasie generowanej
protected override int[] ParentArray => s_parent;
protected override int[] DepthArray => s_depth;
// itd.
```

## Wpływ na działanie

Obecnie ostrzeżenia **nie wpływają** na poprawne działanie kodu, ponieważ:
1. Generator konsekwentnie używa swoich pól
2. Klasa bazowa sprawdza czy pola nie są null przed użyciem
3. Hiding działa "przypadkowo" poprawnie w tym kontekście

Jednak to nie jest dobra praktyka i powinno zostać naprawione.

## Rekomendacja

**Krótkoterminowo**: Dodać słowo kluczowe `new` do generowanych pól (Opcja 1)
**Długoterminowo**: Przeprojektować architekturę na inicjalizację w konstruktorze statycznym (Opcja 2)

## Status
⚠️ **Ostrzeżenia kosmetyczne** - nie wpływają na działanie, ale należy je naprawić dla czystości kodu