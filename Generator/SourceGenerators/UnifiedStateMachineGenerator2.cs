using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Generator.Model;
using Generator.Helpers;
using Generator.Infrastructure;
using IndentedStringBuilder;
using static Generator.Strings;

namespace Generator.SourceGenerators;

/// <summary>
/// Temporary unified generator class for migration - KROK 2
/// </summary>
public sealed class UnifiedStateMachineGenerator2
{
    #region Fields and Properties

    private readonly StateMachineModel Model;
    private readonly UnifiedStateMachineGenerator _delegateGenerator;
    private readonly IndentedStringBuilder.IndentedStringBuilder Sb = new();
    private readonly TypeSystemHelper TypeHelper = new();
    private readonly bool IsAsyncMachine;
    private bool ShouldGenerateLogging;
    private readonly HashSet<string> AddedUsings = new(StringComparer.Ordinal);
    
    // Constants from StateMachineCodeGenerator
    private const string HookVarContext = "smCtx";
    private const string EndOfTryFireLabel = "END_TRY_FIRE";
    
    // From UnifiedStateMachineGenerator
    private readonly ExtensionsFeatureWriter _ext = new();
    private bool HasExtensions => Model.GenerationConfig.HasExtensions;
    private bool ExtensionsOn => HasExtensions || IsExtensionsVariant();
    
    // Additional properties for generation
    private bool HasPayload => IsPayloadVariant();
    private bool HasMultiPayload => Model.TriggerPayloadTypes.Any();
    private bool IsHierarchical => Model.HierarchyEnabled;
    private bool HasOnEntryExit => ShouldGenerateOnEntryExit();
    private string CurrentStateField => IsAsyncMachine ? "CurrentState" : "_currentState";

    #endregion

    public UnifiedStateMachineGenerator2(StateMachineModel model)
    {
        Model = model ?? throw new ArgumentNullException(nameof(model));
        _delegateGenerator = new UnifiedStateMachineGenerator(model);
        IsAsyncMachine = model.GenerationConfig.IsAsync;
        ShouldGenerateLogging = model.GenerateLogging;
    }

    /// <summary>
    /// Main generation method - currently delegates to existing UnifiedStateMachineGenerator
    /// </summary>
    public string Generate()
    {
        // For now, just delegate to existing generator to maintain 1:1 behavior
        return _delegateGenerator.Generate();
    }

    #region Main Generation Methods (Step 3 - Placeholders with delegation)

    private void WriteHeader()
    {
        Sb.AppendLine("// <auto-generated/>");
        Sb.AppendLine("#nullable enable");

        // Standard usings
        AddUsing(NamespaceSystem);
        AddUsing(NamespaceSystemCollectionsGeneric);
        AddUsing(NamespaceSystemLinq);
        AddUsing(NamespaceSystemRuntimeCompilerServices);
        AddUsing(NamespaceStateMachineContracts);
        AddUsing(NamespaceStateMachineRuntime);

        if (IsExtensionsVariant())
        {
            AddUsing(NamespaceStateMachineRuntimeExtensions);
        }

        if (ShouldGenerateLogging)
        {
            AddUsing(NamespaceMicrosoftExtensionsLogging);
        }
        if (IsAsyncMachine)
        {
            AddUsing("System.Threading");
            AddUsing("System.Threading.Tasks");
            AddUsing("StateMachine.Exceptions");
        }
        
        if (Model.ExceptionHandler != null)
        {
            AddUsing(NamespaceStateMachineExceptions);
        }
        
        // Type-specific namespaces
        var allNamespaces = new HashSet<string>();
        allNamespaces.UnionWith(TypeHelper.GetRequiredNamespaces(Model.StateType));
        allNamespaces.UnionWith(TypeHelper.GetRequiredNamespaces(Model.TriggerType));

        if (IsPayloadVariant())
        {
            foreach (var payload in GetAllPayloadTypes())
            {
                allNamespaces.UnionWith(TypeHelper.GetRequiredNamespaces(payload));
            }
        }

        // Filter out standard namespaces and add remaining
        foreach (var ns in allNamespaces.OrderBy(n => n))
        {
            if (ns is NamespaceSystem or NamespaceSystemCollectionsGeneric or
                NamespaceSystemLinq or NamespaceSystemRuntimeCompilerServices or
                NamespaceStateMachineContracts or NamespaceStateMachineRuntime)
                continue;

            AddUsing(ns);
        }

        // Hook for additional usings
        foreach (var ns in GetAdditionalUsings().OrderBy(n => n))
        {
            AddUsing(ns);
        }

        Sb.AppendLine();
    }

    private void WriteNamespaceAndClass()
    {
        var stateTypeForUsage = GetTypeNameForUsage(Model.StateType);
        var triggerTypeForUsage = GetTypeNameForUsage(Model.TriggerType);
        var userNamespace = Model.Namespace;
        var className = Model.ClassName;

        if (!string.IsNullOrEmpty(userNamespace))
        {
            using (Sb.Block($"namespace {userNamespace}"))
            {
                WriteContainingTypesAndClass(className, stateTypeForUsage, triggerTypeForUsage);
            }
        }
        else
        {
            WriteContainingTypesAndClass(className, stateTypeForUsage, triggerTypeForUsage);
        }
    }

    private void WriteContainingTypesAndClass(string className, string stateTypeForUsage, string triggerTypeForUsage)
    {
        // Placeholder - delegates to old logic for now
        // Will be filled in later steps
    }

    // Placeholder methods for Step 3 - will delegate to old implementations
    private void WriteStartMethods()
    {
        // Placeholder - will be filled in later steps
    }

    private void WriteInitialEntryMethods(string stateType)
    {
        // Placeholder - will be filled in later steps
    }

    private void WriteTryFireMethods(string stateType, string triggerType)
    {
        WriteTryFireMethod(stateType, triggerType);
        
        // Additional payload-aware public wrappers will be added in later steps
    }
    
    private void WriteTryFireMethod(string stateType, string triggerType)
    {
        if (IsAsyncMachine)
        {
            WriteTryFireMethodAsync(stateType, triggerType);
        }
        else
        {
            WriteTryFireMethodSync(stateType, triggerType);
        }
    }
    
    private void WriteTryFireMethodAsync(string stateType, string triggerType)
    {
        WriteMethodAttribute();
        using (Sb.Block($"protected override async ValueTask<bool> TryFireInternalAsync({triggerType} trigger, object? payload, CancellationToken cancellationToken = default)"))
        {
            Sb.AppendLine("cancellationToken.ThrowIfCancellationRequested();");
            Sb.AppendLine();
            
            if (!Model.Transitions.Any())
            {
                Sb.AppendLine("return false; // no transitions defined");
                return;
            }
            
            // For multi-payload: validate payload type upfront
            if (HasPayload && HasMultiPayload)
            {
                Sb.AppendLine("// Payload-type validation for multi-payload variant");
                Sb.AppendLine("if (_payloadMap.TryGetValue(trigger, out var expectedType) && (payload == null || !expectedType.IsInstanceOfType(payload)))");
                Sb.AppendLine("{");
                if (ShouldGenerateLogging)
                {
                    Sb.AppendLine("    // Log payload validation failure");
                }
                Sb.AppendLine("    return false; // wrong payload type");
                Sb.AppendLine("}");
                Sb.AppendLine();
            }
            
            Sb.AppendLine($"var originalState = {CurrentStateField};");
            Sb.AppendLine("bool success = false;");
            Sb.AppendLine();
            
            // Use WriteTryFireStructure with appropriate transition logic
            WriteTryFireStructure(stateType, triggerType, (transition, stateType, triggerType) =>
            {
                WriteTransitionLogic(transition, stateType, triggerType, isAsync: true);
            });
            
            Sb.AppendLine("END_TRY_FIRE:;");
            Sb.AppendLine();
            
            // Log failure if needed
            if (ShouldGenerateLogging)
            {
                Sb.AppendLine("if (!success)");
                using (Sb.Block(""))
                {
                    Sb.AppendLine("// Log transition failure");
                }
            }
            
            Sb.AppendLine("return success;");
        }
        Sb.AppendLine();
    }
    
    private void WriteTryFireMethodSync(string stateType, string triggerType)
    {
        WriteMethodAttribute();
        using (Sb.Block($"protected override bool TryFireInternal({triggerType} trigger, object? payload)"))
        {
            if (!Model.Transitions.Any())
            {
                Sb.AppendLine("return false; // no transitions defined");
                return;
            }
            
            // For multi-payload: validate payload type upfront
            if (HasPayload && HasMultiPayload)
            {
                Sb.AppendLine("// Payload-type validation for multi-payload variant");
                Sb.AppendLine("if (_payloadMap.TryGetValue(trigger, out var expectedType) && (payload == null || !expectedType.IsInstanceOfType(payload)))");
                Sb.AppendLine("{");
                if (ShouldGenerateLogging)
                {
                    Sb.AppendLine("    // Log payload validation failure");
                }
                Sb.AppendLine("    return false; // wrong payload type");
                Sb.AppendLine("}");
                Sb.AppendLine();
            }
            
            WriteTryFireStructure(stateType, triggerType, (transition, stateType, triggerType) =>
            {
                WriteTransitionLogic(transition, stateType, triggerType, isAsync: false);
            });
        }
        Sb.AppendLine();
        
        // Generate public wrapper for sync
        WriteMethodAttribute();
        using (Sb.Block($"public override bool TryFire({triggerType} trigger, object? payload = null)"))
        {
            Sb.AppendLine("EnsureStarted();");
            Sb.AppendLine("return TryFireInternal(trigger, payload);");
        }
        Sb.AppendLine();
    }
    
    private void WriteTryFireStructure(
        string stateTypeForUsage,
        string triggerTypeForUsage,
        Action<TransitionModel, string, string> writeTransitionLogic)
    {
        if (ExtensionsOn)
        {
            WriteTryFireStructureWithExtensions(stateTypeForUsage, triggerTypeForUsage, writeTransitionLogic);
        }
        else if (Model.HierarchyEnabled)
        {
            WriteTryFireStructureHierarchical(stateTypeForUsage, triggerTypeForUsage, writeTransitionLogic);
        }
        else
        {
            WriteTryFireStructureFlat(stateTypeForUsage, triggerTypeForUsage, writeTransitionLogic);
        }
    }
    
    private void WriteTryFireStructureWithExtensions(string stateType, string triggerType, Action<TransitionModel, string, string> writeTransitionLogic)
    {
        // Custom implementation that notifies extensions even when no transition is found
        if (!Model.Transitions.Any())
        {
            // No transitions at all - notify extensions and return false
            Sb.AppendLine("// No transitions defined - notify extensions");
            Sb.AppendLine($"var failCtx = new StateMachineContext<{stateType}, {triggerType}>(");
            Sb.AppendLine("    Guid.NewGuid().ToString(),");
            Sb.AppendLine($"    {CurrentStateField},");
            Sb.AppendLine("    trigger,");
            Sb.AppendLine($"    {CurrentStateField},");
            Sb.AppendLine("    payload);");
            Sb.AppendLine("_extensionRunner.RunAfterTransition(_extensions, failCtx, false);");
            Sb.AppendLine("return false;");
            return;
        }
        
        // Generate structure with extension hooks
        var sortedTransitions = Model.Transitions
            .Select((t, index) => new { Transition = t, Index = index })
            .OrderByDescending(x => x.Transition.Priority)
            .ThenBy(x => x.Index)
            .Select(x => x.Transition);
            
        var grouped = sortedTransitions.GroupBy(t => t.FromState);
        
        Sb.AppendLine($"switch ({CurrentStateField}) {{");
        foreach (var state in grouped)
        {
            Sb.AppendLine($"    case {stateType}.{TypeHelper.EscapeIdentifier(state.Key)}: {{");
            
            var triggerGroups = state.GroupBy(t => t.Trigger);
            Sb.AppendLine("        switch (trigger) {");
            
            foreach (var triggerGroup in triggerGroups)
            {
                Sb.AppendLine($"            case {triggerType}.{TypeHelper.EscapeIdentifier(triggerGroup.Key)}: {{");
                
                foreach (var tr in triggerGroup)
                {
                    Sb.AppendLine($"                // Transition: {tr.FromState} -> {tr.ToState} (Priority: {tr.Priority})");
                    writeTransitionLogic(tr, stateType, triggerType);
                    break; // Only first matching transition
                }
                
                Sb.AppendLine("            }");
            }
            
            Sb.AppendLine("            default: break;");
            Sb.AppendLine("        }");
            Sb.AppendLine("        break;");
            Sb.AppendLine("    }");
        }
        Sb.AppendLine("    default: break;");
        Sb.AppendLine("}");
        Sb.AppendLine();
        
        // No transition found - notify extensions
        Sb.AppendLine("// No matching transition - notify extensions");
        Sb.AppendLine($"var noTransitionCtx = new StateMachineContext<{stateType}, {triggerType}>(");
        Sb.AppendLine("    Guid.NewGuid().ToString(),");
        Sb.AppendLine($"    {CurrentStateField},");
        Sb.AppendLine("    trigger,");
        Sb.AppendLine($"    {CurrentStateField},");
        Sb.AppendLine("    payload);");
        Sb.AppendLine("_extensionRunner.RunAfterTransition(_extensions, noTransitionCtx, false);");
        Sb.AppendLine("return false;");
    }
    
    private void WriteTryFireStructureFlat(
        string stateTypeForUsage,
        string triggerTypeForUsage,
        Action<TransitionModel, string, string> writeTransitionLogic)
    {
        // Sort transitions by priority (descending) then by declaration order
        var sortedTransitions = Model.Transitions
            .Select((t, index) => new { Transition = t, Index = index })
            .OrderByDescending(x => x.Transition.Priority)
            .ThenBy(x => x.Index)
            .Select(x => x.Transition);
            
        var grouped = sortedTransitions.GroupBy(t => t.FromState);
        
        // switch (CurrentState)
        using (Sb.Block($"switch ({CurrentStateField})"))
        {
            foreach (var state in grouped)
            {
                // case <State>:
                using (Sb.Block($"case {stateTypeForUsage}.{TypeHelper.EscapeIdentifier(state.Key)}:"))
                {
                    // Group by trigger for this state
                    var triggerGroups = state.GroupBy(t => t.Trigger);
                    
                    // switch (trigger)
                    using (Sb.Block("switch (trigger)"))
                    {
                        foreach (var triggerGroup in triggerGroups)
                        {
                            // case <Trigger>:
                            using (Sb.Block($"case {triggerTypeForUsage}.{TypeHelper.EscapeIdentifier(triggerGroup.Key)}:"))
                            {
                                // Process all transitions for this trigger in priority order
                                foreach (var tr in triggerGroup)
                                {
                                    Sb.AppendLine($"// Transition: {tr.FromState} -> {tr.ToState} (Priority: {tr.Priority})");
                                    writeTransitionLogic(tr, stateTypeForUsage, triggerTypeForUsage);
                                    // Only first matching transition executes due to return
                                    break;
                                }
                            }
                        }
                        Sb.AppendLine("default: break;");
                    }
                    Sb.AppendLine("break;");
                }
            }
            Sb.AppendLine("default: break;");
        }
        
        Sb.AppendLine();
        Sb.AppendLine("return false;");
    }
    
    private void WriteTryFireStructureHierarchical(
        string stateTypeForUsage,
        string triggerTypeForUsage,
        Action<TransitionModel, string, string> writeTransitionLogic)
    {
        // Placeholder for hierarchical implementation - will be filled in later steps
        WriteTryFireStructureFlat(stateTypeForUsage, triggerTypeForUsage, writeTransitionLogic);
    }
    
    private void WriteTransitionLogic(TransitionModel transition, string stateType, string triggerType, bool isAsync)
    {
        // Placeholder - basic transition logic
        // Will be expanded in later steps with full logic
        
        // Guard check
        if (!string.IsNullOrEmpty(transition.GuardMethod))
        {
            if (isAsync)
            {
                Sb.AppendLine($"var guardResult = {transition.GuardMethod}();");
                Sb.AppendLine("if (!guardResult)");
                Sb.AppendLine("{");
                Sb.AppendLine("    success = false;");
                Sb.AppendLine("    goto END_TRY_FIRE;");
                Sb.AppendLine("}");
            }
            else
            {
                WriteGuardCall(transition, "guardResult", "null", throwOnException: false);
                Sb.AppendLine("if (!guardResult) return false;");
            }
        }
        
        // State change
        if (!transition.IsInternal)
        {
            Sb.AppendLine($"{CurrentStateField} = {stateType}.{TypeHelper.EscapeIdentifier(transition.ToState)};");
        }
        
        if (isAsync)
        {
            Sb.AppendLine("success = true;");
            Sb.AppendLine("goto END_TRY_FIRE;");
        }
        else
        {
            Sb.AppendLine("return true;");
        }
    }

    private void WriteFireMethods(string stateType, string triggerType)
    {
        // Placeholder - will be filled in later steps
    }

    private void WriteCanFireMethods(string stateType, string triggerType)
    {
        // Base CanFire without payload
        WriteCanFireMethod(stateType, triggerType);
        
        // Additional payload-aware overloads will be added in later steps
    }
    
    private void WriteCanFireMethod(string stateType, string triggerType)
    {
        if (IsAsyncMachine)
        {
            WriteAsyncCanFireMethod(stateType, triggerType);
        }
        else
        {
            WriteCanFireMethodSyncCore(stateType, triggerType);
        }
    }
    
    private void WriteAsyncCanFireMethod(string stateTypeForUsage, string triggerTypeForUsage)
    {
        Sb.WriteSummary("Asynchronously checks if the specified trigger can be fired in the current state (runtime evaluation including guards)");
        Sb.AppendLine("    /// <param name=\"trigger\">The trigger to check</param>");
        Sb.AppendLine("    /// <param name=\"cancellationToken\">A token to observe for cancellation requests</param>");
        Sb.AppendLine("    /// <returns>True if the trigger can be fired, false otherwise</returns>");

        Sb.AppendLine($"    protected override async ValueTask<bool> CanFireInternalAsync({triggerTypeForUsage} trigger, CancellationToken cancellationToken = default)");
        Sb.AppendLine("    {");
        Sb.AppendLine("        cancellationToken.ThrowIfCancellationRequested();");
        Sb.AppendLine();

        if (Model.HierarchyEnabled)
        {
            Sb.AppendLine($"        int check = (int){CurrentStateField};");
            Sb.AppendLine("        while (check >= 0)");
            Sb.AppendLine("        {");
            Sb.AppendLine($"            var state = ({stateTypeForUsage})check;");
            Sb.AppendLine("            switch (state)");
            Sb.AppendLine("            {");
            var grouped = Model.Transitions.GroupBy(t => t.FromState).OrderBy(g => g.Key);
            foreach (var group in grouped)
            {
                Sb.AppendLine($"                case {stateTypeForUsage}.{TypeHelper.EscapeIdentifier(group.Key)}:");
                Sb.AppendLine("                {");
                Sb.AppendLine("                    switch (trigger)");
                Sb.AppendLine("                    {");
                foreach (var transition in group)
                {
                    Sb.AppendLine($"                        case {triggerTypeForUsage}.{TypeHelper.EscapeIdentifier(transition.Trigger)}:");
                    Sb.AppendLine("                        {");
                    if (!string.IsNullOrEmpty(transition.GuardMethod))
                    {
                        if (transition.GuardIsAsync)
                        {
                            GuardGenerationHelper.EmitGuardCheck(
                                Sb,
                                transition,
                                "guardResult",
                                "null",
                                IsAsyncMachine,
                                wrapInTryCatch: true,
                                Model.ContinueOnCapturedContext,
                                handleResultAfterTry: true,
                                cancellationTokenVar: "cancellationToken",
                                treatCancellationAsFailure: Model.GenerationConfig.TreatCancellationAsFailure
                            );
                        }
                        else
                        {
                            WriteGuardCall(transition, "guardResult", "null", throwOnException: false);
                        }
                        Sb.AppendLine("                            return guardResult;");
                    }
                    else
                    {
                        Sb.AppendLine("                            return true;");
                    }
                    Sb.AppendLine("                        }");
                }
                Sb.AppendLine("                        default: break;");
                Sb.AppendLine("                    }");
                Sb.AppendLine("                    break;");
                Sb.AppendLine("                }");
            }
            Sb.AppendLine("                default: break;");
            Sb.AppendLine("            }");
            Sb.AppendLine("            check = (uint)check < (uint)s_parent.Length ? s_parent[check] : -1;");
            Sb.AppendLine("        }");
            Sb.AppendLine("        return false;");
        }
        else
        {
            Sb.AppendLine($"        switch ({CurrentStateField})");
            Sb.AppendLine("        {");
            var allHandledFromStates = Model.Transitions.Select(t => t.FromState).Distinct().OrderBy(s => s);
            foreach (var stateName in allHandledFromStates)
            {
                Sb.AppendLine($"            case {stateTypeForUsage}.{TypeHelper.EscapeIdentifier(stateName)}:");
                Sb.AppendLine("            {");
                Sb.AppendLine("                switch (trigger)");
                Sb.AppendLine("                {");
                var transitionsFromThisState = Model.Transitions.Where(t => t.FromState == stateName);
                foreach (var transition in transitionsFromThisState)
                {
                    Sb.AppendLine($"                    case {triggerTypeForUsage}.{TypeHelper.EscapeIdentifier(transition.Trigger)}:");
                    Sb.AppendLine("                    {");
                    if (!string.IsNullOrEmpty(transition.GuardMethod))
                    {
                        if (transition.GuardIsAsync)
                        {
                            GuardGenerationHelper.EmitGuardCheck(
                                Sb,
                                transition,
                                "guardResult",
                                "null",
                                IsAsyncMachine,
                                wrapInTryCatch: true,
                                Model.ContinueOnCapturedContext,
                                handleResultAfterTry: true,
                                cancellationTokenVar: "cancellationToken",
                                treatCancellationAsFailure: Model.GenerationConfig.TreatCancellationAsFailure
                            );
                        }
                        else
                        {
                            WriteGuardCall(transition, "guardResult", "null", throwOnException: false);
                        }
                        Sb.AppendLine("                        return guardResult;");
                    }
                    else
                    {
                        Sb.AppendLine("                        return true;");
                    }
                    Sb.AppendLine("                    }");
                }
                Sb.AppendLine("                    default: return false;");
                Sb.AppendLine("                }");
                Sb.AppendLine("            }");
            }
            Sb.AppendLine("            default: return false;");
            Sb.AppendLine("        }");
        }
        Sb.AppendLine("    }");
        Sb.AppendLine();
    }
    
    private void WriteCanFireMethodSyncCore(string stateTypeForUsage, string triggerTypeForUsage)
    {
        Sb.WriteSummary("Checks if the specified trigger can be fired in the current state (runtime evaluation including guards)");
        Sb.AppendLine("/// <param name=\"trigger\">The trigger to check</param>");
        Sb.AppendLine("/// <returns>True if the trigger can be fired, false otherwise</returns>");
        WriteMethodAttribute();
        using (Sb.Block($"protected override bool CanFireInternal({triggerTypeForUsage} trigger)"))
        {
            if (Model.HierarchyEnabled)
            {
                // HSM: Walk up the parent chain
                Sb.AppendLine($"int currentIndex = (int){CurrentStateField};");
                Sb.AppendLine("int check = currentIndex;");
                using (Sb.Block("while (check >= 0)"))
                {
                    Sb.AppendLine($"var enumState = ({stateTypeForUsage})check;");
                    using (Sb.Block("switch (enumState)"))
                    {
                        var allHandledFromStates = Model.Transitions.Select(t => t.FromState).Distinct().OrderBy(s => s);

                        foreach (var stateName in allHandledFromStates)
                        {
                            Sb.AppendLine($"case {stateTypeForUsage}.{TypeHelper.EscapeIdentifier(stateName)}:");
                            using (Sb.Indent())
                            {
                                using (Sb.Block("switch (trigger)"))
                                {
                                    var transitionsFromThisState = Model.Transitions
                                        .Where(t => t.FromState == stateName);

                                    foreach (var transition in transitionsFromThisState)
                                    {
                                        Sb.AppendLine($"case {triggerTypeForUsage}.{TypeHelper.EscapeIdentifier(transition.Trigger)}:");
                                        using (Sb.Indent())
                                        {
                                            if (!string.IsNullOrEmpty(transition.GuardMethod))
                                            {
                                                WriteGuardCall(transition, "guardResult", "null", throwOnException: false);
                                                Sb.AppendLine("return guardResult;");
                                            }
                                            else
                                            {
                                                Sb.AppendLine("return true;");
                                            }
                                        }
                                    }
                                    Sb.AppendLine("default: break;");
                                }
                                Sb.AppendLine("break;");
                            }
                        }
                        Sb.AppendLine("default: break;");
                    }
                    Sb.AppendLine("check = (uint)check < (uint)s_parent.Length ? s_parent[check] : -1;");
                }
                Sb.AppendLine("return false;");
            }
            else
            {
                // Flat FSM: Original implementation
                using (Sb.Block($"switch ({CurrentStateField})"))
                {
                    var allHandledFromStates = Model.Transitions.Select(t => t.FromState).Distinct().OrderBy(s => s);

                    foreach (var stateName in allHandledFromStates)
                    {
                        Sb.AppendLine($"case {stateTypeForUsage}.{TypeHelper.EscapeIdentifier(stateName)}:");
                        using (Sb.Indent())
                        {
                            using (Sb.Block("switch (trigger)"))
                            {
                                var transitionsFromThisState = Model.Transitions
                                    .Where(t => t.FromState == stateName);

                                foreach (var transition in transitionsFromThisState)
                                {
                                    Sb.AppendLine($"case {triggerTypeForUsage}.{TypeHelper.EscapeIdentifier(transition.Trigger)}:");
                                    using (Sb.Indent())
                                    {
                                        if (!string.IsNullOrEmpty(transition.GuardMethod))
                                        {
                                            WriteGuardCall(transition, "guardResult", "null", throwOnException: false);
                                            Sb.AppendLine("return guardResult;");
                                        }
                                        else
                                        {
                                            Sb.AppendLine("return true;");
                                        }
                                    }
                                }
                                Sb.AppendLine("default: return false;");
                            }
                        }
                    }
                    Sb.AppendLine("default: return false;");
                }
            }
        }
        Sb.AppendLine();
    }

    private void WriteGetPermittedTriggersMethods(string stateType, string triggerType)
    {
        // Placeholder - will be filled in later steps
    }

    private void WriteHierarchyMethods(string stateType, string triggerType)
    {
        // Placeholder - will be filled in later steps
    }

    private void WriteStructuralApiMethods(string stateType, string triggerType)
    {
        // Placeholder - will be filled in later steps
    }

    #endregion

    #region Utility Methods (From base classes)

    // TypeName and namespace helpers
    private string GetTypeNameForUsage(string fullyQualifiedName) =>
        TypeHelper.FormatTypeForUsage(fullyQualifiedName, useGlobalPrefix: false);

    private IEnumerable<string> GetAdditionalUsings()
    {
        yield return "System";
        yield return "System.Collections.Generic";

        if (IsAsyncMachine)
        {
            yield return "System.Threading";
            yield return "System.Threading.Tasks";
        }

        // Add namespaces from state and trigger types
        var stateNs = GetNamespaceFromType(Model.StateType);
        var triggerNs = GetNamespaceFromType(Model.TriggerType);
        if (!string.IsNullOrEmpty(stateNs)) yield return stateNs;
        if (!string.IsNullOrEmpty(triggerNs) && triggerNs != stateNs) yield return triggerNs;

        if (Model.HierarchyEnabled)
            yield return "System.Linq";

        if (ShouldGenerateLogging)
        {
            yield return "FastFsm.Logging";
            yield return "System.Diagnostics";
        }
    }

    // Async helpers
    private string GetConfigureAwait() => AsyncGenerationHelper.GetConfigureAwait(IsAsyncMachine, Model.ContinueOnCapturedContext);

    // Variant checking methods
    private bool IsPayloadVariant()
    {
        return Model.GenerationConfig.HasPayload || 
               Model.DefaultPayloadType != null || 
               Model.TriggerPayloadTypes.Any();
    }

    private bool IsExtensionsVariant()
    {
        return Model.GenerationConfig.HasExtensions;
    }

    private bool ShouldGenerateInitialOnEntry()
    {
        // For now, always generate if we have initial state OnEntry
        return Model.States.TryGetValue(Model.GenerationConfig.IsAsync ? "InitialState" : "InitialState", out var initialState) && 
               initialState?.OnEntryMethod != null;
    }

    private bool ShouldGenerateOnEntryExit()
    {
        // Zawsze generujemy jeśli są jakiekolwiek callbacki lub wymagana logika
        return Model.States.Any(s => s.Value.OnEntryMethod != null || s.Value.OnExitMethod != null) ||
               Model.Transitions.Any(t => t.ActionMethod != null) ||
               Model.HierarchyEnabled ||
               ShouldGenerateLogging;
    }

    private HashSet<string> GetAllPayloadTypes()
    {
        var types = new HashSet<string>();
        foreach (var transition in Model.Transitions)
        {
            if (!string.IsNullOrEmpty(transition.ExpectedPayloadType))
            {
                types.Add(transition.ExpectedPayloadType);
            }
        }
        return types;
    }

    private string BuildConstructorParameters(string initialState, params string[] additionalParams)
    {
        var allParams = new List<string> { initialState };
        allParams.AddRange(additionalParams);
        return string.Join(", ", allParams);
    }

    private string GetNamespaceFromType(string fullyQualifiedType)
    {
        if (string.IsNullOrEmpty(fullyQualifiedType)) return "";
        var lastDot = fullyQualifiedType.LastIndexOf('.');
        return lastDot > 0 ? fullyQualifiedType.Substring(0, lastDot) : "";
    }

    private void AddUsing(string ns)
    {
        if (!string.IsNullOrWhiteSpace(ns))
        {
            AddedUsings.Add(ns);
        }
    }

    private string GetBaseClassName(string stateType, string triggerType)
    {
        return IsAsyncMachine
            ? $"AsyncStateMachineBase<{stateType}, {triggerType}>"
            : $"StateMachineBase<{stateType}, {triggerType}>";
    }

    private string GetInterfaceName(string stateType, string triggerType)
    {
        return IsAsyncMachine
            ? $"IStateMachineAsync<{stateType}, {triggerType}>"
            : $"IStateMachineSync<{stateType}, {triggerType}>";
    }
    
    private void WriteMethodAttribute() =>
        Sb.AppendLine($"[{Strings.MethodImplAttribute}({Strings.AggressiveInliningAttribute})]");
    
    private void WriteGuardCall(
        TransitionModel transition,
        string resultVar,
        string payloadVar = "null",
        bool throwOnException = false)
    {
        GuardGenerationHelper.EmitGuardCheck(
            Sb,
            transition,
            resultVar,
            payloadVar,
            IsAsyncMachine,
            wrapInTryCatch: !throwOnException,
            Model.ContinueOnCapturedContext,
            handleResultAfterTry: true,
            cancellationTokenVar: GetCtVar(),
            treatCancellationAsFailure: Model.GenerationConfig.TreatCancellationAsFailure
        );
    }
    
    private string GetCtVar() => IsAsyncMachine
        ? "cancellationToken"
        : "CancellationToken.None";
    
    private string ReadOnlyListType => Strings.ReadOnlyListType;
    private string ArrayEmptyMethod => Strings.ArrayEmptyMethod;

    #endregion
}