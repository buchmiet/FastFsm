using System;
using System.Collections.Generic;
using System.Linq;
using Generator.Infrastructure;
using Generator.Model;
using Generator.ModernGeneration.Context;
using Generator.ModernGeneration.Features;
using Generator.ModernGeneration.Policies;
using static Generator.Strings;

namespace Generator.ModernGeneration.Director
{
    /// <summary>
    /// Orkiestruje proces generowania kodu używając modułów i polityk.
    /// </summary>
    public class Director
    {
        private readonly GenerationContext _ctx;
        private readonly List<IFeatureModule> _modules = new();
        private readonly TypeSystemHelper _typeHelper = new();

        public Director(GenerationContext ctx)
        {
            _ctx = ctx ?? throw new ArgumentNullException(nameof(ctx));
        }

        public void RegisterModule(IFeatureModule module)
        {
            _modules.Add(module);
        }

        public string Generate()
        {
            var sb = _ctx.Sb;

            // Header
            EmitHeader();

            // Namespace block (jeśli jest)
            if (!string.IsNullOrEmpty(_ctx.Model.Namespace))
            {
                using (sb.Block($"namespace {_ctx.Model.Namespace}"))
                {
                    GenerateInterface();
                    sb.AppendLine();
                    GenerateClass();
                }
            }
            else
            {
                GenerateInterface();
                sb.AppendLine();
                GenerateClass();
            }

            return sb.ToString();
        }

        private void EmitHeader()
        {
            var sb = _ctx.Sb;

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");

            // Usings from modules
            foreach (var module in _modules.OfType<IEmitUsings>())
            {
                module.EmitUsings(_ctx);
            }

            // Flush collected usings
            _ctx.FlushUsings();
        }

        private void GenerateInterface()
        {
            var sb = _ctx.Sb;
            var model = _ctx.Model;

            var stateType = _typeHelper.FormatTypeForUsage(model.StateType, useGlobalPrefix: false);
            var triggerType = _typeHelper.FormatTypeForUsage(model.TriggerType, useGlobalPrefix: false);

            var baseInterface = model.GenerationConfig.IsAsync
                ? $"IAsyncStateMachine<{stateType}, {triggerType}>"
                : $"IStateMachine<{stateType}, {triggerType}>";

            // Generate interface
            sb.AppendLine($"public interface I{model.ClassName} : {baseInterface} {{ }}");
        }

        private void GenerateClass()
        {
            var sb = _ctx.Sb;
            var model = _ctx.Model;

            var stateType = _typeHelper.FormatTypeForUsage(model.StateType, useGlobalPrefix: false);
            var triggerType = _typeHelper.FormatTypeForUsage(model.TriggerType, useGlobalPrefix: false);

            var baseClass = model.GenerationConfig.IsAsync
                ? $"AsyncStateMachineBase<{stateType}, {triggerType}>"
                : $"StateMachineBase<{stateType}, {triggerType}>";

            // Class declaration - implement custom interface, not the base one
            using (sb.Block($"public partial class {model.ClassName} : {baseClass}, I{model.ClassName}"))
            {
                // Fields
                foreach (var module in _modules.OfType<IEmitFields>())
                {
                    module.EmitFields(_ctx);
                }

                // Constructor
                foreach (var module in _modules.OfType<IEmitConstructor>())
                {
                    module.ContributeConstructor(_ctx);
                }

                // Methods
                foreach (var module in _modules.OfType<IEmitMethods>())
                {
                    module.EmitMethods(_ctx);
                }
            }
        }
    }
}