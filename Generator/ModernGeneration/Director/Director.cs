using System;
using System.Collections.Generic;
using System.Linq;
using Generator.Infrastructure;
using Generator.Model;
using Generator.ModernGeneration.Context;
using Generator.ModernGeneration.Features;
using Generator.ModernGeneration.Policies;

namespace Generator.ModernGeneration.Director
{
    /// <summary>
    /// Orkiestruje proces generowania kodu używając modułów i polityk.
    /// TYLKO orkiestracja - żadnej logiki biznesowej!
    /// </summary>
    public class Director
    {
        private readonly GenerationContext _ctx;
        private readonly List<IFeatureModule> _modules = new();
        private readonly TypeSystemHelper _typeHelper = new();

        public Director(GenerationContext ctx)
        {
            _ctx = ctx ?? throw new ArgumentNullException(nameof(ctx));
            InitializePolicies();
        }

        private void InitializePolicies()
        {
            // Wybierz odpowiednią politykę async
            IAsyncPolicy asyncPolicy = _ctx.Model.GenerationConfig.IsAsync
                ? new AsyncPolicyAsync(_ctx.Model.ContinueOnCapturedContext)
                : new AsyncPolicySync();

            // Zawsze używamy tej samej GuardPolicy (obsługuje wszystkie warianty)
            IGuardPolicy guardPolicy = new GuardPolicy();

            // Używamy Twojej implementacji HookDispatchPolicy
            IHookDispatchPolicy hookPolicy = new HookDispatchPolicy();

            // Ustaw polityki w kontekście
            _ctx.SetPolicies(asyncPolicy, guardPolicy, hookPolicy);
        }

        public void RegisterModule(IFeatureModule module)
        {
            _modules.Add(module);
        }

        public string Generate()
        {
            var sb = _ctx.Sb;

            // Header
            EmitHeader();

            // Namespace block (jeśli jest)
            if (!string.IsNullOrEmpty(_ctx.Model.Namespace))
            {
                using (sb.Block($"namespace {_ctx.Model.Namespace}"))
                {
                    GenerateInterface();
                    sb.AppendLine();
                    GenerateClass();
                }
            }
            else
            {
                GenerateInterface();
                sb.AppendLine();
                GenerateClass();
            }

            return sb.ToString();
        }

        private void EmitHeader()
        {
            var sb = _ctx.Sb;

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");

            // Usings from modules
            foreach (var module in _modules.OfType<IEmitUsings>())
            {
                module.EmitUsings(_ctx);
            }

            // Flush collected usings
            _ctx.FlushUsings();
        }

        private void GenerateInterface()
        {
            var sb = _ctx.Sb;
            var model = _ctx.Model;

            var stateType = _typeHelper.FormatTypeForUsage(model.StateType, useGlobalPrefix: false);
            var triggerType = _typeHelper.FormatTypeForUsage(model.TriggerType, useGlobalPrefix: false);

            // Określ interfejs bazowy - WAŻNE: musi być zgodny z Legacy!
            string baseInterface;

            if (model.GenerationConfig.HasPayload)
            {
                // Payload warianty
                var payloadFeature = _ctx.Modules.OfType<IPayloadFeature>().FirstOrDefault();

                if (payloadFeature?.IsSinglePayload == true)
                {
                    // Single payload
                    var payloadType = _typeHelper.FormatTypeForUsage(model.DefaultPayloadType ?? "object", useGlobalPrefix: false);

                    // UWAGA: Legacy używa IStateMachineWithPayload dla obu wariantów (sync i async)
                    // NIE używamy IAsyncStateMachineWithPayload!
                    baseInterface = $"IStateMachineWithPayload<{stateType}, {triggerType}, {payloadType}>";
                }
                else
                {
                    // Multi-payload
                    if (model.GenerationConfig.IsAsync)
                    {
                        // Tu może być IAsyncStateMachineWithMultiPayload jeśli taki interfejs istnieje
                        baseInterface = $"IAsyncStateMachineWithMultiPayload<{stateType}, {triggerType}>";
                    }
                    else
                    {
                        baseInterface = $"IStateMachineWithMultiPayload<{stateType}, {triggerType}>";
                    }
                }
            }
            else
            {
                // Standard warianty (bez payload)
                baseInterface = model.GenerationConfig.IsAsync
                    ? $"IAsyncStateMachine<{stateType}, {triggerType}>"
                    : $"IStateMachine<{stateType}, {triggerType}>";
            }

            // Generate interface declaration
            sb.AppendLine($"public interface I{model.ClassName} : {baseInterface} {{ }}");
            sb.AppendLine();
        }

        private void GenerateClass()
        {
            var sb = _ctx.Sb;
            var model = _ctx.Model;

            var stateType = _typeHelper.FormatTypeForUsage(model.StateType, useGlobalPrefix: false);
            var triggerType = _typeHelper.FormatTypeForUsage(model.TriggerType, useGlobalPrefix: false);

            var baseClass = model.GenerationConfig.IsAsync
                ? $"AsyncStateMachineBase<{stateType}, {triggerType}>"
                : $"StateMachineBase<{stateType}, {triggerType}>";

            // Class declaration - implement custom interface, not the base one
            using (sb.Block($"public partial class {model.ClassName} : {baseClass}, I{model.ClassName}"))
            {
                // Fields - deleguj do modułów
                foreach (var module in _modules.OfType<IEmitFields>())
                {
                    module.EmitFields(_ctx);
                }

                // Flush fields after all modules contributed
                _ctx.FlushFields();

                // Constructor - deleguj do modułów  
                foreach (var module in _modules.OfType<IEmitConstructor>())
                {
                    module.ContributeConstructor(_ctx);
                }

                // Methods - deleguj do modułów
                foreach (var module in _modules.OfType<IEmitMethods>())
                {
                    module.EmitMethods(_ctx);
                }
            }
        }
    }
}