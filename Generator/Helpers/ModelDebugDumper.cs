using Generator.Model;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Generator.Helpers;

/// <summary>
/// Dumps parsed StateMachineModel to a diagnostic source file for debugging
/// </summary>
public static class ModelDebugDumper
{
    public static void Dump(SourceProductionContext context, StateMachineModel model, string safeName, HashSet<string> usedNames)
    {
        var uniqueName = GetUniqueDumpName(safeName, usedNames);
        var content = GenerateDumpContent(model, uniqueName);
        
        try
        {
            var hintName = $"__FastFsm.ModelDump_{uniqueName}.g.cs";
            context.AddSource(hintName, SourceText.From(content, Encoding.UTF8));
        }
        catch (Exception ex)
        {
            // Silent fail for dump - it's just diagnostic
            _ = ex;
        }
    }
    
    private static string GetUniqueDumpName(string baseName, HashSet<string> usedNames)
    {
        var sanitized = SanitizeName(baseName);
        if (usedNames.Add(sanitized))
            return sanitized;
            
        int i = 2;
        while (true)
        {
            var candidate = $"{sanitized}_{i}";
            if (usedNames.Add(candidate))
                return candidate;
            i++;
        }
    }
    
    private static string SanitizeName(string raw)
    {
        var sb = new StringBuilder(raw.Length);
        foreach (var ch in raw)
            sb.Append(char.IsLetterOrDigit(ch) || ch == '_' ? ch : '_');
        return sb.ToString();
    }
    
    private static string GenerateDumpContent(StateMachineModel model, string safeName)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        var fullName = string.IsNullOrEmpty(model.Namespace) ? model.ClassName : $"{model.Namespace}.{model.ClassName}";
        sb.AppendLine($"// FastFSM Model Dump for {fullName}");
        sb.AppendLine($"// Generated at: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
        sb.AppendLine();
        sb.AppendLine($"internal static class __FastFsm_ModelDump_{safeName}");
        sb.AppendLine("{");
        
        // Basic info
        sb.AppendLine($"    // ClassName: {model.ClassName}");
        sb.AppendLine($"    // Namespace: {model.Namespace}");
        sb.AppendLine($"    // FullName: {fullName}");
        sb.AppendLine($"    // StateType: {model.StateType}");
        sb.AppendLine($"    // TriggerType: {model.TriggerType}");
        sb.AppendLine();
        
        // Variant and features from GenerationConfig
        sb.AppendLine($"    // Variant: {model.Variant}");
        sb.AppendLine($"    // IsAsync: {model.GenerationConfig.IsAsync}");
        sb.AppendLine($"    // HasPayload: {model.GenerationConfig.HasPayload}");
        sb.AppendLine($"    // HasExtensions: {model.GenerationConfig.HasExtensions}");
        sb.AppendLine($"    // HasOnEntryExit: {model.GenerationConfig.HasOnEntryExit}");
        sb.AppendLine($"    // HierarchyEnabled: {model.HierarchyEnabled}");
        sb.AppendLine($"    // HasHierarchy: {model.HasHierarchy}");
        sb.AppendLine();
        
        // Payload types
        if (model.TriggerPayloadTypes?.Any() == true || !string.IsNullOrEmpty(model.DefaultPayloadType))
        {
            sb.AppendLine($"    // DefaultPayloadType: {model.DefaultPayloadType ?? "none"}");
            sb.AppendLine($"    // TriggerPayloadTypes ({model.TriggerPayloadTypes?.Count ?? 0}):");
            if (model.TriggerPayloadTypes != null)
            {
                foreach (var pt in model.TriggerPayloadTypes)
                {
                    sb.AppendLine($"    //   - {pt.Key}: {pt.Value}");
                }
            }
        }
        else
        {
            sb.AppendLine("    // PayloadTypes: none");
        }
        sb.AppendLine();
        
        // States
        sb.AppendLine($"    // States ({model.States?.Count ?? 0}):");
        if (model.States != null)
        {
            foreach (var state in model.States.Values.OrderBy(s => s.Name))
            {
                sb.Append($"    //   - {state.Name}");
                
                if (!string.IsNullOrEmpty(state.ParentState))
                    sb.Append($" Parent={state.ParentState}");
                    
                if (state.History != HistoryMode.None)
                    sb.Append($" History={state.History}");
                    
                if (state.IsInitial)
                    sb.Append(" IsInitial=true");
                    
                if (state.IsComposite)
                    sb.Append(" IsComposite=true");
                    
                if (!string.IsNullOrEmpty(state.OnEntryMethod))
                    sb.Append($" OnEntry={state.OnEntryMethod}");
                    
                if (!string.IsNullOrEmpty(state.OnExitMethod))
                    sb.Append($" OnExit={state.OnExitMethod}");
                    
                sb.AppendLine();
            }
        }
        sb.AppendLine();
        
        // Transitions analysis
        var externalTransitions = model.Transitions?.Where(t => !t.IsInternal).ToList() ?? new List<TransitionModel>();
        var internalTransitions = model.Transitions?.Where(t => t.IsInternal).ToList() ?? new List<TransitionModel>();
        
        sb.AppendLine($"    // External Transitions ({externalTransitions.Count}):");
        foreach (var t in externalTransitions)
        {
            sb.Append($"    //   - {t.FromState} --[{t.Trigger}]--> {t.ToState}");
            if (!string.IsNullOrEmpty(t.GuardMethod))
                sb.Append($" Guard={t.GuardMethod}");
            if (!string.IsNullOrEmpty(t.ActionMethod))
                sb.Append($" Action={t.ActionMethod}");
            if (t.Priority != 0)
                sb.Append($" Priority={t.Priority}");
            sb.AppendLine();
        }
        sb.AppendLine();
        
        sb.AppendLine($"    // Internal Transitions ({internalTransitions.Count}):");
        foreach (var t in internalTransitions)
        {
            sb.Append($"    //   - {t.FromState} --[{t.Trigger}]--â€¢ (internal)");
            if (!string.IsNullOrEmpty(t.GuardMethod))
                sb.Append($" Guard={t.GuardMethod}");
            if (!string.IsNullOrEmpty(t.ActionMethod))
                sb.Append($" Action={t.ActionMethod}");
            if (t.Priority != 0)
                sb.Append($" Priority={t.Priority}");
            sb.AppendLine();
        }
        sb.AppendLine();
        
        // Summary flags
        bool hasExternal = externalTransitions.Count > 0;
        bool hasInternal = internalTransitions.Count > 0;
        bool isInternalOnly = hasInternal && !hasExternal;
        bool hasAnyTransitions = model.Transitions?.Count > 0;
        
        sb.AppendLine($"    // InternalOnly: {isInternalOnly}");
        sb.AppendLine($"    // HasAnyExternal: {hasExternal}");
        sb.AppendLine($"    // HasAnyInternal: {hasInternal}");
        sb.AppendLine($"    // HasAnyTransitions: {hasAnyTransitions}");
        sb.AppendLine($"    // TotalTransitions: {model.Transitions?.Count ?? 0}");
        sb.AppendLine();
        
        // Initial state
        if (model.States?.Count > 0)
        {
            var firstState = model.States.Values.FirstOrDefault()?.Name;
            sb.AppendLine($"    // InitialState (first): {firstState}");
        }
        
        // HSM info if enabled
        if (model.HierarchyEnabled || model.HasHierarchy)
        {
            sb.AppendLine();
            sb.AppendLine("    // === HSM Structure ===");
            
            if (model.ParentOf?.Count > 0)
            {
                sb.AppendLine($"    // ParentOf ({model.ParentOf.Count}):");
                foreach (var kvp in model.ParentOf)
                {
                    sb.AppendLine($"    //   {kvp.Key} -> {kvp.Value ?? "(none)"}");
                }
            }
            
            if (model.ChildrenOf?.Count > 0)
            {
                sb.AppendLine($"    // ChildrenOf ({model.ChildrenOf.Count}):");
                foreach (var kvp in model.ChildrenOf)
                {
                    sb.AppendLine($"    //   {kvp.Key} -> [{string.Join(", ", kvp.Value)}]");
                }
            }
            
            if (model.InitialChildOf?.Count > 0)
            {
                sb.AppendLine($"    // InitialChildOf ({model.InitialChildOf.Count}):");
                foreach (var kvp in model.InitialChildOf)
                {
                    sb.AppendLine($"    //   {kvp.Key} -> {kvp.Value ?? "(none)"}");
                }
            }
            
            if (model.HistoryOf?.Count > 0)
            {
                sb.AppendLine($"    // HistoryOf ({model.HistoryOf.Count}):");
                foreach (var kvp in model.HistoryOf)
                {
                    sb.AppendLine($"    //   {kvp.Key} -> {kvp.Value}");
                }
            }
            
            if (model.Depth?.Count > 0)
            {
                sb.AppendLine($"    // Depth ({model.Depth.Count}):");
                foreach (var kvp in model.Depth.OrderBy(x => x.Value))
                {
                    sb.AppendLine($"    //   {kvp.Key}: depth={kvp.Value}");
                }
            }
        }
        
        // Exception handler
        if (model.ExceptionHandler != null)
        {
            sb.AppendLine();
            sb.AppendLine($"    // ExceptionHandler: {model.ExceptionHandler.MethodName}");
        }
        
        // Generation flags
        sb.AppendLine();
        sb.AppendLine($"    // GenerateLogging: {model.GenerateLogging}");
        sb.AppendLine($"    // GenerateDependencyInjection: {model.GenerateDependencyInjection}");
        
        sb.AppendLine("}");
        
        return sb.ToString();
    }
}