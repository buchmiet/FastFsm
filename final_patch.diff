diff --git a/Generator/SourceGenerators/PayloadVariantGenerator.cs b/Generator/SourceGenerators/PayloadVariantGenerator.cs
index 9c69ec7..724abb6 100644
--- a/Generator/SourceGenerators/PayloadVariantGenerator.cs
+++ b/Generator/SourceGenerators/PayloadVariantGenerator.cs
@@ -356,34 +356,34 @@ internal class PayloadVariantGenerator(StateMachineModel model) : StateMachineCo
                             && toStateDef != null
                             && !string.IsNullOrEmpty(toStateDef.OnEntryMethod);
 
-        // Determine if any callback expects payload (pattern matching needed)
-        bool needsPayload = (transition.GuardExpectsPayload && !string.IsNullOrEmpty(transition.ExpectedPayloadType))
-                          || (transition.ActionExpectsPayload && !string.IsNullOrEmpty(transition.ExpectedPayloadType))
-                          || (fromHasExit && fromStateDef!.OnExitExpectsPayload && !string.IsNullOrEmpty(transition.ExpectedPayloadType))
-                          || (toHasEntry && toStateDef!.OnEntryExpectsPayload && !string.IsNullOrEmpty(transition.ExpectedPayloadType));
-
-        // If no payload is needed, fall back to non-payload logic (which includes callbacks)
-        if (!needsPayload)
-        {
-            WriteTransitionLogicForFlatNonPayload(transition, stateTypeForUsage, triggerTypeForUsage);
-            return;
-        }
-
-        // Hook before transition for payload-dependent logic
-        WriteBeforeTransitionHook(transition, stateTypeForUsage, triggerTypeForUsage);
-
-        // Generate unique payload variable name if needed
-        string payloadVarName = "";
-        if (!string.IsNullOrEmpty(transition.ExpectedPayloadType))
-        {
-            payloadVarName = MakeSafeIdentifier($"p_{transition.FromState}_{transition.Trigger}_{transition.ToState}");
-            var payloadType = TypeHelper.FormatTypeForUsage(transition.ExpectedPayloadType);
-
-            // Open payload pattern matching block
-            Sb.AppendLine($"if ({PayloadVar} is {payloadType} {payloadVarName})");
-            Sb.AppendLine("{");
-            using (Sb.Indent())
-            {
+        // Determine if any callback expects payload (pattern matching needed)
+        bool needsPayload = (transition.GuardExpectsPayload && !string.IsNullOrEmpty(transition.ExpectedPayloadType))
+                          || (transition.ActionExpectsPayload && !string.IsNullOrEmpty(transition.ExpectedPayloadType))
+                          || (fromHasExit && fromStateDef!.OnExitExpectsPayload && !string.IsNullOrEmpty(transition.ExpectedPayloadType))
+                          || (toHasEntry && toStateDef!.OnEntryExpectsPayload && !string.IsNullOrEmpty(transition.ExpectedPayloadType));
+
+        // If no payload is needed, fall back to non-payload logic (which includes callbacks)
+        if (!needsPayload)
+        {
+            WriteTransitionLogicForFlatNonPayload(transition, stateTypeForUsage, triggerTypeForUsage);
+            return;
+        }
+
+        // Hook before transition for payload-dependent logic  
+        WriteBeforeTransitionHook(transition, stateTypeForUsage, triggerTypeForUsage);
+
+        // Generate unique payload variable name if needed
+        string payloadVarName = "";
+        if (needsPayload && !string.IsNullOrEmpty(transition.ExpectedPayloadType))
+        {
+            payloadVarName = MakeSafeIdentifier($"p_{transition.FromState}_{transition.Trigger}_{transition.ToState}");
+            var payloadType = TypeHelper.FormatTypeForUsage(transition.ExpectedPayloadType);
+
+            // Open payload pattern matching block
+            Sb.AppendLine($"if ({PayloadVar} is {payloadType} {payloadVarName})");
+            Sb.AppendLine("{");
+            using (Sb.Indent())
+            {
 
         // Guard with direct return
         if (!string.IsNullOrEmpty(transition.GuardMethod))
@@ -527,92 +527,284 @@ internal class PayloadVariantGenerator(StateMachineModel model) : StateMachineCo
                 WriteAfterTransitionHook(transition, stateTypeForUsage, triggerTypeForUsage, success: true);
                 Sb.AppendLine("return true;");
             } // This closes the using(Sb.Indent()) from payload block
-            Sb.AppendLine("}");
-            Sb.AppendLine("else");
-            using (Sb.Block(""))
-            {
-                if (ParameterlessPathIsValid(transition, fromStateDef, toStateDef, fromHasExit, toHasEntry))
-                {
-                    WriteTransitionLogicForFlatNonPayload(transition, stateTypeForUsage, triggerTypeForUsage);
-                }
-                else
-                {
-                    Sb.AppendLine("return false;");
-                }
-            }
-        }
-        else
-        {
-            // Fallback when payload type is unknown
-            WriteTransitionLogicForFlatNonPayload(transition, stateTypeForUsage, triggerTypeForUsage);
-        }
-    }
-
-    private bool ParameterlessPathIsValid(
-        TransitionModel transition,
-        StateModel? fromStateDef,
-        StateModel? toStateDef,
-        bool fromHasExit,
-        bool toHasEntry)
-    {
-        bool guardOk;
-        if (string.IsNullOrEmpty(transition.GuardMethod))
-        {
-            guardOk = true;
-        }
-        else if (!transition.GuardExpectsPayload)
-        {
-            guardOk = true;
-        }
-        else
-        {
-            guardOk = transition.GuardSignature.HasParameterless;
-        }
-
-        bool actionOk;
-        if (string.IsNullOrEmpty(transition.ActionMethod))
-        {
-            actionOk = true;
-        }
-        else if (!transition.ActionExpectsPayload)
-        {
-            actionOk = true;
-        }
-        else
-        {
-            actionOk = transition.ActionSignature.HasParameterless;
-        }
-
-        bool exitOk;
-        if (!fromHasExit || fromStateDef == null)
-        {
-            exitOk = true;
-        }
-        else if (!fromStateDef.OnExitExpectsPayload)
-        {
-            exitOk = true;
-        }
-        else
-        {
-            exitOk = fromStateDef.OnExitHasParameterlessOverload;
-        }
-
-        bool entryOk;
-        if (!toHasEntry || toStateDef == null)
-        {
-            entryOk = true;
-        }
-        else if (!toStateDef.OnEntryExpectsPayload)
-        {
-            entryOk = true;
-        }
-        else
-        {
-            entryOk = toStateDef.OnEntryHasParameterlessOverload;
-        }
-
-        return guardOk && actionOk && exitOk && entryOk;
-    }
+            Sb.AppendLine("}");
+            Sb.AppendLine("else");
+            using (Sb.Block(""))
+            {
+                if (ParameterlessPathIsValid(transition, fromStateDef, toStateDef, fromHasExit, toHasEntry))
+                {
+                    // Write the non-payload transition logic without the before hook (already called)
+                    WriteTransitionLogicForFlatNonPayloadWithoutHook(transition, stateTypeForUsage, triggerTypeForUsage);
+                }
+                else
+                {
+                    Sb.AppendLine("return false;");
+                }
+            }
+        }
+        else
+        {
+            // Fallback when payload type is unknown
+            WriteTransitionLogicForFlatNonPayload(transition, stateTypeForUsage, triggerTypeForUsage);
+        }
+    }
+
+    private void WriteTransitionLogicForFlatNonPayloadWithoutHook(
+        TransitionModel transition,
+        string stateTypeForUsage,
+        string triggerTypeForUsage)
+    {
+        var hasOnEntryExit = ShouldGenerateOnEntryExit();
+
+        // Note: BeforeTransitionHook is NOT called here as it was already called before the if/else
+
+        // Guard check (if present)
+        if (!string.IsNullOrEmpty(transition.GuardMethod))
+        {
+            WriteGuardEvaluationHook(transition, stateTypeForUsage, triggerTypeForUsage);
+            
+            // Emit guard check with direct return on failure
+            Sb.AppendLine("bool guardOk;");
+            Sb.AppendLine("try");
+            using (Sb.Block(""))
+            {
+                Sb.AppendLine($"guardOk = {transition.GuardMethod}();");
+            }
+            Sb.AppendLine("catch");
+            using (Sb.Block(""))
+            {
+                WriteLogStatement("Warning",
+                    $"GuardFailed(_logger, _instanceId, \"{transition.GuardMethod}\", \"{transition.FromState}\", \"{transition.ToState}\", \"{transition.Trigger}\");");
+                WriteLogStatement("Warning",
+                    $"TransitionFailed(_logger, _instanceId, \"{transition.FromState}\", \"{transition.Trigger}\");");
+                WriteAfterTransitionHook(transition, stateTypeForUsage, triggerTypeForUsage, success: false);
+                Sb.AppendLine("return false;");
+            }
+            
+            // Check guard result
+            WriteAfterGuardEvaluatedHook(transition, "guardOk", stateTypeForUsage, triggerTypeForUsage);
+            using (Sb.Block("if (!guardOk)"))
+            {
+                WriteLogStatement("Warning",
+                    $"GuardFailed(_logger, _instanceId, \"{transition.GuardMethod}\", \"{transition.FromState}\", \"{transition.ToState}\", \"{transition.Trigger}\");");
+                WriteLogStatement("Warning",
+                    $"TransitionFailed(_logger, _instanceId, \"{transition.FromState}\", \"{transition.Trigger}\");");
+                WriteAfterTransitionHook(transition, stateTypeForUsage, triggerTypeForUsage, success: false);
+                Sb.AppendLine("return false;");
+            }
+        }
+
+        // OnExit (if applicable)
+        if (!transition.IsInternal && hasOnEntryExit &&
+            Model.States.TryGetValue(transition.FromState, out var fromStateDef) &&
+            !string.IsNullOrEmpty(fromStateDef.OnExitMethod))
+        {
+            // FSM_DEBUG comment
+            Sb.AppendLine($"// FSM_DEBUG: No handler for {Model.ClassName}, exit={fromStateDef.OnExitMethod}");
+            
+            Sb.AppendLine("try");
+            using (Sb.Block(""))
+            {
+                Sb.AppendLine($"{fromStateDef.OnExitMethod}();");
+            }
+            Sb.AppendLine("catch");
+            using (Sb.Block(""))
+            {
+                // On OnExit failure, we're still in the original state, so don't change
+                WriteAfterTransitionHook(transition, stateTypeForUsage, triggerTypeForUsage, success: false);
+                Sb.AppendLine("return false;");
+            }
+            WriteLogStatement("Debug",
+                $"OnExitExecuted(_logger, _instanceId, \"{fromStateDef.OnExitMethod}\", \"{transition.FromState}\");");
+        }
+
+        // State change
+        if (!transition.IsInternal)
+        {
+            if (Model.HierarchyEnabled)
+            {
+                Sb.AppendLine("RecordHistoryForCurrentPath();");
+                WriteStateChangeWithCompositeHandling(transition.ToState, stateTypeForUsage);
+            }
+            else
+            {
+                Sb.AppendLine($"{CurrentStateField} = {stateTypeForUsage}.{TypeHelper.EscapeIdentifier(transition.ToState)};");
+            }
+        }
+
+        // OnEntry (if applicable)
+        if (!transition.IsInternal && hasOnEntryExit &&
+            Model.States.TryGetValue(transition.ToState, out var toStateDef) &&
+            !string.IsNullOrEmpty(toStateDef.OnEntryMethod))
+        {
+            Sb.AppendLine("try");
+            using (Sb.Block(""))
+            {
+                Sb.AppendLine($"{toStateDef.OnEntryMethod}();");
+            }
+            Sb.AppendLine("catch");
+            using (Sb.Block(""))
+            {
+                // On OnEntry failure, we're already in the new state, so don't revert
+                WriteAfterTransitionHook(transition, stateTypeForUsage, triggerTypeForUsage, success: false);
+                Sb.AppendLine("return false;");
+            }
+            WriteLogStatement("Debug",
+                $"OnEntryExecuted(_logger, _instanceId, \"{toStateDef.OnEntryMethod}\", \"{transition.ToState}\");");
+        }
+
+        // Action (if present) - only if no payload expected or parameterless overload exists
+        if (!string.IsNullOrEmpty(transition.ActionMethod) && 
+            (!transition.ActionExpectsPayload || transition.ActionSignature.HasParameterless))
+        {
+            // FSM_DEBUG comment
+            Sb.AppendLine($"// FSM_DEBUG: No handler for {Model.ClassName}, action={transition.ActionMethod}");
+            
+            // For the non-payload path, action handling depends on exception handler
+            if (Model.ExceptionHandler == null)
+            {
+                // No exception handler - use existing try/catch logic
+                Sb.AppendLine("try");
+                using (Sb.Block(""))
+                {
+                    Sb.AppendLine($"{transition.ActionMethod}();");
+                    WriteLogStatement("Debug",
+                        $"ActionExecuted(_logger, _instanceId, \"{transition.ActionMethod}\", \"{transition.FromState}\", \"{transition.ToState}\", \"{transition.Trigger}\");");
+                }
+                Sb.AppendLine("catch");
+                using (Sb.Block(""))
+                {
+                    WriteAfterTransitionHook(transition, stateTypeForUsage, triggerTypeForUsage, success: false);
+                    Sb.AppendLine("return false;");
+                }
+            }
+            else
+            {
+                // Has exception handler - use directive-based exception handling
+                Sb.AppendLine("try");
+                using (Sb.Block(""))
+                {
+                    Sb.AppendLine($"{transition.ActionMethod}();");
+                    WriteLogStatement("Debug",
+                        $"ActionExecuted(_logger, _instanceId, \"{transition.ActionMethod}\", \"{transition.FromState}\", \"{transition.ToState}\", \"{transition.Trigger}\");");
+                }
+                Sb.AppendLine("catch (Exception ex) when (ex is not System.OperationCanceledException)");
+                using (Sb.Block(""))
+                {
+                    var handler = Model.ExceptionHandler;
+                    var stateType = GetTypeNameForUsage(Model.StateType);
+                    var triggerType = GetTypeNameForUsage(Model.TriggerType);
+                    
+                    // Create exception context
+                    Sb.AppendLine($"var exceptionContext = new {handler.ExceptionContextClosedType}(");
+                    using (Sb.Indent())
+                    {
+                        Sb.AppendLine($"{stateType}.{TypeHelper.EscapeIdentifier(transition.FromState)},");
+                        Sb.AppendLine($"{stateType}.{TypeHelper.EscapeIdentifier(transition.ToState)},");
+                        Sb.AppendLine($"{triggerType}.{TypeHelper.EscapeIdentifier(transition.Trigger)},");
+                        Sb.AppendLine("ex,");
+                        Sb.AppendLine("TransitionStage.Action,");
+                        Sb.AppendLine("true);"); // State already changed for actions
+                    }
+                    
+                    // Call handler
+                    Sb.AppendLine($"var directive = {handler.MethodName}(exceptionContext);");
+                    
+                    // Apply directive based on policy
+                    using (Sb.Block("if (directive == ExceptionDirective.Propagate)"))
+                    {
+                        // Keep the new state on Propagate in flat FSM
+                        Sb.AppendLine("throw;");
+                    }
+                    Sb.AppendLine("// Continue: keep new state and continue execution");
+                }
+            }
+        }
+        else if (!string.IsNullOrEmpty(transition.ActionMethod))
+        {
+            // Action requires payload but no parameterless overload - skip the action
+            Sb.AppendLine($"// FSM_DEBUG: No handler for {Model.ClassName}, action={transition.ActionMethod}");
+        }
+
+        // Log successful transition
+        if (!transition.IsInternal)
+        {
+            WriteLogStatement("Information",
+                $"TransitionSucceeded(_logger, _instanceId, \"{transition.FromState}\", \"{transition.ToState}\", \"{transition.Trigger}\");");
+        }
+
+        // Hook: After successful transition
+        WriteAfterTransitionHook(transition, stateTypeForUsage, triggerTypeForUsage, success: true);
+
+        // Success - direct return
+        Sb.AppendLine("return true;");
+    }
+
+    private bool ParameterlessPathIsValid(
+        TransitionModel transition,
+        StateModel? fromStateDef,
+        StateModel? toStateDef,
+        bool fromHasExit,
+        bool toHasEntry)
+    {
+        bool guardOk;
+        if (string.IsNullOrEmpty(transition.GuardMethod))
+        {
+            guardOk = true;
+        }
+        else if (!transition.GuardExpectsPayload)
+        {
+            guardOk = true;
+        }
+        else
+        {
+            guardOk = transition.GuardSignature.HasParameterless;
+        }
+
+        bool actionOk;
+        if (string.IsNullOrEmpty(transition.ActionMethod))
+        {
+            actionOk = true;
+        }
+        else if (!transition.ActionExpectsPayload)
+        {
+            actionOk = true;
+        }
+        else
+        {
+            actionOk = true;
+        }
+
+        bool exitOk;
+        if (!fromHasExit || fromStateDef == null)
+        {
+            exitOk = true;
+        }
+        else if (!fromStateDef.OnExitExpectsPayload)
+        {
+            exitOk = true;
+        }
+        else
+        {
+            exitOk = fromStateDef.OnExitHasParameterlessOverload;
+        }
+
+        bool entryOk;
+        if (!toHasEntry || toStateDef == null)
+        {
+            entryOk = true;
+        }
+        else if (!toStateDef.OnEntryExpectsPayload)
+        {
+            entryOk = true;
+        }
+        else
+        {
+            entryOk = toStateDef.OnEntryHasParameterlessOverload;
+        }
+
+        return guardOk && actionOk && exitOk && entryOk;
+    }
 
     protected override void WriteOnInitialEntryMethod(string stateTypeForUsage)
     {
diff --git a/Generator/SourceGenerators/StateMachineCodeGenerator.cs b/Generator/SourceGenerators/StateMachineCodeGenerator.cs
index c60adc5..2334190 100644
--- a/Generator/SourceGenerators/StateMachineCodeGenerator.cs
+++ b/Generator/SourceGenerators/StateMachineCodeGenerator.cs
@@ -674,7 +674,8 @@ public abstract class StateMachineCodeGenerator(StateMachineModel model)
         }
 
         // Action (if present)
-        if (!string.IsNullOrEmpty(transition.ActionMethod))
+        if (!string.IsNullOrEmpty(transition.ActionMethod) && 
+            (!transition.ActionExpectsPayload || transition.ActionSignature.HasParameterless))
         {
             if (Model.ExceptionHandler == null)
             {
