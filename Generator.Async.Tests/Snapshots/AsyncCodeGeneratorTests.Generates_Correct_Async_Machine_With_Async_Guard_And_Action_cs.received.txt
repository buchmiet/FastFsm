// <auto-generated/>
#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using StateMachine.Contracts;
using StateMachine.Runtime;
using Generator.Async.Tests.Implementations;

namespace MyTest.Machines
{
    public interface ITestAsyncMachine : IAsyncStateMachine<TestState, TestTrigger> { }

    public partial class TestAsyncMachine : AsyncStateMachineBase<TestState, TestTrigger>, ITestAsyncMachine
    {
        public TestAsyncMachine(TestState initialState) : base(initialState, continueOnCapturedContext: false)
        {
        }

        protected override async ValueTask<bool> TryFireInternalAsync(TestTrigger trigger, object? payload, CancellationToken cancellationToken)
        {
            var originalState = _currentState;
            bool success = false;

            switch (_currentState)
            {
                case TestState.A:
                {
                    switch (trigger)
                    {
                        case TestTrigger.Go:
                        {
                            var guardResult = await CanGoAsync().ConfigureAwait(_continueOnCapturedContext);
                            if (!guardResult)
                            {
                                success = false;
                                goto END_TRY_FIRE;
                            }
                            await OnGoAsync().ConfigureAwait(_continueOnCapturedContext);
                            _currentState = TestState.B;
                            success = true;
                            goto END_TRY_FIRE;
                        }
                        default: break;
                    }
                    break;
                }
                default: break;
            }
            END_TRY_FIRE:;

            if (!success)
            {
            }
            return success;
        }

        public override async ValueTask<bool> CanFireAsync(TestTrigger trigger, CancellationToken cancellationToken = default)
        {
            switch (_currentState)
            {
                case TestState.A:
                    switch (trigger)
                    {
                        case TestTrigger.Go:
                            return await CanGoAsync().ConfigureAwait(_continueOnCapturedContext);
                        default: return false;
                    }
                default: return false;
            }
        }

        public override async ValueTask<IReadOnlyList<TestTrigger>> GetPermittedTriggersAsync(CancellationToken cancellationToken = default)
        {
            switch (_currentState)
            {
                case TestState.A:

                {
                    var permitted = new List<TestTrigger>();
                    if (await CanGoAsync().ConfigureAwait(_continueOnCapturedContext))
                    {
                        permitted.Add(TestTrigger.Go);
                    }
                    return permitted.Count == 0 ? 
                        System.Array.Empty<TestTrigger>() :
                        permitted.ToArray();
                }
                default: return System.Array.Empty<TestTrigger>();
            }
        }

    }
}
