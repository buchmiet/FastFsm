# FastFsm Architectural Documentation

## 1\. Core Philosophy & Goals

`FastFsm` is a .NET library for creating Finite State Machines (FSMs). Its design is driven by a set of core principles aimed at addressing the shortcomings of traditional reflection-based or dictionary-heavy FSM libraries, especially in performance-critical, resource-constrained, or modern .NET environments.

The primary goals are:

  * **🚀 Maximum Performance**: Achieve near-native code speed for state transitions by eliminating runtime reflection, dictionary lookups, and dynamic dispatch. The goal is to make transition logic as cheap as a `switch` statement.
  * **🗑️ Zero Allocation (in hot path)**: State transitions should not allocate memory on the managed heap, preventing garbage collector pressure in high-throughput scenarios.
  * **🛡️ AOT & Trimming Safety**: The library must be fully compatible with Ahead-of-Time (AOT) compilation and assembly trimming, making it suitable for modern deployment models like Native AOT, Blazor Wasm, and mobile/IoT applications.
  * **✨ Superb Developer Experience**: Defining a state machine should be declarative, intuitive, and type-safe. The library should provide compile-time feedback and require minimal boilerplate from the user.
  * **🧩 Modular & Pay-for-Play**: Core functionality should be lean. Advanced features like logging, dependency injection, or complex state behaviors should be opt-in, ensuring that users who don't need them don't pay the performance or dependency cost.

## 2\. High-Level Architecture

The ecosystem is composed of three key projects and a novel packaging strategy.

1.  **`Abstractions`**: A `netstandard2.0` class library containing only the attributes (e.g., `[StateMachine]`, `[Transition]`) needed to define an FSM. Its wide compatibility ensures it can be referenced by any .NET project.
2.  **`Generator`**: A C\# Source Generator project. This is the heart of the library. It analyzes user code decorated with attributes from the `Abstractions` library and generates the high-performance C\# implementation of the state machine.
3.  **`StateMachine` (`FastFsm.Net`)**: The main runtime and tooling package. It references `Abstractions` and includes the `Generator` as a Roslyn Analyzer. It also provides base classes, contracts (`IStateMachine<TState, TTrigger>`), and helper code.
4.  **`FastFsm.Net.Logging`**: A "virtual" or "overlay" package. It contains no DLLs itself but cleverly manipulates the build process of the consuming project to "activate" logging features within the code generated by `FastFsm.Net`.

This separation ensures a clean dependency graph and reinforces the "pay-for-play" philosophy.

-----

## 3\. The Source Generation Engine

The core innovation of `FastFsm` is its reliance on source generation.

### 3.1. User-Facing API

A developer defines a state machine by creating a `partial` class and decorating it with attributes. This is the entirety of the required boilerplate.

**Example: User Code**

```csharp
// User defines enums for states and triggers
public enum OrderState { New, Submitted, Shipped }
public enum OrderTrigger { Submit, Ship }

// User defines the state machine structure using attributes
[StateMachine(typeof(OrderState), typeof(OrderTrigger))]
public partial class OrderMachine
{
    // A dummy method to hold transition definitions
    [Transition(OrderState.New, OrderTrigger.Submit, OrderState.Submitted)]
    private void Configure() { }
}
```

### 3.2. Generated Implementation

The `Generator` project detects the `[StateMachine]` attribute and generates the other part of the `partial class`. The key is that it translates the declarative attributes into a highly optimized, imperative `switch`-based implementation.

**Example: Generated Code (Simplified)**

```csharp
// <auto-generated/>
public partial class OrderMachine : StateMachineBase<OrderState, OrderTrigger>, IOrderMachine
{
    public OrderMachine(OrderState initialState) : base(initialState) { }

    public override bool TryFire(OrderTrigger trigger, object? payload = null)
    {
        // The core logic is a nested switch, which the JIT can optimize heavily.
        switch (_currentState)
        {
            case OrderState.New:
                switch (trigger)
                {
                    case OrderTrigger.Submit:
                        _currentState = OrderState.Submitted;
                        return true;
                }
                break;
        }
        return false;
    }

    public override bool CanFire(OrderTrigger trigger)
    {
        // Similar switch-based logic for pre-checks.
        switch (_currentState)
        {
            case OrderState.New:
                return trigger == OrderTrigger.Submit;
        }
        return false;
    }
    // ... and so on for GetPermittedTriggers()
}
```

### 3.3. Architectural Benefits

  * **Performance**: The generated code is a simple `switch` statement on enums. The .NET JIT/AOT compiler is exceptionally good at optimizing this pattern, often converting it into a jump table. This is significantly faster than any approach involving `Dictionary<TKey, TValue>` lookups or reflection.
  * **AOT/Trimming Safety**: Since the implementation is pure, static C\# code with no runtime reflection on user types, it is perfectly safe for AOT compilers and linkers. The linker can see all possible code paths and trim away unused code effectively.
  * **Type Safety**: The generator works with the Roslyn compiler's semantic model, ensuring that any misuse of states or triggers results in a compile-time error, not a runtime exception.

-----

## 4\. The Conditional Logging Overlay

This is the most sophisticated part of the architecture, designed to provide optional, high-performance logging without burdening the core package with extra dependencies.

### 4.1. The Challenge

We want to inject logging statements directly into the generated `TryFire` method. However, this requires a dependency on `Microsoft.Extensions.Logging.Abstractions`. Forcing this dependency on all users, especially in IoT or other lean environments, violates the "pay-for-play" principle.

### 4.2. The Solution: A Multi-Stage MSBuild & Source-Gen Dance

The solution involves three orchestrated components that work together.

#### Step 1: The Build Property Hook (`FastFsm.Net`)

The core `FastFsm.Net` package introduces an MSBuild property, `FsmGenerateLogging`, which acts as a global switch for the generator.

Inside the `FastFsm.Net.nupkg`, there is a file located at `build/FastFsm.Net.props`. This file is automatically imported by any project that references the package.

**`build/FastFsm.Net.props`**

```xml
<Project>
  <PropertyGroup>
    <FsmGenerateLogging Condition="'$(FsmGenerateLogging)' == ''">false</FsmGenerateLogging>
  </PropertyGroup>
  <ItemGroup>
    <CompilerVisibleProperty Include="FsmGenerateLogging" />
  </ItemGroup>
</Project>
```

The source generator can now query this property during compilation to decide whether to emit logging code. By default, it's `false`.

#### Step 2: The Activator Package (`FastFsm.Net.Logging`)

This is a NuGet package that acts as a feature flag and dependency provider. It is intentionally "empty" in terms of compiled output.

**`FastFsm.Net.Logging.csproj` (Key Parts)**

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <IncludeBuildOutput>false</IncludeBuildOutput>

    <FsmGenerateLogging>true</FsmGenerateLogging>
    <DefineConstants>$(DefineConstants);FSM_LOGGING_ENABLED</DefineConstants>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="..." />
    <PackageReference Include="FastFsm.Net" Version="..." />
  </ItemGroup>

  <ItemGroup>
    <None Include="build\FastFsm.Net.Logging.props" Pack="true" PackagePath="buildTransitive" />
  </ItemGroup>
</Project>
```

When a user adds a `PackageReference` to `FastFsm.Net.Logging`:

1.  The `FsmGenerateLogging` property is set to `true`, overriding the default `false` from the core package.
2.  The `FSM_LOGGING_ENABLED` C\# preprocessor constant is defined.
3.  The `Microsoft.Extensions.Logging.Abstractions` DLL is added to the user's project dependencies.

#### Step 3: Conditional Generation & Compilation

Now, all the pieces fall into place:

1.  **The Source Generator**: It sees `FsmGenerateLogging` is `true` and emits the logging-enhanced version of the state machine, which includes an `ILogger` field, an updated constructor, and calls to a static `Log` class.
2.  **The Shared Source File (`ExtensionRunner.cs`)**: This file, which handles extension logic, needs to perform logging too. It's included in the user's project as a linked source file and uses `#if FSM_LOGGING_ENABLED` to conditionally compile logging calls.

This design achieves the holy grail:

  * Users of `FastFsm.Net` get a lean, dependency-free library.
  * Users of `FastFsm.Net.Logging` get rich, high-performance, structured logging by simply adding one package reference. The "activation" is seamless.

-----

## 5\. The `ExtensionRunner.cs` Shared Source Strategy

A particularly tricky component is `ExtensionRunner.cs`. It's a runtime helper, not generated code, but its implementation *must* change depending on whether logging is active. Compiling two versions of `FastFsm.Net.dll` would be a maintenance nightmare.

### 5.1. The Problem

How can a file within the `FastFsm.Net` library conditionally compile against a preprocessor symbol (`FSM_LOGGING_ENABLED`) that is only defined when a *different* package (`FastFsm.Net.Logging`) is installed?

### 5.2. The Solution: `contentFiles`

The solution is to not compile `ExtensionRunner.cs` into `FastFsm.Net.dll` at all. Instead, we package it as "content" that gets added directly to the consumer's project.

**`StateMachine.csproj` (`FastFsm.Net` project file)**

```xml
<ItemGroup>
  <Compile Remove="Runtime\Extensions\ExtensionRunner.cs" />

  <None Include="Runtime\Extensions\ExtensionRunner.cs"
        Pack="true"
        PackagePath="contentFiles/cs/any"
        BuildAction="Compile"
        Visible="false" />
</ItemGroup>
```

**How it works:**

1.  `<Compile Remove>` prevents the file from being part of `FastFsm.Net.dll`.
2.  The `<None Include...>` item places the `ExtensionRunner.cs` source file into the `contentFiles/cs/any` folder inside the `.nupkg`.
3.  When a developer installs `FastFsm.Net`, NuGet adds this file to their project's compilation, but as a linked, hidden item.
4.  Crucially, the file is now compiled **as part of the user's project**. It therefore respects the `DefineConstants` of that project. If `FastFsm.Net.Logging` is installed, `FSM_LOGGING_ENABLED` is defined, and the logging blocks inside `ExtensionRunner.cs` are enabled. If not, they are compiled out.

This is a powerful technique for shipping "shared source" that adapts to the consumer's build environment.

-----

## 6\. Future Architectural Considerations: The DI-less Fork

The current `FastFsm.Net` package includes support for `Microsoft.Extensions.DependencyInjection` via `FsmServiceCollectionExtensions.cs`. While this is convenient, it introduces a dependency that might be undesirable in the most resource-constrained environments (e.g., a tiny IoT device running `dotnet` without a host or DI container).

The current architecture makes creating a "DI-less" variant trivial, with zero maintenance overhead for the core generator logic.

**Roadmap:**

1.  **Create `FastFsm.Net.Core`**: Fork the `FastFsm.Net` project.
2.  **Remove DI**: In the new `.csproj`, remove the `PackageReference` to `Microsoft.Extensions.DependencyInjection`.
3.  **Delete DI Code**: Delete the `StateMachine.DependencyInjection` folder (`FsmServiceCollectionExtensions.cs`, `StateMachineFactory.cs`).
4.  **Publish**: Publish this as a new, leaner package.

The `Generator`, `Abstractions`, and the core generation logic remain **completely unchanged**. The modular design isolates the DI concern, allowing it to be "unplugged" without affecting the rest of the system. This confirms the robustness and flexibility of the chosen architecture.