\# FastFSM Deferred Events - Final Implementation Specification v0.9

\*Complete specification superseding initial deep research proposal\*



\## Executive Summary



This document represents the final, consolidated implementation specification for deferred events in FastFSM 0.9. It incorporates all refinements from the review process, superseding the initial deep research proposal. Key principles maintained: \*\*zero heap allocations\*\*, \*\*minimal performance overhead\*\*, \*\*compile-time safety\*\*, and \*\*full UML 2.5.1 compliance\*\*.



---



\## Part I: Core Architecture



\### 1.1 Attribute Design (Final)



```csharp

// Primary enablement on state machine class

\[EnableDeferredEvents(

&nbsp;   MaxDeferredEvents = 8,  // Fixed buffer size (compile-time constant)

&nbsp;   OverflowPolicy = DeferralOverflowPolicy.DropOldest  // Default policy

)]

public partial class OrderProcessor { }



// Preferred syntax: separate attribute for clarity

\[State(OrderState.Processing)]

\[DefersEvents(OrderTrigger.Cancel, OrderTrigger.UpdateAddress)]

private void ConfigureProcessing() { }



// Alternative syntax (backward compatibility)

\[State(OrderState.Processing, 

&nbsp;   DeferredEvents = new\[] { OrderTrigger.Cancel, OrderTrigger.UpdateAddress })]

private void ConfigureProcessingAlt() { }

```



\### 1.2 Overflow Policy



```csharp

public enum DeferralOverflowPolicy

{

&nbsp;   DropOldest,      // Default: overwrite oldest event

&nbsp;   DropNewest,      // Reject new events when full

&nbsp;   ThrowException   // DEBUG only; maps to DropNewest in RELEASE

}

```



\### 1.3 Data Structures (Zero-Allocation)



```csharp

// Generated fields (only when HasDeferredEvents = true)

private int \_deferHead = 0;

private int \_deferCount = 0;

private readonly (TTrigger Trigger, object? Payload)\[] \_deferQueue = 

&nbsp;   new (TTrigger, object?)\[MAX\_DEFERRED\_EVENTS];



// For enum triggers: O(1) deferral check via bitmask

// NOTE: For sparse enums or >64 triggers, see trigger ordinal mapping below

private static readonly ulong\[] s\_deferredMaskByState = new ulong\[] {

&nbsp;   /\* State.A \*/ 0b0001,  // Defers trigger at ordinal 0

&nbsp;   /\* State.B \*/ 0b0000,  // No deferrals

&nbsp;   // ...

};



// Trigger ordinal mapping for sparse/large enums (generated when needed)

// Maps actual enum values to compact 0..N-1 range

private static readonly int\[] s\_triggerOrdinals = new int\[(int)TTrigger.MaxValue + 1];



// Alternative for >64 triggers: chunked bitmask

private static readonly ulong\[]\[] s\_deferredChunkedMaskByState = new ulong\[]\[] {

&nbsp;   /\* State.A \*/ new\[] { 0x0001, 0x0000 },  // 128 bits total

&nbsp;   /\* State.B \*/ new\[] { 0x0000, 0x0000 },

&nbsp;   // ...

};

```



\*\*Trigger Ordinal Mapping Strategy\*\*:

\- \*\*Dense enums (≤64 values, sequential)\*\*: Direct bitmask using enum value

\- \*\*Sparse enums\*\*: Compact mapping via `s\_triggerOrdinals` array

\- \*\*Large enums (>64)\*\*: Either chunked bitmask or fallback to inline if-chain

\- \*\*Compile-time warning\*\*: Emitted when approaching 64-trigger limit



---



\## Part II: Critical Design Decisions



\### 2.1 Boxing Prevention (MANDATORY)



\*\*Rule\*\*: Deferred events are allowed \*\*ONLY\*\* for:

\- Triggers without payload

\- Triggers with reference-type payload



\*\*Compile-time validation\*\*:

```csharp

// In StateMachineModelBuilder

// NOTE: Get payload type from trigger model, not transition (deferral may have no local transition)

foreach (var (state, deferredTriggers) in Model.DeferredByState)

{

&nbsp;   foreach (var trigger in deferredTriggers)

&nbsp;   {

&nbsp;       // Get type from global trigger metadata

&nbsp;       var payloadType = Model.TriggerPayloadTypes?.GetValueOrDefault(trigger);

&nbsp;       

&nbsp;       if (payloadType?.IsValueType == true)

&nbsp;       {

&nbsp;           context.ReportDiagnostic(Diagnostic.Create(

&nbsp;               FSM\_ERR\_DEFERRED\_VALUE\_TYPE,

&nbsp;               location,

&nbsp;               "Cannot defer trigger '{0}' with value-type payload '{1}' (would cause boxing)",

&nbsp;               trigger,

&nbsp;               payloadType.Name

&nbsp;           ));

&nbsp;       }

&nbsp;   }

}

```



\### 2.2 Iterative Recall (NO RECURSION)



\*\*Critical change from initial proposal\*\*: Replace recursive `RecallDeferredEvents()` with iterative RTC loop.



```csharp

protected override bool TryFireInternal(TTrigger trigger, object? payload)

{

&nbsp;   var curTrigger = trigger;

&nbsp;   var curPayload = payload;



&nbsp;   while (true)

&nbsp;   {

&nbsp;       // Core transition logic (without recall/deferral handling)

&nbsp;       bool success = TryFireImmediate(curTrigger, curPayload);

&nbsp;       

&nbsp;       if (!success) 

&nbsp;           return false;  // Not handled and not deferred

&nbsp;       

&nbsp;       // After successful transition: check for deferred events

&nbsp;       if (\_deferCount == 0) 

&nbsp;           return true;

&nbsp;       

&nbsp;       // Peek at queue front

&nbsp;       var (nextTrigger, nextPayload) = \_deferQueue\[\_deferHead];

&nbsp;       

&nbsp;       // If still deferred in new state, stop RTC

&nbsp;       if (IsDeferredInState(CurrentState, nextTrigger)) 

&nbsp;           return true;

&nbsp;       

&nbsp;       // Dequeue and continue RTC with recalled event

&nbsp;       \_deferHead = (\_deferHead + 1) % \_deferQueue.Length;

&nbsp;       \_deferCount--;

&nbsp;       curTrigger = nextTrigger;

&nbsp;       curPayload = nextPayload;

&nbsp;       // Loop continues with recalled event

&nbsp;   }

}

```



\### 2.3 HSM Implementation (UML Compliant)



\*\*Critical correction\*\*: Must check deferral at \*\*every hierarchy level\*\*, not just leaf.



```csharp

// Generated HSM traversal with deferral checks

private bool TryFireImmediate(TTrigger trigger, object? payload)

{

&nbsp;   int stateIndex = (int)CurrentState;

&nbsp;   

&nbsp;   // Quick check: leaf state defers?

&nbsp;   if (IsDeferredInState(stateIndex, trigger))

&nbsp;   {

&nbsp;       EnqueueDeferred(trigger, payload);

&nbsp;       return true;

&nbsp;   }

&nbsp;   

&nbsp;   // Walk up hierarchy

&nbsp;   while (stateIndex >= 0)

&nbsp;   {

&nbsp;       var state = (TState)stateIndex;

&nbsp;       

&nbsp;       switch (state)

&nbsp;       {

&nbsp;           case State.ChildA:

&nbsp;               switch (trigger)

&nbsp;               {

&nbsp;                   case Trigger.X:

&nbsp;                       // Execute transition...

&nbsp;                       return true;

&nbsp;                   

&nbsp;                   default:

&nbsp;                       // Check if THIS level defers

&nbsp;                       if (IsDeferredInState(stateIndex, trigger))

&nbsp;                       {

&nbsp;                           EnqueueDeferred(trigger, payload);

&nbsp;                           return true;

&nbsp;                       }

&nbsp;                       break;  // Continue to parent

&nbsp;               }

&nbsp;               break;

&nbsp;           // ... other states

&nbsp;       }

&nbsp;       

&nbsp;       // Move to parent

&nbsp;       stateIndex = (uint)stateIndex < (uint)s\_parent.Length 

&nbsp;           ? s\_parent\[stateIndex] 

&nbsp;           : -1;

&nbsp;   }

&nbsp;   

&nbsp;   return false;  // No transition and not deferred

}

```



\*\*UML Compliance\*\*: 

\- If child defers event X → X is deferred (parent's transition on X ignored)

\- If parent defers event X → X is deferred when coming from non-handling child

\- Deferral at any level stops upward propagation



---



\## Part III: Code Generation Strategy



\### 3.1 Generator Modifications



\*\*File: `UnifiedStateMachineGenerator.cs`\*\*



\#### A. Model Building Phase

```csharp

// In StateMachineModelBuilder

private void ProcessDeferralAttributes(INamedTypeSymbol classSymbol)

{

&nbsp;   // Check for \[EnableDeferredEvents]

&nbsp;   var enableAttr = classSymbol.GetAttributes()

&nbsp;       .FirstOrDefault(a => a.AttributeClass.Name == "EnableDeferredEventsAttribute");

&nbsp;   

&nbsp;   if (enableAttr != null)

&nbsp;   {

&nbsp;       Model.HasDeferredEvents = true;

&nbsp;       Model.MaxDeferredEvents = GetNamedArgument(enableAttr, "MaxDeferredEvents", 8);

&nbsp;       Model.OverflowPolicy = GetNamedArgument(enableAttr, "OverflowPolicy", 

&nbsp;           DeferralOverflowPolicy.DropOldest);

&nbsp;   }

&nbsp;   

&nbsp;   // Process \[DefersEvents] and \[State].DeferredEvents

&nbsp;   foreach (var stateConfig in Model.States)

&nbsp;   {

&nbsp;       var deferrals = CollectDeferralsForState(stateConfig);

&nbsp;       if (deferrals.Any())

&nbsp;       {

&nbsp;           ValidateDeferrals(stateConfig, deferrals);  // Check for value types

&nbsp;           Model.DeferredByState\[stateConfig.Name] = deferrals;

&nbsp;       }

&nbsp;   }

}

```



\#### B. Field Generation

```csharp

private void WriteFields(string className)

{

&nbsp;   // Existing fields...

&nbsp;   

&nbsp;   if (Model.HasDeferredEvents)

&nbsp;   {

&nbsp;       Sb.AppendLine($"    private int \_deferHead = 0;");

&nbsp;       Sb.AppendLine($"    private int \_deferCount = 0;");

&nbsp;       Sb.AppendLine($"    private readonly ({triggerType} Trigger, object? Payload)\[] \_deferQueue = ");

&nbsp;       Sb.AppendLine($"        new ({triggerType}, object?)\[{Model.MaxDeferredEvents}];");

&nbsp;       Sb.AppendLine();

&nbsp;       

&nbsp;       // Choose deferral check strategy based on trigger characteristics

&nbsp;       if (Model.TriggerType.IsEnum)

&nbsp;       {

&nbsp;           var enumValues = Enum.GetValues(Model.TriggerType);

&nbsp;           var maxValue = enumValues.Cast<int>().Max();

&nbsp;           var count = enumValues.Length;

&nbsp;           var density = (double)count / (maxValue + 1);

&nbsp;           

&nbsp;           if (count <= 64 \&\& density > 0.5)

&nbsp;           {

&nbsp;               // Dense enum ≤64: direct bitmask

&nbsp;               WriteDeferralBitmask();

&nbsp;           }

&nbsp;           else if (count <= 64)

&nbsp;           {

&nbsp;               // Sparse enum: ordinal mapping + bitmask

&nbsp;               WriteTriggerOrdinalMapping();

&nbsp;               WriteDeferralBitmask();

&nbsp;           }

&nbsp;           else if (count <= 256)

&nbsp;           {

&nbsp;               // Large enum: chunked bitmask

&nbsp;               WriteDeferralChunkedBitmask();

&nbsp;           }

&nbsp;           else

&nbsp;           {

&nbsp;               // Very large: fallback to inline checks

&nbsp;               // No static structures needed

&nbsp;               EmitCompileTimeWarning("FSM203", 

&nbsp;                   $"Trigger enum has {count} values - using inline checks for deferrals");

&nbsp;           }

&nbsp;       }

&nbsp;   }

}

```



\#### C. Method Splitting

```csharp

private void WriteTryFireMethodSync(string stateType, string triggerType)

{

&nbsp;   if (Model.HasDeferredEvents)

&nbsp;   {

&nbsp;       // Generate iterative wrapper

&nbsp;       WriteTryFireWithDeferralSupport(stateType, triggerType);

&nbsp;       // Generate core logic without deferral

&nbsp;       WriteTryFireImmediate(stateType, triggerType);

&nbsp;   }

&nbsp;   else

&nbsp;   {

&nbsp;       // Original implementation

&nbsp;       base.WriteTryFireMethodSync(stateType, triggerType);

&nbsp;   }

}

```



\### 3.2 Helper Methods (Generated)



```csharp

// O(1) deferral check with support for sparse/large enums

\[MethodImpl(MethodImplOptions.AggressiveInlining)]

private static bool IsDeferredInState(int stateOrdinal, TTrigger trigger)

{

&nbsp;   if ((uint)stateOrdinal >= (uint)s\_deferredMaskByState.Length)

&nbsp;       return false;

&nbsp;   

&nbsp;   // Strategy depends on trigger characteristics (compile-time decision)

&nbsp;   

&nbsp;   // Option 1: Dense enum ≤64 - direct bitmask

&nbsp;   ulong mask = s\_deferredMaskByState\[stateOrdinal];

&nbsp;   return (mask \& (1UL << (int)trigger)) != 0;

&nbsp;   

&nbsp;   // Option 2: Sparse enum - mapped ordinals

&nbsp;   int ordinal = s\_triggerOrdinals\[(int)trigger];

&nbsp;   if (ordinal < 0) return false;  // -1 = not mapped

&nbsp;   ulong mask = s\_deferredMaskByState\[stateOrdinal];

&nbsp;   return (mask \& (1UL << ordinal)) != 0;

&nbsp;   

&nbsp;   // Option 3: Large enum >64 - chunked bitmask

&nbsp;   int ordinal = (int)trigger;

&nbsp;   int chunk = ordinal / 64;

&nbsp;   int bit = ordinal % 64;

&nbsp;   if (chunk >= s\_deferredChunkedMaskByState\[stateOrdinal].Length)

&nbsp;       return false;

&nbsp;   ulong mask = s\_deferredChunkedMaskByState\[stateOrdinal]\[chunk];

&nbsp;   return (mask \& (1UL << bit)) != 0;

&nbsp;   

&nbsp;   // Option 4: Fallback for very sparse - inline if-chain (generated)

&nbsp;   // Generator emits: if (trigger == Trigger.X || trigger == Trigger.Y) return true;

&nbsp;   // This is fastest for ≤3 deferrals per state

}



// Queue management with overflow policy (compile-time resolved)

private void EnqueueDeferred(TTrigger trigger, object? payload)

{

&nbsp;   if (\_deferCount < \_deferQueue.Length)

&nbsp;   {

&nbsp;       // Space available

&nbsp;       int tail = (\_deferHead + \_deferCount) % \_deferQueue.Length;

&nbsp;       \_deferQueue\[tail] = (trigger, payload);

&nbsp;       \_deferCount++;

&nbsp;   }

&nbsp;   else

&nbsp;   {

&nbsp;       // Queue full - only selected policy branch is generated

&nbsp;       // Generator emits ONLY the branch for Model.OverflowPolicy

&nbsp;       

&nbsp;       // If OverflowPolicy == DropOldest (generated code):

&nbsp;       \_deferQueue\[\_deferHead] = (trigger, payload);

&nbsp;       \_deferHead = (\_deferHead + 1) % \_deferQueue.Length;

&nbsp;       #if DEBUG

&nbsp;       \_logger?.LogWarning("Deferred event queue full, dropped oldest event");

&nbsp;       #endif

&nbsp;       

&nbsp;       // OR if OverflowPolicy == DropNewest (generated code):

&nbsp;       // (nothing - just return)

&nbsp;       #if DEBUG

&nbsp;       \_logger?.LogWarning("Deferred event queue full, dropped new event");

&nbsp;       #endif

&nbsp;       

&nbsp;       // OR if OverflowPolicy == ThrowException (generated code):

&nbsp;       #if DEBUG

&nbsp;       throw new InvalidOperationException(

&nbsp;           $"Deferred event queue full (capacity: {\_deferQueue.Length})");

&nbsp;       #else

&nbsp;       // In RELEASE, fallback to DropNewest (no string interpolation!)

&nbsp;       // (nothing - just return)

&nbsp;       #endif

&nbsp;   }

}

```



\### 3.3 Debug Support



```csharp

// Properties for monitoring (always available, zero-cost)

public int DeferredEventCount => \_deferCount;

public int DeferredCapacity => \_deferQueue.Length;



// Debug-only helpers

\[System.Diagnostics.Conditional("DEBUG")]

public void DumpDeferredQueue(ILogger? logger = null)

{

&nbsp;   if (logger == null) return;

&nbsp;   

&nbsp;   logger.LogDebug($"Deferred queue ({\_deferCount}/{\_deferQueue.Length}):");

&nbsp;   for (int i = 0; i < \_deferCount; i++)

&nbsp;   {

&nbsp;       int idx = (\_deferHead + i) % \_deferQueue.Length;

&nbsp;       var (t, p) = \_deferQueue\[idx];

&nbsp;       logger.LogDebug($"  \[{i}]: {t} (payload: {p?.GetType().Name ?? "null"})");

&nbsp;   }

}



// Optional event hook (debug builds only)

\#if DEBUG

private Action<TTrigger>? \_onEventDeferred;



\[System.Diagnostics.Conditional("DEBUG")]

public void SetOnEventDeferred(Action<TTrigger>? callback) 

&nbsp;   => \_onEventDeferred = callback;

\#endif

```



---



\## Part IV: Integration Points



\### 4.1 Flat FSM Integration



```csharp

// In WriteTryFireStructureFlat

foreach (var stateGroup in transitionsByState)

{

&nbsp;   Sb.AppendLine($"case {stateType}.{stateGroup.Key}:");

&nbsp;   Sb.AppendLine("    switch (trigger) {");

&nbsp;   

&nbsp;   foreach (var transition in stateGroup)

&nbsp;   {

&nbsp;       // Check for deferral collision

&nbsp;       if (Model.DeferralCollisions.Contains((stateGroup.Key, transition.Trigger)))

&nbsp;       {

&nbsp;           Sb.AppendLine($"        // NOTE: {transition.Trigger} is also deferred but transition takes precedence (UML)");

&nbsp;       }

&nbsp;       // Normal transition cases...

&nbsp;   }

&nbsp;   

&nbsp;   Sb.AppendLine("        default:");

&nbsp;   if (Model.HasDeferredEvents \&\& 

&nbsp;       Model.DeferredByState.TryGetValue(stateGroup.Key, out var deferred))

&nbsp;   {

&nbsp;       // Generate deferral check (excluding triggers with transitions)

&nbsp;       var actualDeferred = deferred.Except(

&nbsp;           Model.Transitions.Where(t => t.FromState == stateGroup.Key)

&nbsp;                           .Select(t => t.Trigger));

&nbsp;       

&nbsp;       if (actualDeferred.Any())

&nbsp;       {

&nbsp;           // For ≤3 triggers: inline if-chain (fastest)

&nbsp;           if (actualDeferred.Count() <= 3)

&nbsp;           {

&nbsp;               var conditions = actualDeferred.Select(t => $"trigger == {triggerType}.{t}");

&nbsp;               Sb.AppendLine($"            if ({string.Join(" || ", conditions)})");

&nbsp;               Sb.AppendLine("            {");

&nbsp;               Sb.AppendLine("                EnqueueDeferred(trigger, payload);");

&nbsp;               Sb.AppendLine("                return true;");

&nbsp;               Sb.AppendLine("            }");

&nbsp;           }

&nbsp;           else

&nbsp;           {

&nbsp;               // For >3 triggers: use bitmask helper

&nbsp;               Sb.AppendLine($"            if (IsDeferredInState((int){stateType}.{stateGroup.Key}, trigger))");

&nbsp;               Sb.AppendLine("            {");

&nbsp;               Sb.AppendLine("                EnqueueDeferred(trigger, payload);");

&nbsp;               Sb.AppendLine("                return true;");

&nbsp;               Sb.AppendLine("            }");

&nbsp;           }

&nbsp;       }

&nbsp;   }

&nbsp;   Sb.AppendLine("            break;");

&nbsp;   Sb.AppendLine("    }");

&nbsp;   Sb.AppendLine("    break;");

}

```



\### 4.2 Extensions Integration



When extensions are enabled, prevent false "transition failed" notifications:



```csharp

// Before calling RunAfterTransition with failure

if (Model.HasDeferredEvents \&\& IsDeferredInState(CurrentState, trigger))

{

&nbsp;   EnqueueDeferred(trigger, payload);

&nbsp;   // Optional: notify extension of deferral (new hook)

&nbsp;   \_extensionRunner.RunEventDeferred?(\_extensions, trigger);

&nbsp;   return true;  // Not a failure

}



// Only now notify failure

\_extensionRunner.RunAfterTransition(\_extensions, context, false);

```



---



\## Part V: Validation \& Diagnostics



\### 5.1 Compile-Time Diagnostics



```csharp

// Diagnostic descriptors

private static readonly DiagnosticDescriptor FSM\_ERR\_DEFERRED\_VALUE\_TYPE = new(

&nbsp;   "FSM201",

&nbsp;   "Cannot defer trigger with value-type payload",

&nbsp;   "Trigger '{0}' has value-type payload '{1}' and cannot be deferred (would cause boxing)",

&nbsp;   "FastFSM.DeferredEvents",

&nbsp;   DiagnosticSeverity.Error,

&nbsp;   isEnabledByDefault: true

);



private static readonly DiagnosticDescriptor FSM\_WARN\_DEFERRED\_AND\_TRANSITION = new(

&nbsp;   "FSM202", 

&nbsp;   "Trigger both deferred and handled",

&nbsp;   "State '{0}' both defers and has a transition for trigger '{1}' - transition takes precedence (per UML)",

&nbsp;   "FastFSM.DeferredEvents",

&nbsp;   DiagnosticSeverity.Warning,  // Warning, not Error - valid per UML

&nbsp;   isEnabledByDefault: true

);



// Additional validation during model building

private void ValidateDeferralConsistency()

{

&nbsp;   foreach (var (state, deferredTriggers) in Model.DeferredByState)

&nbsp;   {

&nbsp;       var stateTransitions = Model.Transitions

&nbsp;           .Where(t => t.FromState == state)

&nbsp;           .Select(t => t.Trigger);

&nbsp;       

&nbsp;       foreach (var trigger in deferredTriggers)

&nbsp;       {

&nbsp;           if (stateTransitions.Contains(trigger))

&nbsp;           {

&nbsp;               // Transition takes precedence per UML - emit warning

&nbsp;               context.ReportDiagnostic(Diagnostic.Create(

&nbsp;                   FSM\_WARN\_DEFERRED\_AND\_TRANSITION,

&nbsp;                   location,

&nbsp;                   state,

&nbsp;                   trigger

&nbsp;               ));

&nbsp;               

&nbsp;               // Mark for code comment generation

&nbsp;               Model.DeferralCollisions.Add((state, trigger));

&nbsp;           }

&nbsp;       }

&nbsp;   }

}

```



\### 5.2 Runtime Assertions (DEBUG only)



```csharp

\#if DEBUG

\[System.Diagnostics.Conditional("DEBUG")]

private void AssertDeferralInvariants()

{

&nbsp;   Debug.Assert(\_deferCount >= 0 \&\& \_deferCount <= \_deferQueue.Length);

&nbsp;   Debug.Assert(\_deferHead >= 0 \&\& \_deferHead < \_deferQueue.Length);

&nbsp;   

&nbsp;   // Verify no value types in queue (should be caught at compile-time)

&nbsp;   for (int i = 0; i < \_deferCount; i++)

&nbsp;   {

&nbsp;       var payload = \_deferQueue\[(\_deferHead + i) % \_deferQueue.Length].Payload;

&nbsp;       if (payload != null)

&nbsp;       {

&nbsp;           Debug.Assert(!payload.GetType().IsValueType, 

&nbsp;               "Value type in deferred queue - boxing occurred!");

&nbsp;       }

&nbsp;   }

}

\#endif

```



---



\## Part VI: Performance Guarantees



\### 6.1 Zero-Overhead When Disabled

\- No fields generated

\- No checks in transition paths

\- Identical generated code to v0.8



\### 6.2 Minimal Overhead When Enabled

\- \*\*Memory\*\*: Fixed `N \* (sizeof(Trigger) + sizeof(object)) + 8 bytes` per instance

\- \*\*CPU (unused)\*\*: Single bitmask check in default path (~1ns)

\- \*\*CPU (active)\*\*: O(1) enqueue/dequeue operations (~2-3ns)



\### 6.3 Benchmarking Requirements



```csharp

\[MemoryDiagnoser]

\[SimpleJob(RuntimeMoniker.Net80)]

public class DeferralBenchmarks

{

&nbsp;   \[Benchmark(Baseline = true)]

&nbsp;   public bool NoDefer\_Transition() => fsm.TryFire(Trigger.X);

&nbsp;   

&nbsp;   \[Benchmark]

&nbsp;   public bool WithDefer\_NotDeferred() => fsmDefer.TryFire(Trigger.X);

&nbsp;   

&nbsp;   \[Benchmark] 

&nbsp;   public bool WithDefer\_Deferred() => fsmDefer.TryFire(Trigger.Deferred);

&nbsp;   

&nbsp;   \[Benchmark]

&nbsp;   public bool WithDefer\_Recalled() 

&nbsp;   {

&nbsp;       fsmDefer.TryFire(Trigger.Deferred);  // Defer

&nbsp;       return fsmDefer.TryFire(Trigger.StateChange);  // Recall

&nbsp;   }

}

```



\*\*Success Criteria\*\*:

\- `NoDefer\_Transition` vs `WithDefer\_NotDeferred`: < 5% overhead

\- Zero allocations in all scenarios

\- Recall performance within 2x of direct transition



---



\## Part VII: Implementation Phases



\### Phase 1: Core Implementation (Week 1)

\- \[ ] Attributes and model extensions

\- \[ ] Flat FSM with no-payload triggers

\- \[ ] Basic queue management (DropOldest only)

\- \[ ] Unit tests for FIFO, overflow, basic recall



\### Phase 2: Payload Support (Week 2)

\- \[ ] Reference-type payload support

\- \[ ] Value-type compile-time rejection

\- \[ ] Validation diagnostics

\- \[ ] Extended test coverage



\### Phase 3: HSM Integration (Week 3)

\- \[ ] Hierarchical deferral checks

\- \[ ] Parent-child deferral tests

\- \[ ] UML compliance validation



\### Phase 4: Polish \& Performance (Week 4)

\- \[ ] All overflow policies

\- \[ ] Debug helpers and diagnostics

\- \[ ] Performance benchmarks

\- \[ ] Documentation and examples



---



\## Part VIII: Test Scenarios



\### 8.1 Basic Functionality

```csharp

\[Test]

public void DeferredEvent\_IsRecalledAfterTransition()

{

&nbsp;   var fsm = new TestFSM(State.A);

&nbsp;   fsm.Start();

&nbsp;   

&nbsp;   // X is deferred in A

&nbsp;   Assert.True(fsm.TryFire(Trigger.X));

&nbsp;   Assert.Equal(State.A, fsm.CurrentState);

&nbsp;   Assert.Equal(1, fsm.DeferredEventCount);

&nbsp;   

&nbsp;   // Y transitions A->B, X is recalled and transitions B->C

&nbsp;   Assert.True(fsm.TryFire(Trigger.Y));

&nbsp;   Assert.Equal(State.C, fsm.CurrentState);

&nbsp;   Assert.Equal(0, fsm.DeferredEventCount);

}

```



\### 8.2 HSM Compliance

```csharp

\[Test]

public void ChildDeferral\_BlocksParentTransition()

{

&nbsp;   // Parent has transition on X, Child defers X

&nbsp;   var hsm = new HierarchicalFSM(State.Parent\_Child);

&nbsp;   hsm.Start();

&nbsp;   

&nbsp;   Assert.True(hsm.TryFire(Trigger.X));

&nbsp;   Assert.Equal(State.Parent\_Child, hsm.CurrentState);  // Still in child

&nbsp;   Assert.Equal(1, hsm.DeferredEventCount);  // X deferred, not handled by parent

}

```



\### 8.3 Zero Allocation Verification

```csharp

\[Test]

public void DeferralCycle\_ZeroAllocations()

{

&nbsp;   var fsm = new TestFSM(State.A);

&nbsp;   fsm.Start();

&nbsp;   

&nbsp;   var before = GC.GetTotalAllocatedBytes();

&nbsp;   

&nbsp;   for (int i = 0; i < 1000; i++)

&nbsp;   {

&nbsp;       fsm.TryFire(Trigger.Defer);

&nbsp;       fsm.TryFire(Trigger.Transition);

&nbsp;   }

&nbsp;   

&nbsp;   var after = GC.GetTotalAllocatedBytes();

&nbsp;   Assert.Equal(before, after);  // Zero allocations

}

```



---



\## Appendix A: Naming Conventions



\- `TryFireInternal` → Main entry with RTC loop

\- `TryFireImmediate` → Core logic without deferral/recall (formerly `TryFireCore`)

\- `IsDeferredInState` → O(1) deferral check

\- `EnqueueDeferred` → Add to queue with overflow handling

\- `\_deferQueue` → Internal circular buffer

\- `s\_deferredMaskByState` → Static bitmask array



\## Appendix B: Future Considerations



1\. \*\*Generic Queue\*\* (C# vNext with union types):

&nbsp;  ```csharp

&nbsp;  private DeferredQueue<TTrigger, TPayload> \_deferQueue;

&nbsp;  ```



2\. \*\*Value Type Support\*\* (v1.0+):

&nbsp;  - Per-trigger typed storage to avoid boxing

&nbsp;  - Significantly more complex generator



3\. \*\*Orthogonal Regions\*\* (if FastFSM adds them):

&nbsp;  - UML: consumption wins over deferral

&nbsp;  - Would require queue per region



\## Appendix C: Implementation Notes (v0.9 Updates)



\### Key Refinements from Review

1\. \*\*Trigger Ordinal Mapping\*\*: Handles sparse/large enums efficiently

2\. \*\*Compile-Time Overflow Policy\*\*: Only selected branch generated (no runtime switch)

3\. \*\*Payload Type from Trigger Model\*\*: Not from transition (handles deferred-only triggers)

4\. \*\*Deferral vs Transition Collision\*\*: Warning + code comment (transition wins per UML)

5\. \*\*Inline vs Bitmask Decision\*\*: ≤3 deferrals use inline if-chain (faster than bitmask)



\### Performance Optimizations

\- \*\*Dense enums (≤64)\*\*: Direct bitmask lookup - O(1), ~1ns

\- \*\*Sparse enums\*\*: Ordinal mapping + bitmask - O(1), ~2ns  

\- \*\*Large enums (>64)\*\*: Chunked bitmask - O(1), ~3ns

\- \*\*Very sparse (≤3 per state)\*\*: Inline if-chain - O(n), ~0.5ns per check



---



\*\*Document Status\*\*: FINAL - Ready for implementation  

\*\*Supersedes\*\*: Initial Deep Research Proposal  

\*\*Version\*\*: 0.9-FINAL (with refinements)

