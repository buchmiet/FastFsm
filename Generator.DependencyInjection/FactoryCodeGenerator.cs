using Generator.Model;
using IndentedStringBuilder;
using System;
using System.Collections.Generic;
using System.Linq;
using Generator.Model.Dtos;

namespace Generator.DependencyInjection
{

        /// <summary>
        /// Generuje fabrykę oraz metody rozszerzeń dla kontenera DI na podstawie gotowego,
        /// wstępnie przetworzonego modelu danych.
        /// </summary>
        public sealed class FactoryCodeGenerator(FactoryGenerationModel model)
        {
            #region String Constants
            private const string FactorySuffix = "Factory";
            private const string ServiceProviderField = "_serviceProvider";
            private const string ActivatorUtilitiesClass = "Microsoft.Extensions.DependencyInjection.ActivatorUtilities";
            private const string ServiceCollectionExtensionsSuffix = "ServiceCollectionExtensions";
            private const string StateMachineContractsNamespace = "StateMachine.Contracts";
            private const string StateMachineFactoryInterface = "IStateMachineFactory";
            private const string StateMachineWithPayloadFactoryInterface = "IStateMachineWithPayloadFactory";
            private const string StateMachineDINamespace = "StateMachine.DependencyInjection";
            private const string InitialStateProviderInterface = "IInitialStateProvider";
            private const string DINamespace = "Microsoft.Extensions.DependencyInjection";
            #endregion

            private readonly FactoryGenerationModel _model = model ?? throw new ArgumentNullException(nameof(model));
            private readonly IndentedStringBuilder.IndentedStringBuilder _sb = new();

            public string Generate()
            {
                WriteHeader();
                WriteContent();
                return _sb.ToString();
            }

            private void WriteHeader()
            {
                _sb.AppendLine("// <auto-generated/>");
                _sb.AppendLine("#nullable enable");
                _sb.AppendLine();

                foreach (var ns in _model.AllRequiredNamespaces)
                {
                    _sb.AppendLine($"using {ns};");
                }

                _sb.AppendLine();
            }

            private void WriteContent()
            {
                var stateTypeSimple = _model.StateType.UsageName;
                var triggerTypeSimple = _model.TriggerType.UsageName;
                var userNamespace = _model.UserNamespace;
                var className = _model.ClassName;

                var hasNamespace = !string.IsNullOrEmpty(userNamespace);
                if (hasNamespace)
                {
                    using (_sb.Block($"namespace {userNamespace!}"))
                    {
                        WriteFactory(className, stateTypeSimple, triggerTypeSimple);
                    }
                }
                else
                {
                    WriteFactory(className, stateTypeSimple, triggerTypeSimple);
                }

                _sb.AppendLine();

                using (_sb.Block($"namespace {DINamespace}"))
                {
                    WriteExtensionMethods(className, userNamespace);
                }
            }

            private void WriteFactory(string className, string stateTypeSimple, string triggerTypeSimple)
            {
                _sb.WriteSummary($"Factory for creating {className} instances");

                string factoryInterface;
                if (_model.IsSinglePayloadVariant)
                {
                    var payloadType = _model.PayloadType!.UsageName;
                    factoryInterface = $": {StateMachineContractsNamespace}.{StateMachineWithPayloadFactoryInterface}<I{className}, {stateTypeSimple}, {triggerTypeSimple}, {payloadType}>";
                }
                else
                {
                    factoryInterface = $": {StateMachineContractsNamespace}.{StateMachineFactoryInterface}<I{className}, {stateTypeSimple}, {triggerTypeSimple}>";
                }

                using (_sb.Block($"internal sealed class {className}{FactorySuffix} {factoryInterface}"))
                {
                    WriteFactoryFields();
                    WriteFactoryConstructor(className);
                    WriteCreateMethod(className, stateTypeSimple);
                    WritePayloadCreateMethodIfNeeded(className, stateTypeSimple);
                }
            }

            private void WriteFactoryFields()
            {
                _sb.AppendLine($"private readonly IServiceProvider {ServiceProviderField};");
                _sb.AppendLine();
            }

            private void WriteFactoryConstructor(string className)
            {
                using (_sb.Block($"public {className}{FactorySuffix}(IServiceProvider serviceProvider)"))
                {
                    _sb.AppendLine($"{ServiceProviderField} = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));");
                }
                _sb.AppendLine();
            }

            private void WriteCreateMethod(string className, string stateTypeSimple)
            {
                using (_sb.Block($"public I{className} Create({stateTypeSimple} initialState)"))
                {
                    var instanceParams = new List<string> { ServiceProviderField, "initialState" };

                    if (_model.ShouldGenerateLogging)
                    {
                        _sb.AppendLine($"var logger = {ServiceProviderField}.GetService<ILogger<{className}>>();");
                        _sb.AppendLine();
                        instanceParams.Add("logger");
                    }

                    switch (_model.Variant)
                    {
                        case GenerationVariant.WithExtensions:
                        case GenerationVariant.Full:
                            _sb.AppendLine("// Get all registered extensions from DI");
                            _sb.AppendLine($"var extensions = {ServiceProviderField}.GetServices<{StateMachineContractsNamespace}.IStateMachineExtension>();");
                            _sb.AppendLine();
                            // Logger jest już na liście, jeśli trzeba. Dodajemy rozszerzenia przed nim.
                            instanceParams.Insert(2, "extensions");
                            break;

                        case GenerationVariant.Pure:
                        case GenerationVariant.Basic:
                        case GenerationVariant.WithPayload:
                            // Nic więcej nie trzeba robić
                            break;

                        default:
                            _sb.AppendLine($"throw new NotSupportedException(\"Variant {_model.Variant} not supported\");");
                            return;
                    }

                    _sb.AppendLine($"return {ActivatorUtilitiesClass}.CreateInstance<{className}>({string.Join(", ", instanceParams)});");
                }
                _sb.AppendLine();
            }

            private void WritePayloadCreateMethodIfNeeded(string className, string stateTypeSimple)
            {
                if (_model.IsSinglePayloadVariant)
                {
                    var payloadType = _model.PayloadType!.UsageName;
                    using (_sb.Block($"public I{className} Create({stateTypeSimple} initialState, {payloadType} defaultPayload)"))
                    {
                        _sb.AppendLine("// Create instance normally - payload can be passed to transitions");
                        _sb.AppendLine("return Create(initialState);");
                    }
                }
            }

            private void WriteExtensionMethods(string className, string? userNamespace)
            {
                var fullFactoryName = string.IsNullOrEmpty(userNamespace)
                    ? $"{className}{FactorySuffix}"
                    : $"{userNamespace}.{className}{FactorySuffix}";

                var fullInterfaceName = string.IsNullOrEmpty(userNamespace)
                    ? $"I{className}"
                    : $"{userNamespace}.I{className}";

                var fullStateType = _model.StateType.TypeOfName;
                var fullTriggerType = _model.TriggerType.TypeOfName;

                _sb.WriteSummary($"Extension methods for registering {className} with dependency injection");
                using (_sb.Block($"public static class {className}{ServiceCollectionExtensionsSuffix}"))
                {
                    WriteMainRegistrationMethod(className, fullFactoryName, fullInterfaceName, fullStateType, fullTriggerType);
                    WriteInitialStateFactoryOverload(className, fullStateType);

                    if (_model.IsSinglePayloadVariant)
                    {
                        WriteSinglePayloadRegistrationMethod(className, fullStateType);
                    }
                }
            }

            private void WriteMainRegistrationMethod(string className, string fullFactoryName, string fullInterfaceName, string fullStateType, string fullTriggerType)
            {
                _sb.WriteSummary($"Registers {className} with the service collection");
                var methodParams = $"this IServiceCollection services,\n    {fullStateType}? initialState = null,\n    ServiceLifetime lifetime = ServiceLifetime.Singleton";
                using (_sb.Block($"public static IServiceCollection Add{className}({methodParams})"))
                {
                    _sb.AppendLine("if (services == null) throw new ArgumentNullException(nameof(services));");
                    _sb.AppendLine();

                    WriteFactoryRegistration(fullFactoryName, fullInterfaceName, fullStateType, fullTriggerType);
                    WriteStateMachineRegistration(fullInterfaceName, fullStateType);

                    _sb.AppendLine("return services;");
                }
            }

            private void WriteFactoryRegistration(string fullFactoryName, string fullInterfaceName, string fullStateType, string fullTriggerType)
            {
                _sb.AppendLine("// Register factory");
                string factoryInterfaceType;
                if (_model.IsSinglePayloadVariant)
                {
                    var payloadType = _model.PayloadType!.TypeOfName;
                    factoryInterfaceType = $"typeof({StateMachineContractsNamespace}.{StateMachineWithPayloadFactoryInterface}<{fullInterfaceName}, {fullStateType}, {fullTriggerType}, {payloadType}>)";
                }
                else
                {
                    factoryInterfaceType = $"typeof({StateMachineContractsNamespace}.{StateMachineFactoryInterface}<{fullInterfaceName}, {fullStateType}, {fullTriggerType}>)";
                }

                _sb.AppendLine("services.Add(new ServiceDescriptor(");
                using (_sb.Indent())
                {
                    _sb.AppendLine($"{factoryInterfaceType},");
                    _sb.AppendLine($"typeof({fullFactoryName}),");
                    _sb.AppendLine("lifetime));");
                }
                _sb.AppendLine();
            }

            private void WriteStateMachineRegistration(string fullInterfaceName, string fullStateType)
            {
                _sb.AppendLine("// Register state machine");
                _sb.AppendLine("services.Add(new ServiceDescriptor(");
                using (_sb.Indent())
                {
                    _sb.AppendLine($"typeof({fullInterfaceName}),");
                    _sb.AppendLine("provider =>");
                    _sb.AppendLine("{");
                    using (_sb.Indent())
                    {
                        WriteFactoryResolution(fullInterfaceName, fullStateType);
                        WriteInitialStateResolution(fullStateType);
                        _sb.AppendLine("return factory.Create(actualInitialState);");
                    }
                    _sb.AppendLine("},");
                    _sb.AppendLine("lifetime));");
                }
                _sb.AppendLine();
            }

            private void WriteFactoryResolution(string fullInterfaceName, string fullStateType)
            {
                string factoryInterface;
                if (_model.IsSinglePayloadVariant)
                {
                    var payloadType = _model.PayloadType!.TypeOfName;
                    factoryInterface = $"{StateMachineContractsNamespace}.{StateMachineWithPayloadFactoryInterface}<{fullInterfaceName}, {fullStateType}, {_model.TriggerType.UsageName}, {payloadType}>";
                }
                else
                {
                    factoryInterface = $"{StateMachineContractsNamespace}.{StateMachineFactoryInterface}<{fullInterfaceName}, {fullStateType}, {_model.TriggerType.UsageName}>";
                }
                _sb.AppendLine($"var factory = provider.GetRequiredService<{factoryInterface}>();");
                _sb.AppendLine();
            }

            private void WriteInitialStateResolution(string fullStateType)
            {
                _sb.AppendLine("// Determine initial state");
                _sb.AppendLine($"{fullStateType} actualInitialState;");
                using (_sb.Block("if (initialState.HasValue)"))
                {
                    _sb.AppendLine("actualInitialState = initialState.Value;");
                }
                _sb.AppendLine("else");
                using (_sb.Indent())
                {
                    _sb.AppendLine("{");
                    _sb.AppendLine($"// Check for registered initial state provider");
                    _sb.AppendLine($"var stateProvider = provider.GetService<{StateMachineDINamespace}.{InitialStateProviderInterface}<{fullStateType}>>();");
                    using (_sb.Block("if (stateProvider != null)"))
                    {
                        _sb.AppendLine("actualInitialState = stateProvider.GetInitialState(provider);");
                    }
                    _sb.AppendLine("else");
                    using (_sb.Indent())
                    {
                        _sb.AppendLine("{");
                        _sb.AppendLine("// Default to first enum value");
                        _sb.AppendLine($"actualInitialState = ({fullStateType})Enum.GetValues(typeof({fullStateType})).GetValue(0)!;");
                        _sb.AppendLine("}");
                    }
                    _sb.AppendLine("}");
                }
                _sb.AppendLine();
            }

            private void WriteInitialStateFactoryOverload(string className, string fullStateType)
            {
                _sb.AppendLine();
                _sb.WriteSummary($"Registers {className} with a factory for initial state");
                var methodParams = $"this IServiceCollection services,\n    Func<IServiceProvider, {fullStateType}> initialStateFactory,\n    ServiceLifetime lifetime = ServiceLifetime.Singleton";
                using (_sb.Block($"public static IServiceCollection Add{className}({methodParams})"))
                {
                    _sb.AppendLine("if (initialStateFactory == null) throw new ArgumentNullException(nameof(initialStateFactory));");
                    _sb.AppendLine();
                    _sb.AppendLine("// Register initial state provider first");
                    _sb.AppendLine($"services.ConfigureStateMachineInitialState(initialStateFactory);");
                    _sb.AppendLine();
                    _sb.AppendLine("// Then register state machine without explicit initial state");
                    _sb.AppendLine($"return services.Add{className}(({fullStateType}?)null, lifetime);");
                }
            }

            private void WriteSinglePayloadRegistrationMethod(string className, string fullStateType)
            {
                if (!_model.IsSinglePayloadVariant) return;

                var simpleName = _model.PayloadType!.SimpleName;

                if (simpleName.Equals("object", StringComparison.OrdinalIgnoreCase))
                    return;

                var payloadType = _model.PayloadType!.TypeOfName;

                _sb.AppendLine();
                _sb.WriteSummary($"Registers {className} with typed payload support");

                var methodParams =
                    $"this IServiceCollection services,\n" +
                    $"    {fullStateType}? initialState = null,\n" +
                    $"    ServiceLifetime lifetime = ServiceLifetime.Singleton";

                using (_sb.Block(
                           $"public static IServiceCollection Add{className}<TPayload>({methodParams}) " +
                           $"where TPayload : {payloadType}"))
                {
                    _sb.AppendLine("// Compile-time payload check");
                    _sb.AppendLine($"return services.Add{className}(initialState, lifetime);");
                }
            }
        }
    }
